# Java 8 Stream API - Complete Tutorial

## üìö Table of Contents

1.  Introduction & Analogy
2.  Stream Creation
3.  Intermediate Operations
4.  Terminal Operations
5.  Memory Visualization
6.  Collectors Deep Dive
7.  Parallel Streams
8.  Interview Problems with Solutions

----------
## üèÅ 1. What is Stream API?

### **Definition**

The **Stream API** in Java 8 is used to process collections of data (like Lists, Sets, or arrays) in a **declarative and functional style**.

Instead of **writing loops**, you **describe what you want to do** with the data.

----------

### **Real-World Analogy**

üß© **Think of a Stream as a Water Pipeline System**:

-   The **source** (like a tank) ‚Üí your data (List, Set, etc.)
    
-   The **intermediate filters** (purifiers) ‚Üí `filter()`, `map()`, `sorted()`
    
-   The **terminal output** (tap) ‚Üí `collect()`, `forEach()`, `count()`
    

üíß Once water (data) passes through the pipeline, it **can‚Äôt be reused** ‚Äî Stream **is consumed once**.
## üåä Introduction & Analogy

### What is a Stream?

**Analogy**: Think of a Stream as a  **conveyor belt in a factory**:

-   Raw materials (data) enter from one end
-   They pass through various processing stations (intermediate operations)
-   Final products come out at the end (terminal operations)
-   The conveyor belt doesn't store items; it just processes them

### Key Characteristics

```
Source ‚Üí [Operation 1] ‚Üí [Operation 2] ‚Üí [Operation 3] ‚Üí Result
  |           ‚Üì              ‚Üì              ‚Üì
Collection  filter()       map()        collect()
           (Intermediate) (Intermediate) (Terminal)
```

**Important Properties:**

1.  **Not a data structure**  - doesn't store elements
2.  **Functional**  - operations produce results but don't modify source
3.  **Lazy evaluation**  - intermediate operations are lazy (executed only when terminal operation is called)
4.  **Possibly unbounded**  - can be infinite
5.  **Consumable**  - can be traversed only once

----------

## üî® Stream Creation

### 1. From Collections

java

```java
// From List
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();

// From Set
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3));
Stream<Integer> stream = set.stream();

// From Map
Map<String, Integer> map = new HashMap<>();
map.put("a", 1);
map.put("b", 2);

Stream<String> keyStream = map.keySet().stream();
Stream<Integer> valueStream = map.values().stream();
Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();
```

### 2. From Arrays

java

```java
String[] array = {"apple", "banana", "cherry"};
Stream<String> stream = Arrays.stream(array);
Stream<String> stream2 = Stream.of("apple", "banana", "cherry");
```

### 3. Using Stream.of()

java

```java
Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5);
Stream<String> empty = Stream.empty();
```

### 4. Using Stream.builder()

java

```java
Stream<String> stream = Stream.<String>builder()
    .add("a")
    .add("b")
    .add("c")
    .build();
```

### 5. Infinite Streams

java

```java
// Generate infinite stream
Stream<Double> randoms = Stream.generate(Math::random);

// Iterate to create sequence
Stream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2);

// With limit (Java 9+)
Stream<Integer> limited = Stream.iterate(0, n -> n < 20, n -> n + 2);
```

----------

## üîÑ Intermediate Operations

**Memory Visualization:**

```
Original List: [1, 2, 3, 4, 5, 6]
         ‚Üì
    filter(n -> n % 2 == 0)  ‚Üê Lazy (not executed yet)
         ‚Üì
    map(n -> n * 2)          ‚Üê Lazy (not executed yet)
         ‚Üì
    sorted()                 ‚Üê Lazy (not executed yet)
         ‚Üì
    collect(toList())        ‚Üê Terminal (triggers execution)
         ‚Üì
Result: [4, 8, 12]
```

### 1. filter() - Filtering Elements

**Analogy**: Like a bouncer at a club - only lets elements through that meet criteria

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Get even numbers
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// Result: [2, 4, 6, 8, 10]

// Multiple filters (chaining)
List<Integer> result = numbers.stream()
    .filter(n -> n > 3)
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// Result: [4, 6, 8, 10]
```

### 2. map() - Transforming Elements

**Analogy**: Like a factory machine that transforms raw material into something else

java

```java
List<String> names = Arrays.asList("alice", "bob", "charlie");

// Convert to uppercase
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
// Result: ["ALICE", "BOB", "CHARLIE"]

// Extract lengths
List<Integer> nameLengths = names.stream()
    .map(String::length)
    .collect(Collectors.toList());
// Result: [5, 3, 7]

// Complex transformation
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30)
);

List<String> descriptions = people.stream()
    .map(p -> p.getName() + " is " + p.getAge())
    .collect(Collectors.toList());
// Result: ["Alice is 25", "Bob is 30"]
```

### 3. flatMap() - Flattening Nested Structures

**Analogy**: Like unpacking boxes within boxes to get all items in one flat surface

**Memory Visualization:**

```
Before flatMap:
[[1, 2], [3, 4], [5, 6]]
     ‚Üì
After flatMap:
[1, 2, 3, 4, 5, 6]
```

java

```java
List<List<Integer>> nestedList = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5),
    Arrays.asList(6, 7, 8)
);

// Flatten the nested list
List<Integer> flattened = nestedList.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// Result: [1, 2, 3, 4, 5, 6, 7, 8]

// Practical example: Get all words from sentences
List<String> sentences = Arrays.asList(
    "Hello World",
    "Java Streams",
    "Are Powerful"
);

List<String> words = sentences.stream()
    .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
    .collect(Collectors.toList());
// Result: ["Hello", "World", "Java", "Streams", "Are", "Powerful"]
```

### 4. distinct() - Remove Duplicates

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5);

List<Integer> unique = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
// Result: [1, 2, 3, 4, 5]
```

### 5. sorted() - Sorting Elements

java

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

// Natural order
List<Integer> sorted = numbers.stream()
    .sorted()
    .collect(Collectors.toList());
// Result: [1, 2, 5, 8, 9]

// Reverse order
List<Integer> reversed = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());
// Result: [9, 8, 5, 2, 1]

// Custom comparator
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> sortedByLength = names.stream()
    .sorted(Comparator.comparing(String::length))
    .collect(Collectors.toList());
// Result: ["Bob", "Alice", "Charlie"]
```

### 6. peek() - Debugging/Side Effects

**Analogy**: Like security cameras on the conveyor belt - observes items passing through

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .peek(n -> System.out.println("Filtered: " + n))
    .map(n -> n * 2)
    .peek(n -> System.out.println("Mapped: " + n))
    .collect(Collectors.toList());
// Output:
// Filtered: 2
// Mapped: 4
// Filtered: 4
// Mapped: 8
```

### 7. limit() & skip()

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Get first 5 elements
List<Integer> first5 = numbers.stream()
    .limit(5)
    .collect(Collectors.toList());
// Result: [1, 2, 3, 4, 5]

// Skip first 3, take next 4
List<Integer> middle = numbers.stream()
    .skip(3)
    .limit(4)
    .collect(Collectors.toList());
// Result: [4, 5, 6, 7]
```

----------

## ‚ö° Terminal Operations

Terminal operations trigger the stream pipeline execution and produce a result.

### 1. collect() - Most Versatile

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// To List
List<String> list = names.stream().collect(Collectors.toList());

// To Set
Set<String> set = names.stream().collect(Collectors.toSet());

// To Map
Map<String, Integer> map = names.stream()
    .collect(Collectors.toMap(
        name -> name,           // key
        String::length          // value
    ));
// Result: {Alice=5, Bob=3, Charlie=7, David=5}

// Joining strings
String joined = names.stream()
    .collect(Collectors.joining(", "));
// Result: "Alice, Bob, Charlie, David"
```

### 2. forEach() - Iteration

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

names.stream()
    .forEach(name -> System.out.println("Hello, " + name));
// Output:
// Hello, Alice
// Hello, Bob
// Hello, Charlie
```

### 3. reduce() - Aggregation

**Analogy**: Like folding a paper - keeps combining elements until one result remains

**Memory Visualization:**

```
[1, 2, 3, 4, 5]
 ‚Üì
1 + 2 = 3
3 + 3 = 6
6 + 4 = 10
10 + 5 = 15
```

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum using reduce
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);
// Result: 15

// Or using method reference
int sum2 = numbers.stream()
    .reduce(0, Integer::sum);

// Product
int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);
// Result: 120

// Finding max
Optional<Integer> max = numbers.stream()
    .reduce((a, b) -> a > b ? a : b);
// Or: .reduce(Integer::max)
```

### 4. count() - Counting Elements

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

long count = names.stream()
    .filter(name -> name.length() > 3)
    .count();
// Result: 2
```

### 5. anyMatch(), allMatch(), noneMatch()

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Check if any element is even
boolean hasEven = numbers.stream()
    .anyMatch(n -> n % 2 == 0);
// Result: true

// Check if all elements are positive
boolean allPositive = numbers.stream()
    .allMatch(n -> n > 0);
// Result: true

// Check if no element is negative
boolean noNegative = numbers.stream()
    .noneMatch(n -> n < 0);
// Result: true
```

### 6. findFirst() & findAny()

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Find first element
Optional<String> first = names.stream()
    .filter(name -> name.startsWith("B"))
    .findFirst();
// Result: Optional[Bob]

// Find any (useful in parallel streams)
Optional<String> any = names.stream()
    .filter(name -> name.length() > 3)
    .findAny();
// Result: Optional[Alice] or Optional[Charlie]
```

### 7. min() & max()

java

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

Optional<Integer> min = numbers.stream()
    .min(Integer::compareTo);
// Result: Optional[1]

Optional<Integer> max = numbers.stream()
    .max(Integer::compareTo);
// Result: Optional[9]

// For custom objects
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 20)
);

Optional<Person> youngest = people.stream()
    .min(Comparator.comparing(Person::getAge));
// Result: Optional[Charlie]
```

----------

## üß† Memory Visualization

### Stream Pipeline Execution

```
List: [1, 2, 3, 4, 5, 6]

Stream Pipeline (Lazy - not executed):
  .filter(n -> n % 2 == 0)
  .map(n -> n * 2)
  .collect(Collectors.toList())

When terminal operation is called:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Element 1: 1                       ‚îÇ
‚îÇ    ‚Üí filter(1 % 2 == 0) = false    ‚îÇ
‚îÇ    ‚Üí SKIP                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Element 2: 2                       ‚îÇ
‚îÇ    ‚Üí filter(2 % 2 == 0) = true     ‚îÇ
‚îÇ    ‚Üí map(2 * 2) = 4                ‚îÇ
‚îÇ    ‚Üí ADD to result: [4]            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Element 3: 3                       ‚îÇ
‚îÇ    ‚Üí filter(3 % 2 == 0) = false    ‚îÇ
‚îÇ    ‚Üí SKIP                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Element 4: 4                       ‚îÇ
‚îÇ    ‚Üí filter(4 % 2 == 0) = true     ‚îÇ
‚îÇ    ‚Üí map(4 * 2) = 8                ‚îÇ
‚îÇ    ‚Üí ADD to result: [4, 8]         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Element 5: 5                       ‚îÇ
‚îÇ    ‚Üí filter(5 % 2 == 0) = false    ‚îÇ
‚îÇ    ‚Üí SKIP                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Element 6: 6                       ‚îÇ
‚îÇ    ‚Üí filter(6 % 2 == 0) = true     ‚îÇ
‚îÇ    ‚Üí map(6 * 2) = 12               ‚îÇ
‚îÇ    ‚Üí ADD to result: [4, 8, 12]     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Final Result: [4, 8, 12]
```

### Short-Circuiting Operations

Operations like  `findFirst()`,  `anyMatch()`  stop processing as soon as result is found:

```
List: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Finding: .filter(n -> n > 5).findFirst()

Process:
1 ‚Üí check (1 > 5) ‚Üí false ‚Üí continue
2 ‚Üí check (2 > 5) ‚Üí false ‚Üí continue
3 ‚Üí check (3 > 5) ‚Üí false ‚Üí continue
4 ‚Üí check (4 > 5) ‚Üí false ‚Üí continue
5 ‚Üí check (5 > 5) ‚Üí false ‚Üí continue
6 ‚Üí check (6 > 5) ‚Üí true  ‚Üí FOUND! STOP!
                            ‚Üì
                         Return 6
(7, 8, 9, 10 are never processed)
```

----------

## üì¶ Collectors Deep Dive

### 1. Grouping

java

```java
class Person {
    String name;
    int age;
    String city;
    // constructor, getters
}

List<Person> people = Arrays.asList(
    new Person("Alice", 25, "NYC"),
    new Person("Bob", 30, "LA"),
    new Person("Charlie", 25, "NYC"),
    new Person("David", 30, "NYC")
);

// Group by age
Map<Integer, List<Person>> byAge = people.stream()
    .collect(Collectors.groupingBy(Person::getAge));
// Result: {25=[Alice, Charlie], 30=[Bob, David]}

// Group by city and count
Map<String, Long> countByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));
// Result: {NYC=3, LA=1}

// Group by age and collect names
Map<Integer, List<String>> namesByAge = people.stream()
    .collect(Collectors.groupingBy(
        Person::getAge,
        Collectors.mapping(Person::getName, Collectors.toList())
    ));
// Result: {25=[Alice, Charlie], 30=[Bob, David]}
```

### 2. Partitioning (Binary Split)

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Partition into even and odd
Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// Result: {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}

// Partition people by age > 25
Map<Boolean, List<Person>> partitionedPeople = people.stream()
    .collect(Collectors.partitioningBy(p -> p.getAge() > 25));
```

### 3. Statistical Collectors

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Summary statistics
IntSummaryStatistics stats = numbers.stream()
    .collect(Collectors.summarizingInt(Integer::intValue));

System.out.println("Count: " + stats.getCount());     // 5
System.out.println("Sum: " + stats.getSum());         // 15
System.out.println("Min: " + stats.getMin());         // 1
System.out.println("Max: " + stats.getMax());         // 5
System.out.println("Average: " + stats.getAverage()); // 3.0

// Average directly
double average = numbers.stream()
    .collect(Collectors.averagingInt(Integer::intValue));
```

### 4. Joining Strings

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Simple join
String joined = names.stream()
    .collect(Collectors.joining());
// Result: "AliceBobCharlie"

// With delimiter
String withComma = names.stream()
    .collect(Collectors.joining(", "));
// Result: "Alice, Bob, Charlie"

// With prefix and suffix
String formatted = names.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// Result: "[Alice, Bob, Charlie]"
```

----------

## ‚ö° Parallel Streams

**Analogy**: Like having multiple workers on an assembly line instead of one

### When to Use Parallel Streams

‚úÖ  **Good for:**

-   Large datasets (thousands of elements)
-   CPU-intensive operations
-   Independent operations (no shared state)

‚ùå  **Bad for:**

-   Small datasets (overhead > benefit)
-   I/O operations
-   Operations with side effects

### Example

java

```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
    .boxed()
    .collect(Collectors.toList());

// Sequential
long start = System.currentTimeMillis();
long sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();
long end = System.currentTimeMillis();
System.out.println("Sequential: " + (end - start) + "ms");

// Parallel
start = System.currentTimeMillis();
sum = numbers.parallelStream()
    .mapToInt(Integer::intValue)
    .sum();
end = System.currentTimeMillis();
System.out.println("Parallel: " + (end - start) + "ms");

// Convert to parallel
Stream<Integer> parallelStream = numbers.stream().parallel();

// Check if parallel
boolean isParallel = parallelStream.isParallel();
```

### Parallel Stream Cautions

java

```java
// ‚ùå WRONG: Race condition
List<Integer> list = new ArrayList<>();
IntStream.range(0, 1000)
    .parallel()
    .forEach(list::add);  // NOT thread-safe!

// ‚úÖ CORRECT: Use thread-safe collection
List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());
IntStream.range(0, 1000)
    .parallel()
    .forEach(syncList::add);

// ‚úÖ BETTER: Use collect
List<Integer> result = IntStream.range(0, 1000)
    .parallel()
    .boxed()
    .collect(Collectors.toList());
```

----------

## üéØ Interview Problems with Solutions

### Problem 1: Find Duplicate Elements

**Question**: Given a list of integers, find all duplicate elements.

java

```java
public static List<Integer> findDuplicates(List<Integer> numbers) {
    return numbers.stream()
        .collect(Collectors.groupingBy(n -> n, Collectors.counting()))
        .entrySet()
        .stream()
        .filter(entry -> entry.getValue() > 1)
        .map(Map.Entry::getKey)
        .collect(Collectors.toList());
}

// Test
List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4, 5, 3, 6);
System.out.println(findDuplicates(numbers)); // [2, 3]
```

### Problem 2: Second Highest Number

**Question**: Find the second highest number in a list.

java

```java
public static Optional<Integer> secondHighest(List<Integer> numbers) {
    return numbers.stream()
        .distinct()
        .sorted(Comparator.reverseOrder())
        .skip(1)
        .findFirst();
}

// Test
List<Integer> numbers = Arrays.asList(5, 2, 8, 8, 1, 9, 3);
System.out.println(secondHighest(numbers)); // Optional[8]
```

### Problem 3: Anagram Grouping

**Question**: Group words that are anagrams of each other.

java

```java
public static Map<String, List<String>> groupAnagrams(List<String> words) {
    return words.stream()
        .collect(Collectors.groupingBy(word -> {
            char[] chars = word.toLowerCase().toCharArray();
            Arrays.sort(chars);
            return new String(chars);
        }));
}

// Test
List<String> words = Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat");
System.out.println(groupAnagrams(words));
// {aet=[eat, tea, ate], ant=[tan, nat], abt=[bat]}
```

### Problem 4: Top K Frequent Elements

**Question**: Find K most frequent elements in a list.

java

```java
public static List<Integer> topKFrequent(List<Integer> nums, int k) {
    return nums.stream()
        .collect(Collectors.groupingBy(n -> n, Collectors.counting()))
        .entrySet()
        .stream()
        .sorted(Map.Entry.<Integer, Long>comparingByValue().reversed())
        .limit(k)
        .map(Map.Entry::getKey)
        .collect(Collectors.toList());
}

// Test
List<Integer> nums = Arrays.asList(1, 1, 1, 2, 2, 3);
System.out.println(topKFrequent(nums, 2)); // [1, 2]
```

### Problem 5: Flatten Nested List

**Question**: Flatten a list of lists into a single list.

java

```java
public static List<Integer> flatten(List<List<Integer>> nested) {
    return nested.stream()
        .flatMap(List::stream)
        .collect(Collectors.toList());
}

// Test
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4, 5),
    Arrays.asList(6)
);
System.out.println(flatten(nested)); // [1, 2, 3, 4, 5, 6]
```

### Problem 6: Remove Nulls and Convert to Uppercase

**Question**: Remove null values and convert all strings to uppercase.

java

```java
public static List<String> cleanAndUppercase(List<String> strings) {
    return strings.stream()
        .filter(Objects::nonNull)
        .map(String::toUpperCase)
        .collect(Collectors.toList());
}

// Test
List<String> strings = Arrays.asList("apple", null, "banana", null, "cherry");
System.out.println(cleanAndUppercase(strings)); // [APPLE, BANANA, CHERRY]
```

### Problem 7: Merge Two Lists Without Duplicates

**Question**: Merge two lists and remove duplicates.

java

```java
public static List<Integer> mergeUnique(List<Integer> list1, List<Integer> list2) {
    return Stream.concat(list1.stream(), list2.stream())
        .distinct()
        .collect(Collectors.toList());
}

// Test
List<Integer> list1 = Arrays.asList(1, 2, 3, 4);
List<Integer> list2 = Arrays.asList(3, 4, 5, 6);
System.out.println(mergeUnique(list1, list2)); // [1, 2, 3, 4, 5, 6]
```

### Problem 8: Employee Salary Statistics

**Question**: Calculate average salary by department and find the department with highest average.

java

```java
class Employee {
    String name;
    String department;
    double salary;
    // constructor, getters
}

public static String departmentWithHighestAvgSalary(List<Employee> employees) {
    return employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.averagingDouble(Employee::getSalary)
        ))
        .entrySet()
        .stream()
        .max(Map.Entry.comparingByValue())
        .map(Map.Entry::getKey)
        .orElse("No department found");
}

// Test
List<Employee> employees = Arrays.asList(
    new Employee("Alice", "IT", 80000),
    new Employee("Bob", "IT", 90000),
    new Employee("Charlie", "HR", 60000),
    new Employee("David", "HR", 55000)
);
System.out.println(departmentWithHighestAvgSalary(employees)); // IT
```

### Problem 9: First Non-Repeated Character

**Question**: Find the first non-repeated character in a string.

java

```java
public static Character firstNonRepeated(String str) {
    return str.chars()
        .mapToObj(c -> (char) c)
        .collect(Collectors.groupingBy(c -> c, LinkedHashMap::new, Collectors.counting()))
        .entrySet()
        .stream()
        .filter(entry -> entry.getValue() == 1)
        .map(Map.Entry::getKey)
        .findFirst()
        .orElse(null);
}

// Test
System.out.println(firstNonRepeated("stress")); // t
```

### Problem 10: Partitioning by Multiple Criteria

**Question**: Partition employees into juniors (age < 30) and seniors, then get average salary for each group.

java

```java
public static Map<String, Double> averageSalaryByLevel(List<Employee> employees) {
    Map<Boolean, List<Employee>> partitioned = employees.stream()
        .collect(Collectors.partitioningBy(e -> e.getAge() < 30));
    
    Map<String, Double> result = new HashMap<>();
    result.put("Junior", partitioned.get(true).stream()
        .mapToDouble(Employee::getSalary)
        .average()
        .orElse(0.0));
    result.put("Senior", partitioned.get(false).stream()
        .mapToDouble(Employee::getSalary)
        .average()
        .orElse(0.0));
    
    return result;
}
```

----------

## üéì Key Takeaways

1.  **Streams don't store data**  - they operate on source data
2.  **Lazy evaluation**  - intermediate operations are not executed until terminal operation
3.  **One-time use**  - streams can only be traversed once
4.  **Immutable**  - operations don't modify source
5.  **Parallel processing**  - easy to parallelize with  `.parallel()`
6.  **Functional style**  - promotes cleaner, more readable code

----------

## üìù Best Practices

‚úÖ  **Do:**

-   Use method references when possible (`String::length`  vs  `s -> s.length()`)
-   Chain operations for readability
-   Use collectors for complex aggregations
-   Prefer  `collect()`  over  `forEach()`  for building collections
-   Use parallel streams for CPU-intensive tasks on large datasets

‚ùå  **Don't:**

-   Modify external state in stream operations
-   Reuse streams (they're one-time use)
-   Ignore Optional results (use proper handling)
-   Use parallel streams for small datasets or I/O operations
-   Overuse streams for simple iterations

----------

## üîç Common Pitfalls

### 1. Reusing Streams

java

```java
// ‚ùå WRONG
Stream<String> stream = list.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println); // IllegalStateException!

// ‚úÖ CORRECT
list.stream().forEach(System.out::println);
list.stream().forEach(System.out::println);
```

### 2. Modifying Source During Stream

java

```java
// ‚ùå WRONG
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
list.stream().forEach(n -> list.add(n * 2)); // ConcurrentModificationException!

// ‚úÖ CORRECT
List<Integer> result = list.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());
```

### 3. Ignoring Optional

java

```java
// ‚ùå WRONG
String name = list.stream()
    .filter(s -> s.startsWith("A"))
    .findFirst()
    .get(); // NoSuchElementException if not found!

// ‚úÖ CORRECT
String name = list.stream()
    .filter(s -> s.startsWith("A"))
    .findFirst()
    .orElse("Default");

// Or check before getting
Optional<String> opt = list.stream()
    .filter(s -> s.startsWith("A"))
    .findFirst();
if (opt.isPresent()) {
    String name = opt.get();
}
```

----------

## üß™ Advanced Interview Problems

### Problem 11: Find All Pairs with Given Sum

**Question**: Find all pairs of numbers in a list that sum to a target value.

java

```java
public static List<List<Integer>> findPairsWithSum(List<Integer> numbers, int target) {
    Set<Integer> seen = new HashSet<>();
    return numbers.stream()
        .filter(n -> {
            int complement = target - n;
            if (seen.contains(complement)) {
                return true;
            }
            seen.add(n);
            return false;
        })
        .map(n -> Arrays.asList(target - n, n))
        .collect(Collectors.toList());
}

// Test
List<Integer> numbers = Arrays.asList(2, 7, 11, 15, 3, 6);
System.out.println(findPairsWithSum(numbers, 9));
// [[2, 7], [3, 6]]
```

### Problem 12: Transform Map Values

**Question**: Given a map of String to List<Integer>, convert it to a map where each list is summed.

java

```java
public static Map<String, Integer> sumMapValues(Map<String, List<Integer>> input) {
    return input.entrySet().stream()
        .collect(Collectors.toMap(
            Map.Entry::getKey,
            entry -> entry.getValue().stream()
                .mapToInt(Integer::intValue)
                .sum()
        ));
}

// Test
Map<String, List<Integer>> input = new HashMap<>();
input.put("A", Arrays.asList(1, 2, 3));
input.put("B", Arrays.asList(4, 5));
System.out.println(sumMapValues(input));
// {A=6, B=9}
```

### Problem 13: Longest String in List

**Question**: Find the longest string(s) in a list. If multiple strings have the same max length, return all.

java

```java
public static List<String> findLongestStrings(List<String> strings) {
    int maxLength = strings.stream()
        .mapToInt(String::length)
        .max()
        .orElse(0);
    
    return strings.stream()
        .filter(s -> s.length() == maxLength)
        .collect(Collectors.toList());
}

// Test
List<String> strings = Arrays.asList("apple", "banana", "cherry", "date");
System.out.println(findLongestStrings(strings));
// [banana, cherry]
```

### Problem 14: Transpose Matrix

**Question**: Transpose a 2D list (matrix).

java

```java
public static List<List<Integer>> transpose(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return Collections.emptyList();
    
    int rows = matrix.size();
    int cols = matrix.get(0).size();
    
    return IntStream.range(0, cols)
        .mapToObj(col -> IntStream.range(0, rows)
            .mapToObj(row -> matrix.get(row).get(col))
            .collect(Collectors.toList()))
        .collect(Collectors.toList());
}

// Test
List<List<Integer>> matrix = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6)
);
System.out.println(transpose(matrix));
// [[1, 4], [2, 5], [3, 6]]
```

### Problem 15: Custom Sorting with Multiple Criteria

**Question**: Sort employees by department (ascending), then by salary (descending), then by name (ascending).

java

```java
public static List<Employee> sortEmployees(List<Employee> employees) {
    return employees.stream()
        .sorted(Comparator
            .comparing(Employee::getDepartment)
            .thenComparing(Comparator.comparing(Employee::getSalary).reversed())
            .thenComparing(Employee::getName))
        .collect(Collectors.toList());
}

// Test
List<Employee> employees = Arrays.asList(
    new Employee("Alice", "IT", 80000),
    new Employee("Bob", "IT", 90000),
    new Employee("Charlie", "HR", 60000),
    new Employee("David", "IT", 90000)
);
// Result: David (IT, 90000), Bob (IT, 90000), Alice (IT, 80000), Charlie (HR, 60000)
```

### Problem 16: Find Missing Numbers in Range

**Question**: Given a list of integers, find all missing numbers in the range [1, n].

java

```java
public static List<Integer> findMissingNumbers(List<Integer> numbers, int n) {
    Set<Integer> numSet = new HashSet<>(numbers);
    return IntStream.rangeClosed(1, n)
        .filter(i -> !numSet.contains(i))
        .boxed()
        .collect(Collectors.toList());
}

// Test
List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);
System.out.println(findMissingNumbers(numbers, 10));
// [2, 4, 6, 8, 10]
```

### Problem 17: Word Frequency Counter

**Question**: Count the frequency of each word in a sentence (case-insensitive).

java

```java
public static Map<String, Long> wordFrequency(String sentence) {
    return Arrays.stream(sentence.toLowerCase().split("\\s+"))
        .filter(word -> !word.isEmpty())
        .collect(Collectors.groupingBy(
            word -> word,
            Collectors.counting()
        ));
}

// Test
String sentence = "the quick brown fox jumps over the lazy dog the fox";
System.out.println(wordFrequency(sentence));
// {the=3, quick=1, brown=1, fox=2, jumps=1, over=1, lazy=1, dog=1}
```

### Problem 18: Partition Students by Pass/Fail

**Question**: Partition students into passed and failed based on average score >= 60.

java

```java
class Student {
    String name;
    List<Integer> scores;
    // constructor, getters
    
    public double getAverage() {
        return scores.stream()
            .mapToInt(Integer::intValue)
            .average()
            .orElse(0.0);
    }
}

public static Map<String, List<String>> partitionStudents(List<Student> students) {
    Map<Boolean, List<Student>> partitioned = students.stream()
        .collect(Collectors.partitioningBy(s -> s.getAverage() >= 60));
    
    Map<String, List<String>> result = new HashMap<>();
    result.put("Passed", partitioned.get(true).stream()
        .map(Student::getName)
        .collect(Collectors.toList()));
    result.put("Failed", partitioned.get(false).stream()
        .map(Student::getName)
        .collect(Collectors.toList()));
    
    return result;
}

// Test
List<Student> students = Arrays.asList(
    new Student("Alice", Arrays.asList(80, 75, 90)),
    new Student("Bob", Arrays.asList(50, 55, 45)),
    new Student("Charlie", Arrays.asList(70, 65, 80))
);
// Result: {Passed=[Alice, Charlie], Failed=[Bob]}
```

### Problem 19: Remove Consecutive Duplicates

**Question**: Remove consecutive duplicate elements from a list.

java

```java
public static List<Integer> removeConsecutiveDuplicates(List<Integer> numbers) {
    return IntStream.range(0, numbers.size())
        .filter(i -> i == 0 || !numbers.get(i).equals(numbers.get(i - 1)))
        .mapToObj(numbers::get)
        .collect(Collectors.toList());
}

// Test
List<Integer> numbers = Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 5);
System.out.println(removeConsecutiveDuplicates(numbers));
// [1, 2, 3, 4, 5]
```

### Problem 20: Custom Collector - Concatenate with Alternating Separator

**Question**: Join strings with alternating separators (, and ;).

java

```java
public static String alternatingJoin(List<String> strings) {
    return IntStream.range(0, strings.size())
        .mapToObj(i -> strings.get(i) + (i < strings.size() - 1 
            ? (i % 2 == 0 ? ", " : "; ") 
            : ""))
        .collect(Collectors.joining());
}

// Test
List<String> strings = Arrays.asList("A", "B", "C", "D", "E");
System.out.println(alternatingJoin(strings));
// "A, B; C, D; E"
```

----------

## üî• Performance Tips

### 1. Use Primitive Streams for Better Performance

java

```java
// ‚ùå Slower (boxing overhead)
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();

// ‚úÖ Faster (no boxing)
int sum = IntStream.rangeClosed(1, 5).sum();

// Available primitive streams
IntStream.range(1, 100);        // int stream
LongStream.range(1L, 100L);     // long stream
DoubleStream.of(1.0, 2.0, 3.0); // double stream
```

### 2. Avoid Unnecessary Boxing/Unboxing

java

```java
// ‚ùå Bad
Stream<Integer> stream = IntStream.range(1, 100).boxed();
int sum = stream.mapToInt(i -> i).sum();

// ‚úÖ Good
int sum = IntStream.range(1, 100).sum();
```

### 3. Use Method References

java

```java
// ‚ùå Verbose
list.stream().map(s -> s.length()).collect(Collectors.toList());

// ‚úÖ Cleaner
list.stream().map(String::length).collect(Collectors.toList());
```

### 4. Limit Stream Size Early

java

```java
// ‚ùå Processes all then limits
list.stream()
    .map(expensiveOperation)
    .filter(condition)
    .limit(10)
    .collect(Collectors.toList());

// ‚úÖ Limits early if possible
list.stream()
    .limit(10)
    .map(expensiveOperation)
    .filter(condition)
    .collect(Collectors.toList());
```

----------

## üìö Cheat Sheet

### Stream Creation

java

```java
Collection.stream()
Arrays.stream(array)
Stream.of(elements)
IntStream.range(start, end)
Stream.generate(supplier)
Stream.iterate(seed, unaryOperator)
```

### Intermediate Operations (Lazy)

java

```java
filter(predicate)           // Filter elements
map(function)               // Transform elements
flatMap(function)           // Flatten nested structures
distinct()                  // Remove duplicates
sorted()                    // Sort elements
sorted(comparator)          // Sort with custom logic
peek(consumer)              // Debug/side effects
limit(n)                    // Take first n elements
skip(n)                     // Skip first n elements
```

### Terminal Operations (Eager)

java

```java
collect(collector)          // Collect to collection
forEach(consumer)           // Iterate
reduce(identity, accumulator) // Aggregate
count()                     // Count elements
anyMatch(predicate)         // Check if any match
allMatch(predicate)         // Check if all match
noneMatch(predicate)        // Check if none match
findFirst()                 // Find first element
findAny()                   // Find any element
min(comparator)             // Find minimum
max(comparator)             // Find maximum
toArray()                   // Convert to array
```

### Common Collectors

java

```java
Collectors.toList()
Collectors.toSet()
Collectors.toMap(keyMapper, valueMapper)
Collectors.joining(delimiter)
Collectors.groupingBy(classifier)
Collectors.partitioningBy(predicate)
Collectors.counting()
Collectors.summingInt(mapper)
Collectors.averagingDouble(mapper)
Collectors.summarizingInt(mapper)
Collectors.maxBy(comparator)
Collectors.minBy(comparator)
```

----------

## üéØ Interview Tips

1.  **Explain the difference between intermediate and terminal operations**
    -   Intermediate: Lazy, return Stream, can be chained
    -   Terminal: Eager, trigger execution, return result
2.  **When to use flatMap vs map**
    -   map: 1-to-1 transformation (T ‚Üí R)
    -   flatMap: 1-to-many transformation (T ‚Üí Stream<R>)
3.  **Explain lazy evaluation**
    -   Operations are not executed until terminal operation is called
    -   Allows optimization and short-circuiting
4.  **Parallel streams pros and cons**
    -   Pros: Faster for CPU-intensive tasks, large datasets
    -   Cons: Overhead for small data, not suitable for I/O operations
5.  **Common mistakes**
    -   Reusing streams
    -   Modifying source during streaming
    -   Not handling Optional properly
    -   Using parallel streams incorrectly
6.  **Performance considerations**
    -   Use primitive streams (IntStream, LongStream, DoubleStream)
    -   Avoid unnecessary boxing/unboxing
    -   Short-circuit when possible (findFirst, anyMatch)
    -   Consider stream overhead for small collections

----------

## üåü Real-World Use Cases

### 1. Data Processing Pipeline

java

```java
// Process employee data: filter, transform, aggregate
Map<String, Double> avgSalaryByDept = employees.stream()
    .filter(e -> e.getYearsOfService() > 2)
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));
```

### 2. Log Analysis

java

```java
// Find top 10 most frequent error codes
Map<String, Long> topErrors = logEntries.stream()
    .filter(log -> log.getLevel().equals("ERROR"))
    .map(LogEntry::getErrorCode)
    .collect(Collectors.groupingBy(
        code -> code,
        Collectors.counting()
    ))
    .entrySet().stream()
    .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
    .limit(10)
    .collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue,
        (e1, e2) -> e1,
        LinkedHashMap::new
    ));
```

### 3. CSV Processing

java

```java
// Parse CSV and aggregate data
List<String> lines = Files.lines(Paths.get("data.csv"));
Map<String, List<Transaction>> transactionsByUser = lines.stream()
    .skip(1) // Skip header
    .map(line -> line.split(","))
    .map(parts -> new Transaction(parts[0], parts[1], Double.parseDouble(parts[2])))
    .collect(Collectors.groupingBy(Transaction::getUserId));
```

----------
## üß†  Stream Internal Working (Memory Visualization)

When you write:
``` java
list.stream().filter(x -> x > 10).map(x -> x * 2).collect(Collectors.toList());` 
```
### Internally:

1.  Stream creates a **pipeline chain** of operations.
    
2.  Each element flows **one by one** through all filters/maps.
    
3.  The chain executes **only** when a **terminal operation** is called.
    

üß© Visualization:
``` java
[10, 20, 30, 40]
  ‚Üì filter(x>10)
[20, 30, 40] 
  ‚Üì map(x*2) 
[40, 60, 80]
  ‚Üì collect()
[List -> 40, 60, 80]`
```
`)`

----------

## üß†  Common Interview Questions with Answers

### **Q1. Difference between `map()` and `flatMap()`**

-   `map()` ‚Üí transforms elements one-to-one.
    
-   `flatMap()` ‚Üí transforms elements one-to-many (flattens nested structures).
    

**Example:**
``` java
map(List::stream) ‚Üí Stream<Stream<Integer>> flatMap(List::stream) ‚Üí Stream<Integer> 
```
----------

### **Q2. What is Lazy Evaluation?**

Intermediate operations like `filter()` or `map()` are not executed until a terminal operation (like `collect()` or `forEach()`) is called.  
This improves performance by **combining steps** and **avoiding unnecessary processing**.

----------

### **Q3. Can we reuse a Stream?**

No. Once a stream is consumed by a terminal operation, it cannot be used again.  
You must recreate it.

----------

### **Q4. How does `parallelStream()` work?**

It splits the data into multiple chunks and processes them in parallel threads using the **ForkJoinPool** framework.

----------

### **Q5. What happens if you modify a source while streaming?**

It throws **ConcurrentModificationException**, as Streams are **not designed for structural modification** during processing.

----------

### **Q6. What is `reduce()` used for?**

To combine all elements into a single result (sum, min, max, concatenation).
## ‚úÖ Summary

Java 8 Streams provide a powerful, functional approach to processing collections:

-   **Declarative**: Express what you want, not how to get it
-   **Composable**: Chain operations for complex transformations
-   **Parallel-ready**: Easy parallelization for performance
-   **Lazy**: Efficient execution with delayed evaluation
-   **Readable**: More concise and maintainable code

Master streams to write cleaner, more efficient Java code!

----------

**Happy Streaming! üöÄ**
