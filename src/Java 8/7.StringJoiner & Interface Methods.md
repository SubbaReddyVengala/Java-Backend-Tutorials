# Java 8: StringJoiner & Interface Methods - Complete Tutorial

## Table of Contents

1.  StringJoiner Class
2.  Static Methods in Interfaces
3.  Default Methods in Interfaces
4.  Interview Questions & Answers

----------

## 1. StringJoiner Class  <a id="stringjoiner"></a>

### ðŸŽ¯ What is StringJoiner?
Before Java 8, to join strings with delimiters (like commas or spaces), developers had to manually handle them using `StringBuilder` or concatenation â€” both were **verbose and error-prone**.

Java 8 introduced **`StringJoiner`**, which simplifies the joining of strings with **delimiter**, **prefix**, and **suffix**.

**Definition**: StringJoiner is a utility class introduced in Java 8 to construct a sequence of characters separated by a delimiter, optionally starting with a prefix and ending with a suffix.

### ðŸ§  Memory Visualization

```
Think of StringJoiner as a NECKLACE MAKER:
- Delimiter = Thread connecting beads
- Elements = Beads
- Prefix = Clasp at the start
- Suffix = Clasp at the end

Example: [Bead1]--[Bead2]--[Bead3]
         â†‘                      â†‘
       Prefix                Suffix
```

### ðŸ“š Theory

**Why StringJoiner?**

-   More efficient than concatenating strings with  `+`  operator
-   Cleaner syntax than using StringBuilder manually
-   Built specifically for joining strings with delimiters

**Internal Working**:

-   Uses StringBuilder internally
-   Efficiently manages memory by avoiding multiple String object creation
-   Thread-unsafe (not synchronized)

### ðŸ”§ Constructors

java

```java
// Constructor 1: Only delimiter
StringJoiner(CharSequence delimiter)

// Constructor 2: Delimiter with prefix and suffix
StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
```

### ðŸ’¡ Simple Examples

#### Example 1: Basic Usage with Delimiter

java

```java
import java.util.StringJoiner;

public class BasicStringJoiner {
    public static void main(String[] args) {
        // Creating StringJoiner with comma delimiter
        StringJoiner joiner = new StringJoiner(", ");
        
        // Adding elements
        joiner.add("Apple");
        joiner.add("Banana");
        joiner.add("Cherry");
        
        System.out.println(joiner.toString());
        // Output: Apple, Banana, Cherry
    }
}
```

#### Example 2: With Prefix and Suffix

java

```java
import java.util.StringJoiner;

public class PrefixSuffixExample {
    public static void main(String[] args) {
        // Creating StringJoiner with [prefix] and {suffix}
        StringJoiner joiner = new StringJoiner(", ", "[", "]");
        
        joiner.add("Red");
        joiner.add("Green");
        joiner.add("Blue");
        
        System.out.println(joiner.toString());
        // Output: [Red, Green, Blue]
    }
}
```

#### Example 3: Empty StringJoiner with setEmptyValue

java

```java
import java.util.StringJoiner;

public class EmptyValueExample {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(", ", "{", "}");
        
        // Set value to display when empty
        joiner.setEmptyValue("No elements");
        
        System.out.println("Empty: " + joiner.toString());
        // Output: Empty: No elements
        
        joiner.add("Element1");
        System.out.println("After adding: " + joiner.toString());
        // Output: After adding: {Element1}
    }
}
```

#### Example 4: Merging Two StringJoiners

java

```java
import java.util.StringJoiner;

public class MergeExample {
    public static void main(String[] args) {
        StringJoiner joiner1 = new StringJoiner(", ", "[", "]");
        joiner1.add("A").add("B").add("C");
        
        StringJoiner joiner2 = new StringJoiner(", ", "[", "]");
        joiner2.add("X").add("Y").add("Z");
        
        // Merge joiner2 into joiner1
        joiner1.merge(joiner2);
        
        System.out.println(joiner1.toString());
        // Output: [A, B, C, X, Y, Z]
    }
}
```

#### Example 5: Real-World Scenario - Creating SQL Query

java

```java
import java.util.StringJoiner;
import java.util.Arrays;
import java.util.List;

public class SQLQueryExample {
    public static void main(String[] args) {
        List<String> columns = Arrays.asList("id", "name", "email", "age");
        
        // Create column list for SELECT query
        StringJoiner columnJoiner = new StringJoiner(", ");
        columns.forEach(columnJoiner::add);
        
        String query = "SELECT " + columnJoiner.toString() + " FROM users";
        System.out.println(query);
        // Output: SELECT id, name, email, age FROM users
        
        // Create WHERE clause with OR conditions
        StringJoiner whereJoiner = new StringJoiner(" OR ", " WHERE (", ")");
        whereJoiner.add("age > 18");
        whereJoiner.add("verified = true");
        whereJoiner.add("role = 'admin'");
        
        System.out.println(query + whereJoiner.toString());
        // Output: SELECT id, name, email, age FROM users WHERE (age > 18 OR verified = true OR role = 'admin')
    }
}
```

### ðŸ“Š Key Methods
<img width="875" height="326" alt="image" src="https://github.com/user-attachments/assets/05c5e2c8-bddd-4588-9af7-ae021d0eab28" />
----------

## 2. Static Methods in Interfaces  <a id="static-methods"></a>

### ðŸŽ¯ What are Static Methods in Interfaces?

**Definition**: Java 8 allows interfaces to have static methods with implementation. These methods belong to the interface itself, not to implementing classes.

### ðŸ§  Analogy

```
Think of an interface as a BUILDING BLUEPRINT:
- Abstract methods = Mandatory rooms (must be built)
- Default methods = Optional furnished rooms (can be used as-is or customized)
- Static methods = SHARED FACILITIES (gym, parking) that belong to the building,
                   not individual apartments

You access static methods through the INTERFACE NAME, not through objects.
```

### ðŸ“š Theory

**Key Characteristics**:

1.  **Cannot be overridden**: Static methods are not inherited by implementing classes
2.  **Accessed via interface name**: Must use  `InterfaceName.staticMethod()`
3.  **Cannot be called on objects**: Even if a class implements the interface
4.  **Can have implementation**: Unlike abstract methods
5.  **Cannot access instance members**: Only other static members

**Why Static Methods in Interfaces?**

-   Provide utility/helper methods related to the interface
-   Keep related methods together
-   No need for separate utility classes

### ðŸ’¡ Simple Examples

#### Example 1: Basic Static Method

java

```java
interface Calculator {
    // Abstract method
    int calculate(int a, int b);
    
    // Static method - utility function
    static boolean isPositive(int number) {
        return number > 0;
    }
    
    static void printInfo() {
        System.out.println("Calculator Interface v1.0");
    }
}

class Addition implements Calculator {
    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
}

public class StaticMethodExample {
    public static void main(String[] args) {
        // Calling static method via interface name
        Calculator.printInfo();
        // Output: Calculator Interface v1.0
        
        System.out.println(Calculator.isPositive(5));  // true
        System.out.println(Calculator.isPositive(-3)); // false
        
        // Cannot call static method on object
        Addition add = new Addition();
        // add.printInfo(); // Compilation Error!
    }
}
```

#### Example 2: Static Factory Method Pattern

java

```java
interface Vehicle {
    void start();
    void stop();
    
    // Static factory method
    static Vehicle createCar() {
        return new Car();
    }
    
    static Vehicle createBike() {
        return new Bike();
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting with key ignition");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stopping with brake pedal");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike starting with kick");
    }
    
    @Override
    public void stop() {
        System.out.println("Bike stopping with hand brake");
    }
}

public class FactoryPatternExample {
    public static void main(String[] args) {
        Vehicle car = Vehicle.createCar();
        car.start();  // Output: Car starting with key ignition
        
        Vehicle bike = Vehicle.createBike();
        bike.start(); // Output: Bike starting with kick
    }
}
```

#### Example 3: Validation Utilities

java

```java
interface User {
    String getName();
    String getEmail();
    
    // Static validation methods
    static boolean isValidEmail(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }
    
    static boolean isValidName(String name) {
        return name != null && !name.trim().isEmpty() && name.length() >= 2;
    }
    
    static void validateUser(User user) {
        if (!isValidName(user.getName())) {
            throw new IllegalArgumentException("Invalid name");
        }
        if (!isValidEmail(user.getEmail())) {
            throw new IllegalArgumentException("Invalid email");
        }
    }
}

class Employee implements User {
    private String name;
    private String email;
    
    public Employee(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    @Override
    public String getName() { return name; }
    
    @Override
    public String getEmail() { return email; }
}

public class ValidationExample {
    public static void main(String[] args) {
        // Using static methods for validation
        System.out.println(User.isValidEmail("test@example.com")); // true
        System.out.println(User.isValidEmail("invalid"));          // false
        
        Employee emp = new Employee("John Doe", "john@company.com");
        User.validateUser(emp);
        System.out.println("User validated successfully");
    }
}
```

----------

## 3. Default Methods in Interfaces  <a id="default-methods"></a>

### ðŸŽ¯ What are Default Methods?

**Definition**: Default methods are methods in interfaces with a default implementation using the  `default`  keyword. Implementing classes can use the default implementation or override it.

### ðŸ§  Analogy

```
Think of default methods as a SMARTPHONE with PRE-INSTALLED APPS:
- You get apps (default methods) out of the box
- You can use them as-is (default implementation)
- You can uninstall and replace with your own (override)
- Older phones (existing classes) get updated without breaking (backward compatibility)

Without default methods, adding a new method to an interface would BREAK all
existing implementations (like forcing all phones to add a new mandatory feature).
```

### ðŸ“š Theory

**Why Default Methods?**

1.  **Backward Compatibility**: Add new methods to interfaces without breaking existing implementations
2.  **Optional Functionality**: Provide default behavior that can be overridden
3.  **Interface Evolution**: Interfaces can evolve over time
4.  **Multiple Inheritance**: Classes can inherit behavior from multiple interfaces

**Key Rules**:

-   Use  `default`  keyword
-   Can be overridden by implementing classes
-   Can access other interface methods
-   Can be called using  `super`  keyword with interface name
-   If two interfaces have same default method, implementing class must override to resolve conflict

### ðŸ’¡ Simple Examples

#### Example 1: Basic Default Method

java

```java
interface Greeting {
    // Abstract method
    String getName();
    
    // Default method
    default void sayHello() {
        System.out.println("Hello, " + getName() + "!");
    }
    
    default void sayGoodbye() {
        System.out.println("Goodbye, " + getName() + "!");
    }
}

class Person implements Greeting {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    // Using default sayHello() as-is
    // Overriding sayGoodbye()
    @Override
    public void sayGoodbye() {
        System.out.println("See you later, " + getName() + "!");
    }
}

public class DefaultMethodExample {
    public static void main(String[] args) {
        Person person = new Person("Alice");
        person.sayHello();    // Output: Hello, Alice! (default implementation)
        person.sayGoodbye();  // Output: See you later, Alice! (overridden)
    }
}
```

#### Example 2: Backward Compatibility Scenario

java

```java
// Original interface (Java 7)
interface Logger {
    void log(String message);
}

// Java 8 - Adding new methods without breaking existing implementations
interface LoggerV2 {
    void log(String message);
    
    // New default methods - existing classes don't break!
    default void logError(String message) {
        log("ERROR: " + message);
    }
    
    default void logWarning(String message) {
        log("WARNING: " + message);
    }
    
    default void logInfo(String message) {
        log("INFO: " + message);
    }
}

class ConsoleLogger implements LoggerV2 {
    @Override
    public void log(String message) {
        System.out.println(message);
    }
    
    // Gets logError, logWarning, logInfo for free!
}

class FileLogger implements LoggerV2 {
    @Override
    public void log(String message) {
        System.out.println("[File] " + message);
    }
    
    // Override only what you need
    @Override
    public void logError(String message) {
        log("CRITICAL ERROR: " + message);
    }
}

public class BackwardCompatibilityExample {
    public static void main(String[] args) {
        ConsoleLogger console = new ConsoleLogger();
        console.logInfo("Application started");
        console.logWarning("Low memory");
        console.logError("Database connection failed");
        
        System.out.println();
        
        FileLogger file = new FileLogger();
        file.logInfo("Application started");
        file.logError("Database connection failed");
    }
}
```

#### Example 3: Diamond Problem Resolution

java

```java
interface Movable {
    default void move() {
        System.out.println("Moving...");
    }
}

interface Flyable {
    default void move() {
        System.out.println("Flying...");
    }
}

// Must resolve conflict explicitly
class Bird implements Movable, Flyable {
    @Override
    public void move() {
        // Option 1: Provide own implementation
        System.out.println("Bird is flying!");
        
        // Option 2: Call specific interface method
        // Flyable.super.move();
        
        // Option 3: Call both
        // Movable.super.move();
        // Flyable.super.move();
    }
}

public class DiamondProblemExample {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.move();  // Output: Bird is flying!
    }
}
```

#### Example 4: Real-World Example - Payment Processing

java

```java
interface Payment {
    double getAmount();
    String getCurrency();
    
    // Default method for currency conversion
    default double getAmountInUSD() {
        String currency = getCurrency();
        double amount = getAmount();
        
        switch(currency) {
            case "USD": return amount;
            case "EUR": return amount * 1.1;
            case "GBP": return amount * 1.25;
            case "INR": return amount * 0.012;
            default: return amount;
        }
    }
    
    // Default method for payment description
    default String getPaymentDescription() {
        return String.format("Payment of %.2f %s", getAmount(), getCurrency());
    }
    
    // Default method for validation
    default boolean isValidPayment() {
        return getAmount() > 0 && getCurrency() != null;
    }
}

class CreditCardPayment implements Payment {
    private double amount;
    private String currency;
    private String cardNumber;
    
    public CreditCardPayment(double amount, String currency, String cardNumber) {
        this.amount = amount;
        this.currency = currency;
        this.cardNumber = cardNumber;
    }
    
    @Override
    public double getAmount() { return amount; }
    
    @Override
    public String getCurrency() { return currency; }
    
    // Override to add custom information
    @Override
    public String getPaymentDescription() {
        return String.format("Credit Card Payment of %.2f %s (Card: ****%s)", 
            getAmount(), getCurrency(), cardNumber.substring(cardNumber.length() - 4));
    }
}

class PayPalPayment implements Payment {
    private double amount;
    private String currency;
    
    public PayPalPayment(double amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }
    
    @Override
    public double getAmount() { return amount; }
    
    @Override
    public String getCurrency() { return currency; }
    
    // Uses default getPaymentDescription() and getAmountInUSD()
}

public class PaymentExample {
    public static void main(String[] args) {
        Payment cc = new CreditCardPayment(100, "EUR", "1234567890123456");
        Payment paypal = new PayPalPayment(5000, "INR");
        
        System.out.println(cc.getPaymentDescription());
        System.out.println("In USD: $" + cc.getAmountInUSD());
        System.out.println("Valid: " + cc.isValidPayment());
        
        System.out.println();
        
        System.out.println(paypal.getPaymentDescription());
        System.out.println("In USD: $" + paypal.getAmountInUSD());
        System.out.println("Valid: " + paypal.isValidPayment());
    }
}
```

#### Example 5: Using super to Call Default Method

java

```java
interface Printer {
    default void print(String message) {
        System.out.println("Printing: " + message);
    }
}

class ColorPrinter implements Printer {
    @Override
    public void print(String message) {
        System.out.println("Setting up color printer...");
        // Call default implementation
        Printer.super.print(message);
        System.out.println("Color printing complete!");
    }
}

public class SuperDefaultExample {
    public static void main(String[] args) {
        ColorPrinter printer = new ColorPrinter();
        printer.print("Test Document");
        // Output:
        // Setting up color printer...
        // Printing: Test Document
        // Color printing complete!
    }
}
```

### ðŸ“Š Static vs Default Methods Comparison

<img width="877" height="286" alt="image" src="https://github.com/user-attachments/assets/6f12afd4-b4c3-4201-9169-864a003e9c76" />
----------

## 4. Interview Questions & Answers  <a id="interview-questions"></a>

### ðŸŽ¯ StringJoiner Questions

#### Q1: What is the difference between StringJoiner and String.join()?

**Answer**:

java

```java
// String.join() - static method, works with collections
String result1 = String.join(", ", "A", "B", "C");
List<String> list = Arrays.asList("A", "B", "C");
String result2 = String.join(", ", list);

// StringJoiner - more flexible, allows prefix/suffix, can be reused
StringJoiner joiner = new StringJoiner(", ", "[", "]");
joiner.add("A").add("B").add("C");
String result3 = joiner.toString(); // [A, B, C]

// Key differences:
// 1. StringJoiner can have prefix and suffix
// 2. StringJoiner can be built incrementally
// 3. StringJoiner can set empty value
// 4. StringJoiner can merge with another StringJoiner
// 5. String.join() is simpler for one-time operations
```

#### Q2: What happens when you call toString() on an empty StringJoiner?

**Answer**:

java

```java
StringJoiner joiner1 = new StringJoiner(", ");
System.out.println(joiner1.toString()); // Output: "" (empty string)

StringJoiner joiner2 = new StringJoiner(", ", "[", "]");
System.out.println(joiner2.toString()); // Output: "[]" (prefix + suffix)

StringJoiner joiner3 = new StringJoiner(", ", "[", "]");
joiner3.setEmptyValue("EMPTY");
System.out.println(joiner3.toString()); // Output: "EMPTY"
```

#### Q3: How is StringJoiner better than StringBuilder for joining strings?

**Answer**:

java

```java
// Using StringBuilder - manual delimiter management
StringBuilder sb = new StringBuilder();
String[] words = {"Java", "Python", "JavaScript"};
for (int i = 0; i < words.length; i++) {
    sb.append(words[i]);
    if (i < words.length - 1) {  // Complex logic for delimiter
        sb.append(", ");
    }
}
String result1 = sb.toString();

// Using StringJoiner - cleaner and simpler
StringJoiner joiner = new StringJoiner(", ");
for (String word : words) {
    joiner.add(word);  // No delimiter logic needed
}
String result2 = joiner.toString();

// Benefits of StringJoiner:
// 1. Automatic delimiter management
// 2. Built-in prefix and suffix support
// 3. Cleaner, more readable code
// 4. Purpose-built for joining operations
```

#### Q4: Write a program to convert a List of integers to a String like "(1, 2, 3, 4, 5)"

**Answer**:

java

```java
import java.util.*;
import java.util.stream.Collectors;

public class ListToString {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Method 1: Using StringJoiner
        StringJoiner joiner = new StringJoiner(", ", "(", ")");
        for (Integer num : numbers) {
            joiner.add(String.valueOf(num));
        }
        System.out.println(joiner.toString());
        
        // Method 2: Using Streams with Collectors.joining()
        String result = numbers.stream()
            .map(String::valueOf)
            .collect(Collectors.joining(", ", "(", ")"));
        System.out.println(result);
    }
}
```

----------

### ðŸŽ¯ Static Methods in Interface Questions

#### Q5: Can we override static methods of an interface in the implementing class?

**Answer**:

java

```java
interface Example {
    static void staticMethod() {
        System.out.println("Interface static method");
    }
}

class Implementation implements Example {
    // This is NOT overriding, it's hiding
    public static void staticMethod() {
        System.out.println("Class static method");
    }
}

public class Test {
    public static void main(String[] args) {
        Example.staticMethod();         // Interface static method
        Implementation.staticMethod();  // Class static method
        
        Example obj = new Implementation();
        // obj.staticMethod(); // Compilation error!
        
        // Key points:
        // 1. Static methods are NOT inherited
        // 2. Cannot override, only hide
        // 3. Must be called using interface/class name
    }
}
```

#### Q6: What is the purpose of static methods in interfaces?

**Answer**: Static methods in interfaces serve these purposes:

1.  **Utility methods**: Keep helper methods with related interface

java

```java
interface MathOperations {
    int calculate(int a, int b);
    
    static boolean isEven(int number) {
        return number % 2 == 0;
    }
    
    static int absolute(int number) {
        return number < 0 ? -number : number;
    }
}
```

2.  **Factory methods**: Create instances of implementing classes

java

```java
interface Database {
    void connect();
    
    static Database createMySQLDatabase() {
        return new MySQLDatabase();
    }
    
    static Database createPostgreSQLDatabase() {
        return new PostgreSQLDatabase();
    }
}
```

3.  **Avoid utility classes**: No need for separate utility classes

#### Q7: Can we have both static and default methods with the same signature in an interface?

**Answer**:

java

```java
// NO! Compilation error
interface Wrong {
    static void process() { }    // Static method
    default void process() { }   // Compilation error: duplicate method
}

// But different signatures are fine
interface Correct {
    static void process() { }           // No parameters
    default void process(String s) { }  // With parameter - OK
}
```

----------

### ðŸŽ¯ Default Methods in Interface Questions

#### Q8: What is the diamond problem with default methods and how is it resolved?

**Answer**:

java

```java
interface A {
    default void display() {
        System.out.println("Interface A");
    }
}

interface B {
    default void display() {
        System.out.println("Interface B");
    }
}

// Diamond problem: C inherits display() from both A and B
class C implements A, B {
    // MUST override to resolve conflict
    @Override
    public void display() {
        // Option 1: Provide own implementation
        System.out.println("Class C");
        
        // Option 2: Call specific interface
        // A.super.display();
        
        // Option 3: Call both
        // A.super.display();
        // B.super.display();
    }
}

// Resolution rules:
// 1. Class implementation wins over interface default
// 2. Most specific interface wins (subinterface over superinterface)
// 3. If ambiguous, must explicitly override
```

#### Q9: What happens if a class implements an interface with a default method and extends a class with the same method?

**Answer**:

java

```java
interface MyInterface {
    default void show() {
        System.out.println("Interface default method");
    }
}

class MyClass {
    public void show() {
        System.out.println("Class method");
    }
}

class Child extends MyClass implements MyInterface {
    // No need to override - class method wins automatically
}

public class Test {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.show();  // Output: Class method
        
        // Rule: Class methods ALWAYS win over interface default methods
        // This prevents changes to interfaces from breaking existing code
    }
}
```

#### Q10: Why were default methods introduced in Java 8?

**Answer**: Default methods were introduced primarily for  **backward compatibility**.

**Problem before Java 8**:

java

```java
// Java 7 interface
interface Collection<E> {
    boolean add(E e);
    boolean remove(Object o);
    // Many other methods...
}

// If we want to add a new method:
// void forEach(Consumer<E> action);
// ALL existing implementations would break!
```

**Solution with Java 8**:

java

```java
interface Collection<E> {
    boolean add(E e);
    boolean remove(Object o);
    
    // New method with default implementation
    default void forEach(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        for (E e : this) {
            action.accept(e);
        }
    }
}

// Existing implementations don't break!
// They automatically get the default forEach() implementation
```

#### Q11: Can we have a default method that overrides Object class methods?

**Answer**:

java

```java
interface Wrong {
    // Compilation error: Cannot override Object methods
    default String toString() {
        return "Wrong";
    }
    
    default int hashCode() {  // Error
        return 42;
    }
    
    default boolean equals(Object obj) {  // Error
        return true;
    }
}

// Reason: Object methods are already available to all classes
// Allowing interface defaults would create ambiguity
// Object class methods always win

// What you CAN do:
interface Correct {
    // Abstract methods are fine
    String toString();  // Implementing class must override
}
```

#### Q12: Write a program demonstrating the use of default and static methods together

**Answer**:

java

```java
interface StringProcessor {
    // Abstract method
    String process(String input);
    
    // Default method
    default String processWithLogging(String input) {
        log("Processing: " + input);
        String result = process(input);
        log("Result: " + result);
        return result;
    }
    
    // Static method
    static void log(String message) {
        System.out.println("[LOG] " + message);
    }
    
    // Static utility
    static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }
}

class UpperCaseProcessor implements StringProcessor {
    @Override
    public String process(String input) {
        return input.toUpperCase();
    }
}

class ReverseProcessor implements StringProcessor {
    @Override
    public String process(String input) {
        return new StringBuilder(input).reverse().toString();
    }
    
    @Override
    public String processWithLogging(String input) {
        if (StringProcessor.isEmpty(input)) {
            StringProcessor.log("Empty input received");
            return "";
        }
        return StringProcessor.super.processWithLogging(input);
    }
}

public class CombinedExample {
    public static void main(String[] args) {
        StringProcessor upper = new UpperCaseProcessor();
        System.out.println(upper.processWithLogging("hello"));
        
        System.out.println();
        
        StringProcessor reverse = new ReverseProcessor();
        System.out.println(reverse.processWithLogging("world"));
    }
}
```

----------

### ðŸŽ¯ Challenging Questions

#### Q13: What is the output of this code?

java

```java
interface A {
    default void print() {
        System.out.println("A");
    }
}

interface B extends A {
    default void print() {
        System.out.println("B");
    }
}

class C implements A, B {
    // What happens here?
}

public class Test {
    public static void main(String[] args) {
        C obj = new C();
        obj.print();  // Output: B
    }
}

// Answer: Output is "B"
// Reason: B is more specific (extends A), so B's method wins
// This follows the "most specific default wins" rule
```

#### Q14: Create a StringJoiner that builds a HTML list

**Answer**:

java

```java
import java.util.StringJoiner;
import java.util.Arrays;
import java.util.List;

public class HTMLListBuilder {
    public static String buildOrderedList(List<String> items) {
        StringJoiner listItems = new StringJoiner("\n  ", "<ol>\n  ", "\n</ol>");
        
        for (String item : items) {
            listItems.add("<li>" + item + "</li>");
        }
        
        return listItems.toString();
    }
    
    public static String buildUnorderedList(List<String> items) {
        StringJoiner listItems = new StringJoiner("\n  ", "<ul>\n  ", "\n</ul>");
        
        for (String item : items) {
            listItems.add("<li>" + item + "</li>");
        }
        
        return listItems.toString();
    }
    
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry");
        
        System.out.println(buildOrderedList(fruits));
        System.out.println();
        System.out.println(buildUnorderedList(fruits));
    }
}

/* Output:
<ol>
  <li>Apple</li>
  <li>Banana</li>
  <li>Cherry</li>
</ol>

<ul>
  <li>Apple</li>
  <li>Banana</li>
  <li>Cherry</li>
</ul>
*/
```

#### Q15: Can an interface have a private method? If yes, how does it work with default methods?

**Answer**: Yes! Java 9 introduced private methods in interfaces.

java

```java
interface Calculator {
    // Public default method
    default int addAll(int... numbers) {
        return performOperation(numbers, (a, b) -> a + b);
    }
    
    default int multiplyAll(int... numbers) {
        return performOperation(numbers, (a, b) -> a * b);
    }
    
    // Private helper method (Java 9+)
    private int performOperation(int[] numbers, 
                                 java.util.function.BinaryOperator<Integer> operator) {
        if (numbers.length == 0) return 0;
        
        int result = numbers[0];
        for (int i = 1; i < numbers.length; i++) {
            result = operator.apply(result, numbers[i]);
        }
        return result;
    }
    
    // Private static method (Java 9+)
    private static void log(String message) {
        System.out.println("[Calculator] " + message);
    }
}

// Benefits:
// 1. Code reuse between default methods
// 2. Encapsulation - hide implementation details
// 3. Keep interface clean
```

#### Q16: Explain method resolution order with an example involving class, interface, and superclass

**Answer**:

java

```java
interface Printable {
    default void print() {
        System.out.println("Printable interface");
    }
}

class Parent {
    public void print() {
        System.out.println("Parent class");
    }
}

class Child extends Parent implements Printable {
    // No override needed
}

class GrandChild extends Child {
    @Override
    public void print() {
        System.out.println("GrandChild class");
    }
}

public class MethodResolutionTest {
    public static void main(String[] args) {
        Child child = new Child();
        child.print();  // Output: Parent class
        
        GrandChild grandChild = new GrandChild();
        grandChild.print();  // Output: GrandChild class
    }
}

// Method Resolution Rules (Priority Order):
// 1. Class methods (own class)
// 2. Superclass methods
// 3. Interface default methods (most specific interface)
// 4. Abstract methods

// Rule Summary:
// Classes Win: Class methods always beat interface defaults
// Subtype Wins: More specific interface wins over general interface
// Explicit Wins: If ambiguous, must explicitly override
```

#### Q17: Create a program that demonstrates merging multiple StringJoiners with different delimiters

**Answer**:

java

```java
import java.util.StringJoiner;

public class MergeStringJoiners {
    public static void main(String[] args) {
        // Department 1: Engineering
        StringJoiner engineering = new StringJoiner(", ");
        engineering.add("Alice").add("Bob").add("Charlie");
        
        // Department 2: Marketing
        StringJoiner marketing = new StringJoiner(", ");
        marketing.add("David").add("Eve");
        
        // Department 3: Sales
        StringJoiner sales = new StringJoiner(", ");
        sales.add("Frank").add("Grace").add("Henry");
        
        // Merge all departments
        StringJoiner allEmployees = new StringJoiner(" | ", "Employees: [", "]");
        allEmployees.merge(engineering)
                   .merge(marketing)
                   .merge(sales);
        
        System.out.println(allEmployees);
        // Output: Employees: [Alice, Bob, Charlie, David, Eve, Frank, Grace, Henry]
        
        // Note: When merging, the delimiter of the first joiner is preserved
        // The prefix/suffix of merged joiners are ignored
        
        // Example 2: Building nested structure
        StringJoiner deptNames = new StringJoiner(", ", "Departments: {", "}");
        deptNames.add("Engineering(3)").add("Marketing(2)").add("Sales(3)");
        
        System.out.println(deptNames);
        // Output: Departments: {Engineering(3), Marketing(2), Sales(3)}
    }
}
```

#### Q18: What are functional interfaces and how do they relate to default methods?

**Answer**:

java

```java
// Functional Interface: Interface with exactly ONE abstract method
@FunctionalInterface
interface Transformer {
    // Single abstract method (SAM)
    String transform(String input);
    
    // Can have multiple default methods
    default String transformAndLog(String input) {
        System.out.println("Transforming: " + input);
        return transform(input);
    }
    
    default String transformTwice(String input) {
        return transform(transform(input));
    }
    
    // Can have multiple static methods
    static String reverse(String input) {
        return new StringBuilder(input).reverse().toString();
    }
    
    static boolean isEmpty(String input) {
        return input == null || input.isEmpty();
    }
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Lambda expression for the abstract method
        Transformer upper = s -> s.toUpperCase();
        
        System.out.println(upper.transform("hello"));           // HELLO
        System.out.println(upper.transformAndLog("world"));     // WORLD
        System.out.println(upper.transformTwice("abc"));        // ABC
        System.out.println(Transformer.reverse("hello"));       // olleh
    }
}

// Key Points:
// 1. @FunctionalInterface ensures only ONE abstract method
// 2. Default methods don't count toward the "one method" rule
// 3. Static methods don't count either
// 4. Can still use lambdas and method references
// 5. Default/static methods add utility without breaking functional interface contract
```

#### Q19: Performance comparison: StringJoiner vs StringBuilder vs String concatenation

**Answer**:

java

```java
import java.util.StringJoiner;

public class PerformanceComparison {
    private static final int ITERATIONS = 10000;
    
    public static void main(String[] args) {
        String[] words = new String[ITERATIONS];
        for (int i = 0; i < ITERATIONS; i++) {
            words[i] = "Word" + i;
        }
        
        // Method 1: String concatenation (SLOWEST - creates many objects)
        long start1 = System.nanoTime();
        String result1 = "";
        for (String word : words) {
            if (!result1.isEmpty()) result1 += ", ";
            result1 += word;
        }
        long end1 = System.nanoTime();
        System.out.println("String concat: " + (end1 - start1) / 1_000_000 + " ms");
        
        // Method 2: StringBuilder (FASTEST - most efficient)
        long start2 = System.nanoTime();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            sb.append(words[i]);
            if (i < words.length - 1) sb.append(", ");
        }
        String result2 = sb.toString();
        long end2 = System.nanoTime();
        System.out.println("StringBuilder: " + (end2 - start2) / 1_000_000 + " ms");
        
        // Method 3: StringJoiner (GOOD - clean and efficient)
        long start3 = System.nanoTime();
        StringJoiner joiner = new StringJoiner(", ");
        for (String word : words) {
            joiner.add(word);
        }
        String result3 = joiner.toString();
        long end3 = System.nanoTime();
        System.out.println("StringJoiner: " + (end3 - start3) / 1_000_000 + " ms");
    }
}

/* Typical Output (times vary):
String concat: 1500-2000 ms (O(nÂ²) complexity)
StringBuilder: 2-5 ms (O(n) complexity)
StringJoiner: 3-7 ms (O(n) complexity, slightly slower than StringBuilder)

Recommendation:
- Use StringBuilder for maximum performance and flexibility
- Use StringJoiner for cleaner code when you need delimiters/prefix/suffix
- NEVER use + operator in loops (creates many temporary String objects)
*/
```

#### Q20: Advanced Challenge - Build a CSV Builder using StringJoiner

**Answer**:

java

```java
import java.util.StringJoiner;
import java.util.Arrays;
import java.util.List;

public class CSVBuilder {
    private StringJoiner rows;
    private String[] headers;
    
    public CSVBuilder(String... headers) {
        this.headers = headers;
        this.rows = new StringJoiner("\n");
        
        // Add header row
        StringJoiner headerRow = new StringJoiner(",");
        for (String header : headers) {
            headerRow.add(escapeCSV(header));
        }
        rows.add(headerRow.toString());
    }
    
    public CSVBuilder addRow(String... values) {
        if (values.length != headers.length) {
            throw new IllegalArgumentException(
                "Expected " + headers.length + " values, got " + values.length
            );
        }
        
        StringJoiner row = new StringJoiner(",");
        for (String value : values) {
            row.add(escapeCSV(value));
        }
        rows.add(row.toString());
        return this;
    }
    
    private String escapeCSV(String value) {
        if (value == null) return "";
        
        // Escape if contains comma, quote, or newline
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
    
    public String build() {
        return rows.toString();
    }
    
    public static void main(String[] args) {
        CSVBuilder csv = new CSVBuilder("ID", "Name", "Email", "Department");
        
        csv.addRow("1", "John Doe", "john@example.com", "Engineering")
           .addRow("2", "Jane Smith", "jane@example.com", "Marketing")
           .addRow("3", "Bob Johnson", "bob@example.com", "Sales, Support")
           .addRow("4", "Alice Brown", "alice@example.com", "HR");
        
        System.out.println(csv.build());
    }
}

/* Output:
ID,Name,Email,Department
1,John Doe,john@example.com,Engineering
2,Jane Smith,jane@example.com,Marketing
3,Bob Johnson,bob@example.com,"Sales, Support"
4,Alice Brown,alice@example.com,HR
*/
```

----------

## ðŸ“‹ Summary Cheat Sheet

### StringJoiner Quick Reference

java

```java
// Constructor patterns
StringJoiner j1 = new StringJoiner(", ");                    // delimiter only
StringJoiner j2 = new StringJoiner(", ", "[", "]");         // with prefix/suffix

// Methods
j1.add("element");                  // Add element
j1.merge(j2);                       // Merge another joiner
j1.setEmptyValue("empty");          // Set value when empty
j1.length();                        // Get length
j1.toString();                      // Convert to string
```

### Interface Methods Quick Reference

java

```java
interface Example {
    // Abstract method - must be implemented
    void abstractMethod();
    
    // Default method - can be overridden
    default void defaultMethod() {
        System.out.println("Default implementation");
    }
    
    // Static method - called via interface name
    static void staticMethod() {
        System.out.println("Static utility");
    }
}

// Usage
class Impl implements Example {
    public void abstractMethod() { }           // Must implement
    public void defaultMethod() { }            // Optional override
    // Cannot override static method
}

Example.staticMethod();                        // Call static method
Impl obj = new Impl();
obj.defaultMethod();                           // Call default/overridden method
```

### Method Resolution Priority

```
1. Own class methods (highest priority)
2. Superclass methods
3. Interface default methods (most specific interface wins)
4. Must explicitly override if ambiguous
```

----------

## ðŸŽ“ Best Practices

### StringJoiner Best Practices

1.  âœ…  **Use for delimiter-based joining**: Perfect for comma-separated lists
2.  âœ…  **Use when you need prefix/suffix**: Like brackets around lists
3.  âœ…  **Reuse for building incrementally**: Add items as you go
4.  âŒ  **Don't use for simple concatenation**: Overkill for 2-3 strings
5.  âŒ  **Don't use for complex formatting**: Use String.format() instead

### Interface Methods Best Practices

1.  âœ…  **Static methods for utilities**: Keep related helpers in the interface
2.  âœ…  **Default methods for evolution**: Add features without breaking code
3.  âœ…  **Default methods for optional behavior**: Provide sensible defaults
4.  âŒ  **Don't abuse default methods**: Keep interfaces focused
5.  âŒ  **Don't override Object methods**: toString(), equals(), hashCode()
6.  âœ…  **Document default behavior**: Let users know they can override
7.  âœ…  **Use @FunctionalInterface**: When you want lambda support

----------

## ðŸš€ Real-World Use Cases

### When to Use StringJoiner

-   Building SQL queries (column lists, WHERE clauses)
-   Generating CSV/TSV data
-   Creating formatted output (JSON arrays, XML elements)
-   Building command-line arguments
-   Creating comma-separated lists for display

### When to Use Default Methods

-   Adding methods to existing interfaces (Java Collections)
-   Providing optional functionality
-   Building fluent APIs
-   Evolving APIs without breaking compatibility
-   Reducing boilerplate in implementing classes

### When to Use Static Methods in Interfaces

-   Factory methods for creating instances
-   Validation utilities
-   Conversion utilities
-   Helper methods related to the interface
-   Constants and configuration methods

----------

## ðŸ’¡ Key Takeaways

### StringJoiner

-   Efficient string joining with delimiters
-   Supports prefix and suffix
-   Cleaner than manual StringBuilder logic
-   Internally uses StringBuilder

### Static Methods in Interfaces

-   Belong to the interface, not implementations
-   Cannot be overridden
-   Called via interface name
-   Perfect for utility and factory methods

### Default Methods in Interfaces

-   Enable interface evolution
-   Can be overridden by implementations
-   Solve backward compatibility problems
-   Allow multiple inheritance of behavior
-   Class methods always win over defaults

----------
