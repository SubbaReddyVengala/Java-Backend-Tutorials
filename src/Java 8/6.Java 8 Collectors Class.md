# Java 8 Collectors Class - Complete Tutorial

## ğŸ“š Table of Contents

1.  Introduction & Theory
2.  Memory Visualization
3.  Core Collectors with Examples
4.  Advanced Collectors
5.  Interview Problems & Solutions

----------
## ğŸ§   Conceptual Understanding

### ğŸ” What is a Collector?

A **Collector** in Java 8 is **a utility that accumulates elements from a Stream into a final result**, such as:

-   A **Collection** (`List`, `Set`, `Map`)
    
-   A **single value** (sum, average, count)
    
-   A **string** (joined)
    
-   A **custom container**
    

----------

### ğŸ’¡ Analogy â€” _Factory Worker_

Imagine a **stream of raw items (Stream elements)** going through a **factory (Collector)**:

-   Each item is **processed** (mapped/transformed)
    
-   All items are **accumulated** into a **final container** (like List, Map, Sum)
    

ğŸ“¦ **Stream â†’ Collector â†’ Result**

Example:  
ğŸ§º Stream of fruits â†’ Collect into Basket (List)

## Introduction & Theory 

### What is the Collectors Class?

The  `Collectors`  class is a  **utility class**  in Java 8's Stream API that provides various reduction operations (collecting stream elements into collections, summarizing, grouping, partitioning, etc.).

**Analogy**: Think of Collectors as a  **factory of collection boxes**. When you have a stream of items flowing like water through a pipe, Collectors help you decide:

-   What type of container to collect into (List, Set, Map)
-   How to organize the items (grouping, partitioning)
-   How to summarize the data (counting, averaging, joining)

### Key Concepts

```
Stream â†’ Collector â†’ Result Container
  ğŸŒŠ  â†’    ğŸ“¦     â†’      ğŸ
```

**Memory Model**:

```
Heap Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Stream Pipeline               â”‚
â”‚   â”Œâ”€â”€â” â”Œâ”€â”€â” â”Œâ”€â”€â” â”Œâ”€â”€â”         â”‚
â”‚   â”‚A â”‚â†’â”‚B â”‚â†’â”‚C â”‚â†’â”‚D â”‚         â”‚
â”‚   â””â”€â”€â”˜ â””â”€â”€â”˜ â””â”€â”€â”˜ â””â”€â”€â”˜         â”‚
â”‚         â†“                       â”‚
â”‚    Collector (Terminal Op)     â”‚
â”‚         â†“                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚   â”‚  ArrayList  â”‚              â”‚
â”‚   â”‚ [A, B, C, D]â”‚              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

## Memory Visualization 

### How Collectors Work Internally

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Collector Components                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  1. Supplier      â†’ Creates result container        â”‚
â”‚     () -> new ArrayList<>()                         â”‚
â”‚                                                      â”‚
â”‚  2. Accumulator   â†’ Adds element to container       â”‚
â”‚     (list, item) -> list.add(item)                  â”‚
â”‚                                                      â”‚
â”‚  3. Combiner      â†’ Merges parallel results         â”‚
â”‚     (list1, list2) -> list1.addAll(list2)          â”‚
â”‚                                                      â”‚
â”‚  4. Finisher      â†’ Final transformation (optional) â”‚
â”‚     list -> Collections.unmodifiableList(list)     â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Visual Example of toList()**:

```
Stream: [1, 2, 3, 4, 5]
        â†“
    Supplier creates: new ArrayList<>()
        â†“
    Accumulator adds each element:
    [] â†’ [1] â†’ [1,2] â†’ [1,2,3] â†’ [1,2,3,4] â†’ [1,2,3,4,5]
        â†“
    Result: ArrayList[1, 2, 3, 4, 5]
```

----------

## Core Collectors with Examples 

### 1.  **toList()**  - Collect to ArrayList

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

// Output: [ALICE, BOB, CHARLIE]
```

**Memory Diagram**:

```
Heap:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ArrayList  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ "ALICE" â”‚ â”‚  â† Object references
â”‚  â”‚  "BOB"  â”‚ â”‚
â”‚  â”‚"CHARLIE"â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

### 2.  **toSet()**  - Collect to HashSet (removes duplicates)

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 4);
Set<Integer> uniqueNumbers = numbers.stream()
    .collect(Collectors.toSet());

// Output: [1, 2, 3, 4]
```

**Analogy**: Like putting marbles into a bag with holes - duplicate marbles fall through, only unique ones stay.

----------

### 3.  **toMap()**  - Collect to HashMap

java

```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry");

// Create map: fruit -> length
Map<String, Integer> fruitLengths = fruits.stream()
    .collect(Collectors.toMap(
        fruit -> fruit,           // key mapper
        fruit -> fruit.length()   // value mapper
    ));

// Output: {apple=5, banana=6, cherry=6}
```

**Handle Duplicate Keys**:

java

```java
List<String> words = Arrays.asList("apple", "apricot", "banana");

Map<Character, String> firstLetterMap = words.stream()
    .collect(Collectors.toMap(
        word -> word.charAt(0),    // key: first letter
        word -> word,              // value: word
        (existing, replacement) -> existing + "," + replacement  // merge function
    ));

// Output: {a=apple,apricot, b=banana}
```

----------

### 4.  **joining()**  - Concatenate strings

java

```java
List<String> words = Arrays.asList("Java", "is", "awesome");

// Simple join
String sentence1 = words.stream()
    .collect(Collectors.joining());
// Output: "Javaisawesome"

// With delimiter
String sentence2 = words.stream()
    .collect(Collectors.joining(" "));
// Output: "Java is awesome"

// With delimiter, prefix, suffix
String sentence3 = words.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// Output: "[Java, is, awesome]"
```

**Analogy**: Like building a train - joining links the cars with delimiters as connectors.

----------

### 5.  **counting()**  - Count elements

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Long count = names.stream()
    .collect(Collectors.counting());

// Output: 3
```

----------

### 6.  **summingInt/Long/Double()**  - Sum numeric values

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

Integer sum = numbers.stream()
    .collect(Collectors.summingInt(Integer::intValue));
// Output: 15

// For object properties
class Product {
    String name;
    double price;
    // constructor, getters
}

List<Product> products = Arrays.asList(
    new Product("Laptop", 999.99),
    new Product("Mouse", 29.99)
);

Double totalPrice = products.stream()
    .collect(Collectors.summingDouble(Product::getPrice));
// Output: 1029.98
```

----------

### 7.  **averagingInt/Long/Double()**  - Calculate average

java

```java
List<Integer> scores = Arrays.asList(85, 90, 78, 92, 88);

Double averageScore = scores.stream()
    .collect(Collectors.averagingInt(Integer::intValue));
// Output: 86.6
```

----------

### 8.  **summarizingInt/Long/Double()**  - Get statistics

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

IntSummaryStatistics stats = numbers.stream()
    .collect(Collectors.summarizingInt(Integer::intValue));

System.out.println("Count: " + stats.getCount());      // 5
System.out.println("Sum: " + stats.getSum());          // 15
System.out.println("Min: " + stats.getMin());          // 1
System.out.println("Max: " + stats.getMax());          // 5
System.out.println("Average: " + stats.getAverage());  // 3.0
```

**Analogy**: Like a sports scoreboard showing all key statistics at once.

----------

### 9.  **groupingBy()**  - Group elements

java

```java
class Employee {
    String name;
    String department;
    int salary;
    // constructor, getters
}

List<Employee> employees = Arrays.asList(
    new Employee("Alice", "IT", 70000),
    new Employee("Bob", "HR", 50000),
    new Employee("Charlie", "IT", 80000),
    new Employee("David", "HR", 55000)
);

// Group by department
Map<String, List<Employee>> byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

// Output: {IT=[Alice, Charlie], HR=[Bob, David]}
```

**Visual Representation**:

```
Original List:
[Alice(IT), Bob(HR), Charlie(IT), David(HR)]
         â†“ groupingBy(department)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        IT         â”‚      HR     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Alice   â”‚    â”‚  â”‚  Bob   â”‚ â”‚
â”‚  â”‚  Charlie â”‚    â”‚  â”‚  David â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advanced groupingBy with downstream collector**:

java

```java
// Count employees per department
Map<String, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.counting()
    ));
// Output: {IT=2, HR=2}

// Average salary per department
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingInt(Employee::getSalary)
    ));
// Output: {IT=75000.0, HR=52500.0}

// Names list per department
Map<String, List<String>> namesByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.mapping(
            Employee::getName,
            Collectors.toList()
        )
    ));
// Output: {IT=[Alice, Charlie], HR=[Bob, David]}
```

----------

### 10.  **partitioningBy()**  - Split into two groups (true/false)

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));

System.out.println("Even: " + partitioned.get(true));   // [2, 4, 6, 8, 10]
System.out.println("Odd: " + partitioned.get(false));   // [1, 3, 5, 7, 9]
```

**Memory Visualization**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     HashMap<Boolean, List>    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ true  â†’ [2, 4, 6, 8, 10]     â”‚
â”‚ false â†’ [1, 3, 5, 7, 9]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy**: Like sorting laundry into two baskets - whites and colors.

----------

## Advanced Collectors 

### 11.  **collectingAndThen()**  - Transform final result

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Collect to list and make it unmodifiable
List<String> unmodifiableList = names.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        Collections::unmodifiableList
    ));
```

**Flow Diagram**:

```
Stream â†’ toList() â†’ [Alice, Bob, Charlie] 
                    â†’ Collections.unmodifiableList() 
                    â†’ UnmodifiableList[Alice, Bob, Charlie]
```

----------

### 12.  **mapping()**  - Transform before collecting

java

```java
List<Employee> employees = getEmployees();

// Get uppercase names grouped by department
Map<String, List<String>> upperNamesByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.mapping(
            emp -> emp.getName().toUpperCase(),
            Collectors.toList()
        )
    ));
```

----------

### 13.  **filtering()**  - Filter before collecting (Java 9+)

java

```java
List<Employee> employees = getEmployees();

// Group by department, but only high earners (>60000)
Map<String, List<Employee>> highEarnersByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.filtering(
            emp -> emp.getSalary() > 60000,
            Collectors.toList()
        )
    ));
```

----------

### 14.  **teeing()**  - Apply two collectors and merge (Java 12+)

java

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Get both sum and count in one pass
record Result(Integer sum, Long count) {}

Result result = numbers.stream()
    .collect(Collectors.teeing(
        Collectors.summingInt(Integer::intValue),
        Collectors.counting(),
        Result::new
    ));

// Output: Result[sum=15, count=5]
```

**Analogy**: Like a factory assembly line that splits into two branches, then merges results.

----------

## Interview Problems & Solutions

### Problem 1: Find Frequency of Each Character

**Question**: Given a string, find the frequency of each character.

java

```java
public Map<Character, Long> charFrequency(String input) {
    return input.chars()
        .mapToObj(c -> (char) c)
        .collect(Collectors.groupingBy(
            c -> c,
            Collectors.counting()
        ));
}

// Test
charFrequency("hello");
// Output: {h=1, e=1, l=2, o=1}
```

----------

### Problem 2: Group Employees by Department and Find Highest Paid

**Question**: Group employees by department and find the highest-paid employee in each department.

java

```java
public Map<String, Optional<Employee>> highestPaidByDept(List<Employee> employees) {
    return employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.maxBy(Comparator.comparingInt(Employee::getSalary))
        ));
}
```

----------

### Problem 3: Partition Students into Pass/Fail

**Question**: Partition students based on passing marks (>= 40).

java

```java
class Student {
    String name;
    int marks;
    // constructor, getters
}

public Map<Boolean, List<Student>> partitionStudents(List<Student> students) {
    return students.stream()
        .collect(Collectors.partitioningBy(
            student -> student.getMarks() >= 40
        ));
}
```

----------

### Problem 4: Find Top 3 Highest Salaries

**Question**: Find the top 3 highest salaries from employee list.

java

```java
public List<Integer> top3Salaries(List<Employee> employees) {
    return employees.stream()
        .map(Employee::getSalary)
        .distinct()
        .sorted(Comparator.reverseOrder())
        .limit(3)
        .collect(Collectors.toList());
}
```

----------

### Problem 5: Create CSV from List

**Question**: Convert list of names to comma-separated string.

java

```java
public String toCSV(List<String> names) {
    return names.stream()
        .collect(Collectors.joining(", "));
}

// Test
toCSV(Arrays.asList("Alice", "Bob", "Charlie"));
// Output: "Alice, Bob, Charlie"
```

----------

### Problem 6: Group and Count Words by Length

**Question**: Group words by their length and count how many words have each length.

java

```java
public Map<Integer, Long> countByLength(List<String> words) {
    return words.stream()
        .collect(Collectors.groupingBy(
            String::length,
            Collectors.counting()
        ));
}

// Test
countByLength(Arrays.asList("a", "ab", "abc", "ab", "a"));
// Output: {1=2, 2=2, 3=1}
```

----------

### Problem 7: Find Department-wise Total Salary

**Question**: Calculate total salary expense per department.

java

```java
public Map<String, Integer> totalSalaryByDept(List<Employee> employees) {
    return employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.summingInt(Employee::getSalary)
        ));
}
```

----------

### Problem 8: Get Employees Names as Comma-Separated per Department

**Question**: Create a map where key is department and value is comma-separated employee names.

java

```java
public Map<String, String> employeeNamesByDept(List<Employee> employees) {
    return employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.mapping(
                Employee::getName,
                Collectors.joining(", ")
            )
        ));
}

// Output: {IT=Alice, Charlie, HR=Bob, David}
```

----------

### Problem 9: Multi-level Grouping

**Question**: Group employees by department, then by salary range (low < 60k, high >= 60k).

java

```java
public Map<String, Map<String, List<Employee>>> multiLevelGroup(List<Employee> employees) {
    return employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.groupingBy(emp -> 
                emp.getSalary() < 60000 ? "Low" : "High"
            )
        ));
}

// Output: {IT={High=[Alice, Charlie]}, HR={Low=[Bob, David]}}
```

----------

### Problem 10: Find Second Highest Salary

**Question**: Find the second highest salary from employee list.

java

```java
public Optional<Integer> secondHighestSalary(List<Employee> employees) {
    return employees.stream()
        .map(Employee::getSalary)
        .distinct()
        .sorted(Comparator.reverseOrder())
        .skip(1)
        .findFirst();
}
```

----------

## ğŸ¯ Key Takeaways

1.  **Collectors are terminal operations**  - they trigger stream processing
2.  **Downstream collectors**  can be combined for complex operations
3.  **groupingBy**  is like SQL's GROUP BY clause
4.  **partitioningBy**  is a special case of groupingBy with boolean predicate
5.  **Collectors are reusable**  - you can save them in variables
6.  **Parallel streams**  work seamlessly with collectors

----------

## ğŸ“Š Collectors Cheat Sheet
<img width="852" height="591" alt="image" src="https://github.com/user-attachments/assets/17b0fda3-ecc9-4af8-8f7f-5a7a27b8b59a" />

## ğŸ§© 3. Technical Explanation with Visual Memory

### ğŸ¯ `toList()`, `toSet()`, `toMap()`

#### â¤ `toList()`

Collects elements into a `List`.
``` java
List<String> names = Stream.of("Subbu", "Ravi", "Anil")
                           .collect(Collectors.toList());` 
```
ğŸ§  _Memory Tip:_  
â€œtoList = bucket with duplicates allowed (ordered).â€

#### â¤ `toSet()`

Collects into a `Set` (removes duplicates).
``` java
Set<Integer> nums = Stream.of(1, 2, 2, 3).collect(Collectors.toSet());` 
```
ğŸ§  _Tip:_ â€œtoSet = unique basket.â€

#### â¤ `toMap()`

Collects into a `Map`.
``` java
Map<Integer, String> nameMap = Stream.of("A", "BB", "CCC")
    .collect(Collectors.toMap(String::length, Function.identity()));` 

âš ï¸ If duplicate keys occur â†’ `IllegalStateException`.  
To handle duplicates:

`Map<Integer, String> nameMap = Stream.of("A", "BB", "CC")
    .collect(Collectors.toMap(String::length, Function.identity(), (s1, s2) -> s1));
``` 
ğŸ§  _Tip:_ â€œWhen duplicates clash, define a rule!â€

----------

### ğŸ¯ `joining()`

Concatenates elements into a String.
``` java
String  result  = Stream.of("Java", "is", "fun")
                      .collect(Collectors.joining(" ")); 
```
Output â†’ `"Java is fun"`

ğŸ§  _Tip:_ â€œjoining = StringBuilder inside collector.â€

----------

### ğŸ¯ `counting()`

Counts number of elements.
``` java
long  count  = Stream.of(1, 2, 3).collect(Collectors.counting());
```
----------

### ğŸ¯ `summingInt()`, `averagingDouble()`
``` java
int  sum  = Stream.of(1, 2, 3).collect(Collectors.summingInt(Integer::intValue)); double  avg  = Stream.of(1, 2, 3).collect(Collectors.averagingDouble(Integer::intValue));` 
```
ğŸ§  _Tip:_ â€œsumming â†’ adds all; averaging â†’ divides by count.â€

----------

### ğŸ¯ `groupingBy()`

Groups elements based on a key function.
``` java
Map<Integer, List<String>> grouped = Stream.of("one", "two", "three", "four")
    .collect(Collectors.groupingBy(String::length));` 
```
Output:  
`{3=[one, two], 4=[four], 5=[three]}`

ğŸ§  _Tip:_ â€œgroupingBy = SQL GROUP BYâ€

Advanced:
``` java
Map<Integer, Long> countByLength = Stream.of("one", "two", "three", "four")
    .collect(Collectors.groupingBy(String::length, Collectors.counting()));` 
```
----------

### ğŸ¯ `partitioningBy()`

Splits data into **two groups** â€” based on a boolean predicate.
``` java
Map<Boolean, List<Integer>> partitioned = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));` 
```
Output:  
`{false=[1,3,5], true=[2,4]}`

ğŸ§  _Tip:_ â€œpartition = binary grouping.â€

----------

### ğŸ¯ `reducing()`

Performs reduction operation (custom aggregation).
``` java
int  sum  = Stream.of(1, 2, 3)
    .collect(Collectors.reducing(0, Integer::sum));` 
```
ğŸ§  _Tip:_ â€œreducing = manual aggregator.â€

----------

### ğŸ¯ `collectingAndThen()`

Post-process the result after collecting.
``` java
`List<String> unmodifiable =
    Stream.of("A", "B", "C")
          .collect(Collectors.collectingAndThen(
              Collectors.toList(),
              Collections::unmodifiableList
          ));` 
```
ğŸ§  _Tip:_ â€œCollect â†’ then transform.â€

----------

## ğŸ§© Internal Working (Visualization)

### Stream â†’ Collector â†’ Container

`Stream Elements â†’ Accumulator â†’ Combiner â†’ Finisher â†’ Final Result` 

Example memory visualization:
``` java
Stream.of(1,2,3)
   | map(x -> x*2)
   | collect(toList)
   â†“ Accumulator: [2], [2,4], [2,4,6]  Combiner (if parallel): merges  partial  lists  Finisher: returns  final  List 
```
----------

## ğŸ§   Interview Problems & Answers

### â“ Q1. Difference between `collect()` and `Collectors`?

**A:**

-   `collect()` is a **terminal operation** of Stream.
    
-   `Collectors` is a **utility class** providing predefined collectors.
    

----------

### â“ Q2. Difference between `groupingBy()` and `partitioningBy()`?

**A:**

-   `groupingBy()` â†’ groups by a key (multiple groups).
    
-   `partitioningBy()` â†’ splits into two groups (boolean condition).
    

----------

### â“ Q3. What if `toMap()` has duplicate keys?

**A:**  
It throws `IllegalStateException` unless a merge function is provided.

----------

### â“ Q4. How do you make an unmodifiable collection after collecting?

**A:**  
Use `collectingAndThen()`.

----------

### â“ Q5. How is `reducing()` different from `reduce()`?

**A:**

-   `reduce()` is a **Stream method**.
    
-   `reducing()` is a **Collector** that can be used inside another collector (like groupingBy).
    

Example:
``` java
Map<Integer, Integer> sumByLength = Stream.of("a", "bb", "ccc")
    .collect(Collectors.groupingBy(String::length,
        Collectors.reducing(0, String::length, Integer::sum)));` 
```
----------

### â“ Q6. How do you find average marks by subject using Collectors?
``` java
class  Student {
    String subject; int marks;
    Student(String s, int m) { subject=s; marks=m; }
}

List<Student> list = Arrays.asList( new  Student("Math", 80), new  Student("Math", 90), new  Student("Science", 70)
);

Map<String, Double> avg = list.stream()
    .collect(Collectors.groupingBy(s -> s.subject,
        Collectors.averagingInt(s -> s.marks)));`

```

## ğŸ”¥ Pro Tips

1.  **Use method references**  for cleaner code:  `.map(Employee::getName)`
2.  **Combine collectors**  using downstream collectors for powerful operations
3.  **Handle null values**  in toMap using three-argument version
4.  **Use partitioningBy**  instead of groupingBy for boolean conditions (more efficient)
5.  **Prefer specific types**  like  `toCollection(ArrayList::new)`  when you need specific collection types

----------

_Happy Coding! Master these collectors and you'll handle 90% of real-world stream operations with ease._  ğŸš€
