# Java 8 Functional Interfaces - Complete Tutorial

## ğŸ“š Table of Contents

1.  Introduction
2.  Core Concepts
3.  Built-in Functional Interfaces
4.  Memory Visualization
5.  Real-World Analogies
6.  Practical Examples
7.  Interview Problems with Solutions

----------

## ğŸ¯ Introduction

### What is a Functional Interface?

A  **Functional Interface**  is an interface that contains  **exactly one abstract method**. It can have multiple default or static methods, but only one abstract method.

**Key Points:**

-   Annotated with  `@FunctionalInterface`  (optional but recommended)
-   Can be used as lambda expressions
-   Forms the foundation of functional programming in Java 8
-   Enables method references and lambda expressions
### âœ… **Annotation**

We mark functional interfaces using `@FunctionalInterface` â€” this ensures the compiler throws an error if more than one abstract method is added.

**Syntax:**

java

```java
@FunctionalInterface
interface MyFunctionalInterface {
    void execute(); // Single abstract method (SAM)
}
```

----------

## ğŸ§  Core Concepts

### Why Functional Interfaces?

**Before Java 8 (Anonymous Inner Classes):**

java

```java
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Running...");
    }
};
```

**After Java 8 (Lambda Expression):**

java

```java
Runnable runnable = () -> System.out.println("Running...");
```

### The @FunctionalInterface Annotation

java

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // Default methods are allowed
    default void showInfo() {
        System.out.println("Calculator Interface");
    }
    
    // Static methods are allowed
    static void helper() {
        System.out.println("Helper method");
    }
}
```

----------



## ğŸ¯  Why Functional Interfaces were introduced

Before Java 8, you needed **anonymous inner classes** to pass a piece of behavior (function).  
Java 8 introduced **Lambda Expressions** â†’ which require a **target type** (Functional Interface).

ğŸ’¡ **Functional Interface acts as a bridge between OOP and Functional Programming**.

----------

## ğŸ”  Memory Visualization (Analogy)

### ğŸ§© **Analogy:**

Think of a **Functional Interface** as a _remote control_ with only one main button.  
When you connect a **Lambda Expression**, it defines what happens when that one button is pressed.

For example:
``` java
@FunctionalInterface  
interface  Button {
 void  click();
} 
Button  b  = () -> 
System.out.println("Clicked!");
b.click(); // triggers the action` 
```
ğŸ§  **Visualization:**

-   `Button` = remote
    
-   `Lambda` = custom action assigned to the single button
    

----------

## ğŸ§© **4. Predefined Functional Interfaces in `java.util.function`**

### âœ´ï¸ **Main Categories**
<img width="883" height="562" alt="image" src="https://github.com/user-attachments/assets/5cf9178c-3673-4d72-8f08-f62eb519a6ef" />



## ğŸ“¦ Built-in Functional Interfaces

Java 8 provides 43+ functional interfaces in  `java.util.function`  package. Here are the main categories:

### 1.  **Predicate<T>**  - The Tester ğŸ”

**Purpose:**  Tests a condition and returns boolean

**Method:**  `boolean test(T t)`

**Use Case:**  Filtering, validation

java

```java
import java.util.function.Predicate;

// Example 1: Simple predicate
Predicate<Integer> isEven = num -> num % 2 == 0;
System.out.println(isEven.test(4));  // true
System.out.println(isEven.test(5));  // false

// Example 2: String validation
Predicate<String> isLongString = str -> str.length() > 5;
System.out.println(isLongString.test("Hello"));      // false
System.out.println(isLongString.test("Hello World")); // true

// Example 3: Chaining predicates
Predicate<Integer> isPositive = num -> num > 0;
Predicate<Integer> isLessThan100 = num -> num < 100;

Predicate<Integer> isValidRange = isPositive.and(isLessThan100);
System.out.println(isValidRange.test(50));   // true
System.out.println(isValidRange.test(150));  // false

// Example 4: Filtering a list
List<String> names = Arrays.asList("Alice", "Bob", "Alexander", "Charlie");
Predicate<String> startsWithA = name -> name.startsWith("A");

names.stream()
     .filter(startsWithA)
     .forEach(System.out::println);  // Alice, Alexander
```

**Key Methods:**

-   `and(Predicate)`  - Logical AND
-   `or(Predicate)`  - Logical OR
-   `negate()`  - Logical NOT
ğŸ§  Visualization:

â€œPredicateâ€ is like a filter gate â€” only allows data that meets a condition to pass.
----------



### 2.  **Function<T, R>**  - The Transformer ğŸ”„

**Purpose:**  Transforms input of type T to output of type R

**Method:**  `R apply(T t)`

**Use Case:**  Data transformation, mapping

java

```java
import java.util.function.Function;

// Example 1: String to Integer
Function<String, Integer> stringLength = str -> str.length();
System.out.println(stringLength.apply("Hello"));  // 5

// Example 2: Number transformation
Function<Integer, Integer> square = num -> num * num;
System.out.println(square.apply(5));  // 25

// Example 3: Chaining functions
Function<String, Integer> lengthFunction = str -> str.length();
Function<Integer, Integer> doubleFunction = num -> num * 2;

Function<String, Integer> combinedFunction = lengthFunction.andThen(doubleFunction);
System.out.println(combinedFunction.apply("Java"));  // 8 (4 * 2)

// Example 4: Object transformation
Function<Employee, String> getEmployeeName = emp -> emp.getName();
Function<Employee, Integer> getEmployeeSalary = emp -> emp.getSalary();

// Example 5: Using with streams
List<String> words = Arrays.asList("apple", "banana", "cherry");
List<Integer> lengths = words.stream()
                             .map(stringLength)
                             .collect(Collectors.toList());
System.out.println(lengths);  // [5, 6, 6]
```

**Key Methods:**

-   `andThen(Function)`  - Executes after current function
-   `compose(Function)`  - Executes before current function
ğŸ§  Visualization:

â€œFunctionâ€ is like a converter machine â€” takes input, applies logic, and gives output.
----------



### 3.  **Consumer<T>**  - The Action Performer âš¡

**Purpose:**  Accepts input and performs an operation (no return)

**Method:**  `void accept(T t)`

**Use Case:**  Printing, logging, updating

java

```java
import java.util.function.Consumer;

// Example 1: Simple printing
Consumer<String> printer = msg -> System.out.println(msg);
printer.accept("Hello World");

// Example 2: List processing
Consumer<Integer> squarePrinter = num -> System.out.println(num * num);
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.forEach(squarePrinter);  // 1, 4, 9, 16, 25

// Example 3: Chaining consumers
Consumer<String> upperCase = str -> System.out.println(str.toUpperCase());
Consumer<String> lowerCase = str -> System.out.println(str.toLowerCase());

Consumer<String> combined = upperCase.andThen(lowerCase);
combined.accept("Java");  
// Output:
// JAVA
// java

// Example 4: Object modification
Consumer<List<Integer>> listModifier = list -> {
    list.add(100);
    list.replaceAll(n -> n * 2);
};

List<Integer> myList = new ArrayList<>(Arrays.asList(1, 2, 3));
listModifier.accept(myList);
System.out.println(myList);  // [2, 4, 6, 100]
```
ğŸ§  Visualization:

â€œConsumerâ€ is like a speaker â€” it consumes your input and produces side effects (output/print).
----------



### 4.  **Supplier<T>**  - The Producer ğŸ­

**Purpose:**  Supplies/generates a value (no input required)

**Method:**  `T get()`

**Use Case:**  Lazy initialization, factory pattern, random generation

java

```java
import java.util.function.Supplier;

// Example 1: Simple value supplier
Supplier<String> helloSupplier = () -> "Hello World";
System.out.println(helloSupplier.get());  // Hello World

// Example 2: Random number generator
Supplier<Double> randomSupplier = () -> Math.random();
System.out.println(randomSupplier.get());  // Random number

// Example 3: Current timestamp
Supplier<Long> timestampSupplier = () -> System.currentTimeMillis();
System.out.println(timestampSupplier.get());

// Example 4: Lazy initialization
Supplier<List<String>> listSupplier = () -> {
    System.out.println("Creating new list...");
    return new ArrayList<>();
};

// List is created only when get() is called
List<String> list1 = listSupplier.get();  // Prints: Creating new list...
List<String> list2 = listSupplier.get();  // Prints: Creating new list...

// Example 5: Factory pattern
Supplier<Employee> employeeFactory = () -> new Employee("John", 50000);
Employee emp1 = employeeFactory.get();
Employee emp2 = employeeFactory.get();

// Example 6: With Optional
Optional<String> optional = Optional.empty();
String result = optional.orElseGet(() -> "Default Value");
System.out.println(result);  // Default Value
```
ğŸ§  Visualization:

â€œSupplierâ€ is like a vending machine â€” press the button, it gives something.
----------



### 5.  **BiFunction<T, U, R>**  - The Two-Input Transformer ğŸ”€

**Purpose:**  Accepts two inputs and returns a result

**Method:**  `R apply(T t, U u)`

**Use Case:**  Two-parameter operations

java

```java
import java.util.function.BiFunction;

// Example 1: Addition
BiFunction<Integer, Integer, Integer> addition = (a, b) -> a + b;
System.out.println(addition.apply(5, 3));  // 8

// Example 2: String concatenation
BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
System.out.println(concat.apply("Hello", "World"));  // Hello World

// Example 3: Complex calculation
BiFunction<Double, Double, Double> power = (base, exp) -> Math.pow(base, exp);
System.out.println(power.apply(2.0, 3.0));  // 8.0

// Example 4: Object creation
BiFunction<String, Integer, Employee> employeeCreator = 
    (name, salary) -> new Employee(name, salary);
Employee emp = employeeCreator.apply("Alice", 75000);

// Example 5: With Map operations
Map<String, Integer> salaries = new HashMap<>();
salaries.put("John", 50000);
salaries.merge("John", 5000, (oldVal, newVal) -> oldVal + newVal);
System.out.println(salaries.get("John"));  // 55000
```

----------

### 6.  **BiConsumer<T, U>**  - The Two-Input Action Performer âš¡âš¡

**Purpose:**  Accepts two inputs and performs operation (no return)

**Method:**  `void accept(T t, U u)`

java

```java
import java.util.function.BiConsumer;

// Example 1: Print two values
BiConsumer<String, Integer> printer = (name, age) -> 
    System.out.println(name + " is " + age + " years old");
printer.accept("Alice", 25);

// Example 2: Map iteration
Map<String, Integer> map = new HashMap<>();
map.put("Apple", 10);
map.put("Banana", 20);

BiConsumer<String, Integer> mapPrinter = (key, value) -> 
    System.out.println(key + ": " + value);
map.forEach(mapPrinter);

// Example 3: List modification
BiConsumer<List<Integer>, Integer> listAdder = (list, num) -> {
    list.add(num);
    list.add(num * 2);
};

List<Integer> numbers = new ArrayList<>();
listAdder.accept(numbers, 5);
System.out.println(numbers);  // [5, 10]
```

----------

### 7.  **BiPredicate<T, U>**  - The Two-Input Tester ğŸ”ğŸ”

**Purpose:**  Tests condition with two inputs

**Method:**  `boolean test(T t, U u)`

java

```java
import java.util.function.BiPredicate;

// Example 1: Range check
BiPredicate<Integer, Integer> isInRange = (num, limit) -> num < limit;
System.out.println(isInRange.test(5, 10));  // true

// Example 2: String comparison
BiPredicate<String, String> startsWith = (str, prefix) -> str.startsWith(prefix);
System.out.println(startsWith.test("Hello", "He"));  // true

// Example 3: Password validation
BiPredicate<String, Integer> isValidPassword = 
    (password, minLength) -> password.length() >= minLength && 
                             password.matches(".*[0-9].*");
System.out.println(isValidPassword.test("pass123", 6));  // true
```

----------

### 8.  **UnaryOperator<T>**  - The Self-Transformer ğŸ”

**Purpose:**  Special case of Function where input and output are same type

**Method:**  `T apply(T t)`

**Extends:**  `Function<T, T>`

java

```java
import java.util.function.UnaryOperator;

// Example 1: String transformation
UnaryOperator<String> toUpperCase = str -> str.toUpperCase();
System.out.println(toUpperCase.apply("hello"));  // HELLO

// Example 2: Number transformation
UnaryOperator<Integer> triple = num -> num * 3;
System.out.println(triple.apply(5));  // 15

// Example 3: List transformation
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.replaceAll(num -> num * num);
System.out.println(numbers);  // [1, 4, 9, 16, 25]

// Example 4: Chaining operations
UnaryOperator<String> addExclamation = str -> str + "!";
UnaryOperator<String> makeUpperCase = str -> str.toUpperCase();

UnaryOperator<String> combined = addExclamation.andThen(makeUpperCase);
System.out.println(combined.apply("hello"));  // HELLO!
```

----------

### 9.  **BinaryOperator<T>**  - The Two-Input Self-Transformer ğŸ”ğŸ”

**Purpose:**  Special case of BiFunction where both inputs and output are same type

**Method:**  `T apply(T t1, T t2)`

**Extends:**  `BiFunction<T, T, T>`

java

```java
import java.util.function.BinaryOperator;

// Example 1: Addition
BinaryOperator<Integer> sum = (a, b) -> a + b;
System.out.println(sum.apply(5, 3));  // 8

// Example 2: Finding maximum
BinaryOperator<Integer> max = (a, b) -> a > b ? a : b;
System.out.println(max.apply(10, 20));  // 20

// Example 3: String concatenation
BinaryOperator<String> concat = (s1, s2) -> s1 + " " + s2;
System.out.println(concat.apply("Hello", "World"));  // Hello World

// Example 4: Using with reduce
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int total = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(total);  // 15

// Example 5: Using BinaryOperator.maxBy()
BinaryOperator<String> longestString = 
    BinaryOperator.maxBy(Comparator.comparingInt(String::length));
Optional<String> longest = Stream.of("a", "abc", "ab")
                                 .reduce(longestString);
System.out.println(longest.get());  // abc
```

----------

## ğŸ¨ Memory Visualization

### How Lambda Expressions Work in Memory

```
HEAP MEMORY
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Anonymous Object (Lambda Instance)     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Functional Interface Type     â”‚    â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚    â”‚
â”‚  â”‚  Method: apply/test/accept     â”‚    â”‚
â”‚  â”‚  Lambda Body: { code }         â”‚    â”‚
â”‚  â”‚  Captured Variables (if any)   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STACK MEMORY
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Reference Variable â”‚
â”‚  (predicate/function)â”‚
â”‚         â”‚            â”‚
â”‚         â–¼            â”‚
â”‚    [Object Ref]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Example Visualization:

java

```java
int multiplier = 10;  // Effectively final variable
Function<Integer, Integer> func = x -> x * multiplier;

/* Memory Layout:
   
   STACK:
   â”œâ”€ multiplier = 10
   â””â”€ func â†’ [Reference to Lambda Object]
   
   HEAP:
   Lambda Object {
     type: Function<Integer, Integer>
     captured: [multiplier = 10]  â† Closure
     code: x -> x * multiplier
   }
*/
```

----------

## ğŸŒ Real-World Analogies

### 1.  **Predicate = Security Guard**  ğŸš¨

-   **Job:**  Check if you can enter (true/false)
-   **Example:**  "Are you 18+?" â†’ Yes/No

java

```java
Predicate<Integer> canEnter = age -> age >= 18;
```

### 2.  **Function = Vending Machine**  ğŸª

-   **Job:**  Take input (money), return output (product)
-   **Example:**  Insert â‚¹20 â†’ Get Chips

java

```java
Function<Integer, String> vendingMachine = money -> 
    money >= 20 ? "Chips" : "Insufficient";
```

### 3.  **Consumer = Printer**  ğŸ–¨ï¸

-   **Job:**  Take input, do something, return nothing
-   **Example:**  Take document â†’ Print it (no return)

java

```java
Consumer<String> printer = doc -> System.out.println(doc);
```

### 4.  **Supplier = ATM Machine**  ğŸ§

-   **Job:**  No input needed, just give money
-   **Example:**  Press button â†’ Get cash

java

```java
Supplier<Double> atm = () -> 500.0;
```

### 5.  **BiFunction = Calculator**  ğŸ§®

-   **Job:**  Take two numbers, return result
-   **Example:**  5 + 3 = 8

java

```java
BiFunction<Integer, Integer, Integer> calculator = (a, b) -> a + b;
```

### 6.  **UnaryOperator = Amplifier**  ğŸ“¢

-   **Job:**  Take input, modify it, return same type
-   **Example:**  Volume 5 â†’ Volume 15 (amplified 3x)

java

```java
UnaryOperator<Integer> amplifier = volume -> volume * 3;
```

----------

## ğŸ’¡ Practical Examples

### Example 1: Employee Management System

java

```java
class Employee {
    private String name;
    private int age;
    private double salary;
    
    // Constructor, getters, setters
    public Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
    public void setSalary(double salary) { this.salary = salary; }
    
    @Override
    public String toString() {
        return "Employee{name='" + name + "', age=" + age + 
               ", salary=" + salary + "}";
    }
}

public class EmployeeManagement {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30, 50000),
            new Employee("Bob", 25, 45000),
            new Employee("Charlie", 35, 60000),
            new Employee("David", 28, 48000)
        );
        
        // 1. Filter employees with salary > 48000
        Predicate<Employee> highEarner = emp -> emp.getSalary() > 48000;
        System.out.println("High Earners:");
        employees.stream()
                 .filter(highEarner)
                 .forEach(System.out::println);
        
        // 2. Get list of employee names
        Function<Employee, String> nameExtractor = Employee::getName;
        List<String> names = employees.stream()
                                      .map(nameExtractor)
                                      .collect(Collectors.toList());
        System.out.println("\nEmployee Names: " + names);
        
        // 3. Give 10% raise to all employees
        Consumer<Employee> giveRaise = emp -> 
            emp.setSalary(emp.getSalary() * 1.10);
        employees.forEach(giveRaise);
        System.out.println("\nAfter 10% Raise:");
        employees.forEach(System.out::println);
        
        // 4. Find total salary
        BinaryOperator<Double> sumSalaries = (a, b) -> a + b;
        double totalSalary = employees.stream()
                                      .map(Employee::getSalary)
                                      .reduce(0.0, sumSalaries);
        System.out.println("\nTotal Salary: " + totalSalary);
    }
}
```

----------

### Example 2: Student Grade Processing

java

```java
class Student {
    private String name;
    private int marks;
    
    public Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }
    
    public String getName() { return name; }
    public int getMarks() { return marks; }
}

public class GradeProcessor {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("John", 85),
            new Student("Sarah", 92),
            new Student("Mike", 78),
            new Student("Emma", 95)
        );
        
        // 1. Check if student passed (marks >= 80)
        Predicate<Student> isPassed = s -> s.getMarks() >= 80;
        
        // 2. Convert marks to grade
        Function<Student, String> marksToGrade = s -> {
            int marks = s.getMarks();
            if (marks >= 90) return "A";
            else if (marks >= 80) return "B";
            else if (marks >= 70) return "C";
            else return "F";
        };
        
        // 3. Print student results
        BiConsumer<String, String> printResult = (name, grade) ->
            System.out.println(name + " received grade: " + grade);
        
        System.out.println("Passed Students:");
        students.stream()
                .filter(isPassed)
                .forEach(s -> printResult.accept(s.getName(), 
                              marksToGrade.apply(s)));
        
        // 4. Create grade report supplier
        Supplier<String> reportHeader = () -> 
            "\n========= GRADE REPORT =========\n";
        
        System.out.println(reportHeader.get());
        students.forEach(s -> 
            System.out.println(s.getName() + ": " + 
                             marksToGrade.apply(s)));
    }
}
```

----------

### Example 3: Shopping Cart with Discounts

java

```java
class Product {
    private String name;
    private double price;
    private String category;
    
    public Product(String name, double price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
}

public class ShoppingCart {
    public static void main(String[] args) {
        List<Product> cart = Arrays.asList(
            new Product("Laptop", 1000, "Electronics"),
            new Product("Mouse", 20, "Electronics"),
            new Product("Shirt", 30, "Clothing"),
            new Product("Book", 15, "Books")
        );
        
        // 1. Filter expensive items (price > 50)
        Predicate<Product> isExpensive = p -> p.getPrice() > 50;
        
        // 2. Apply discount based on category
        Function<Product, Double> applyDiscount = p -> {
            if (p.getCategory().equals("Electronics")) {
                return p.getPrice() * 0.9;  // 10% off
            } else if (p.getCategory().equals("Clothing")) {
                return p.getPrice() * 0.8;  // 20% off
            }
            return p.getPrice();
        };
        
        // 3. Calculate total price
        BinaryOperator<Double> sum = (a, b) -> a + b;
        
        // 4. Display cart items
        Consumer<Product> displayProduct = p ->
            System.out.printf("%s - $%.2f (After discount: $%.2f)%n",
                p.getName(), p.getPrice(), applyDiscount.apply(p));
        
        System.out.println("Shopping Cart:");
        cart.forEach(displayProduct);
        
        // Calculate total
        double total = cart.stream()
                          .map(applyDiscount)
                          .reduce(0.0, sum);
        
        System.out.printf("%nTotal Amount: $%.2f%n", total);
        
        // Expensive items only
        System.out.println("\nExpensive Items:");
        cart.stream()
            .filter(isExpensive)
            .forEach(p -> System.out.println(p.getName()));
    }
}
```

----------

## ğŸ¯ Interview Problems with Solutions

### Problem 1: Find Even Numbers from List

**Question:**  Given a list of integers, filter and print only even numbers.

java

```java
// Solution 1: Using Predicate
public static void findEvenNumbers() {
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
    Predicate<Integer> isEven = num -> num % 2 == 0;
    
    System.out.println("Even Numbers:");
    numbers.stream()
           .filter(isEven)
           .forEach(System.out::println);
}

// Output: 2, 4, 6, 8, 10
```

**Follow-up:**  Find sum of even numbers.

java

```java
public static void sumOfEvenNumbers() {
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
    int sum = numbers.stream()
                     .filter(num -> num % 2 == 0)
                     .reduce(0, (a, b) -> a + b);
    
    System.out.println("Sum of even numbers: " + sum);  // 30
}
```

----------

### Problem 2: Transform String List to Uppercase

**Question:**  Convert all strings in a list to uppercase.

java

```java
public static void transformToUpperCase() {
    List<String> words = Arrays.asList("apple", "banana", "cherry");
    
    // Solution 1: Using Function
    Function<String, String> toUpper = str -> str.toUpperCase();
    List<String> upperWords = words.stream()
                                   .map(toUpper)
                                   .collect(Collectors.toList());
    
    System.out.println(upperWords);  // [APPLE, BANANA, CHERRY]
    
    // Solution 2: Using UnaryOperator
    UnaryOperator<String> upperOperator = String::toUpperCase;
    words.replaceAll(upperOperator);
    System.out.println(words);
}
```

----------

### Problem 3: Find Longest String

**Question:**  Find the longest string from a list using functional interfaces.

java

```java
public static void findLongestString() {
    List<String> words = Arrays.asList("Java", "Python", "JavaScript", "C++");
    
    // Solution 1: Using BinaryOperator
    BinaryOperator<String> longerString = (s1, s2) -> 
        s1.length() > s2.length() ? s1 : s2;
    
    Optional<String> longest = words.stream()
                                    .reduce(longerString);
    
    longest.ifPresent(s -> 
        System.out.println("Longest string: " + s));  // JavaScript
    
    // Solution 2: Using BinaryOperator.maxBy
    BinaryOperator<String> maxBy = 
        BinaryOperator.maxBy(Comparator.comparingInt(String::length));
    
    Optional<String> result = words.stream().reduce(maxBy);
    result.ifPresent(System.out::println);
}
```

----------

### Problem 4: Remove Duplicates and Sort

**Question:**  Remove duplicates from a list and sort it.

java

```java
public static void removeDuplicatesAndSort() {
    List<Integer> numbers = Arrays.asList(5, 3, 8, 3, 9, 5, 2, 8, 1);
    
    List<Integer> result = numbers.stream()
                                  .distinct()
                                  .sorted()
                                  .collect(Collectors.toList());
    
    System.out.println(result);  // [1, 2, 3, 5, 8, 9]
    
    // With custom comparator
    BinaryOperator<Integer> maxComparator = (a, b) -> Integer.compare(b, a);
    List<Integer> descending = numbers.stream()
                                      .distinct()
                                      .sorted((a, b) -> b - a)
                                      .collect(Collectors.toList());
    
    System.out.println(descending);  // [9, 8, 5, 3, 2, 1]
}
```

----------

### Problem 5: Group Employees by Department

**Question:**  Group employees by their department using functional interfaces.

java

```java
class Employee {
    private String name;
    private String department;
    private double salary;
    
    public Employee(String name, String department, double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
}

public static void groupByDepartment() {
    List<Employee> employees = Arrays.asList(
        new Employee("Alice", "IT", 70000),
        new Employee("Bob", "HR", 50000),
        new Employee("Charlie", "IT", 80000),
        new Employee("David", "Finance", 60000),
        new Employee("Eve", "HR", 55000)
    );
    
    // Function to extract department
    Function<Employee, String> departmentExtractor = Employee::getDepartment;
    
    // Group by department
    Map<String, List<Employee>> byDepartment = 
        employees.stream()
                 .collect(Collectors.groupingBy(departmentExtractor));
    
    // Print grouped employees
    BiConsumer<String, List<Employee>> printDepartment = (dept, empList) -> {
        System.out.println("\n" + dept + " Department:");
        empList.forEach(e -> System.out.println("  " + e.getName()));
    };
    
    byDepartment.forEach(printDepartment);
    
    /* Output:
    IT Department:
      Alice
      Charlie
    
    HR Department:
      Bob
      Eve
    
    Finance Department:
      David
    */
}
```

----------

### Problem 6: Calculate Average Salary by Department

**Question:**  Find average salary for each department.

java

```java
public static void averageSalaryByDepartment() {
    List<Employee> employees = Arrays.asList(
        new Employee("Alice", "IT", 70000),
        new Employee("Bob", "HR", 50000),
        new Employee("Charlie", "IT", 80000),
        new Employee("David", "Finance", 60000),
        new Employee("Eve", "HR", 55000)
    );
    
    // Group and calculate average
    Map<String, Double> avgSalaryByDept = employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.averagingDouble(Employee::getSalary)
        ));
    
    // Print results
    BiConsumer<String, Double> printAverage = (dept, avg) ->
        System.out.printf("%s: $%.2f%n", dept, avg);
    
    System.out.println("Average Salary by Department:");
    avgSalaryByDept.forEach(printAverage);
    
    /* Output:
    Average Salary by Department:
    IT: $75000.00
    HR: $52500.00
    Finance: $60000.00
    */
}
```

----------

### Problem 7: Chain Multiple Predicates

**Question:**  Filter employees who are in IT department AND have salary > 60000.

java

```java
public static void chainPredicates() {
    List<Employee> employees = Arrays.asList(
        new Employee("Alice", "IT", 70000),
        new Employee("Bob", "HR", 50000),
        new Employee("Charlie", "IT", 55000),
        new Employee("David", "IT", 80000)
    );
    
    // Create individual predicates
    Predicate<Employee> isIT = emp -> emp.getDepartment().equals("IT");
    Predicate<Employee> highSalary = emp -> emp.getSalary() > 60000;
    
    // Chain predicates using AND
    Predicate<Employee> itWithHighSalary = isIT.and(highSalary);
    
    System.out.println("IT employees with salary > 60000:");
    employees.stream()
             .filter(itWithHighSalary)
             .forEach(e -> System.out.println(e.getName() + " - $" + e.getSalary()));
    
    /* Output:
    Alice - $70000.0
    David - $80000.0
    */
    
    // Using OR
    Predicate<Employee> isHR = emp -> emp.getDepartment().equals("HR");
    Predicate<Employee> itOrHR = isIT.or(isHR);
    
    System.out.println("\nIT or HR employees:");
    employees.stream()
             .filter(itOrHR)
             .forEach(e -> System.out.println(e.getName()));
    
    // Using NEGATE
    System.out.println("\nNon-IT employees:");
    employees.stream()
             .filter(isIT.negate())
             .forEach(e -> System.out.println(e.getName()));
}
```

----------

### Problem 8: Compose and AndThen

**Question:**  Demonstrate the difference between  `compose`  and  `andThen`.

java

```java
public static void composeFunctions() {
    // andThen: executes left function first, then right
    Function<Integer, Integer> multiplyBy2 = x -> x * 2;
    Function<Integer, Integer> add3 = x -> x + 3;
    
    Function<Integer, Integer> multiplyThenAdd = multiplyBy2.andThen(add3);
    System.out.println("andThen result: " + multiplyThenAdd.apply(5));
    // (5 * 2) + 3 = 13
    
    // compose: executes right function first, then left
    Function<Integer, Integer> addThenMultiply = multiplyBy2.compose(add3);
    System.out.println("compose result: " + addThenMultiply.apply(5));
    // (5 + 3) * 2 = 16
    
    /* Visualization:
    
    andThen:  5 â†’ [Ã—2] â†’ 10 â†’ [+3] â†’ 13
    compose:  5 â†’ [+3] â†’ 8 â†’ [Ã—2] â†’ 16
    */
}
```

----------

### Problem 9: Custom Functional Interface

**Question:**  Create a custom functional interface for mathematical operations.

java

```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
    
    // Default method
    default void printOperation(int a, int b) {
        System.out.println("Result: " + operate(a, b));
    }
    
    // Static method
    static MathOperation getAddition() {
        return (a, b) -> a + b;
    }
}

public static void customFunctionalInterface() {
    // Using lambda
    MathOperation addition = (a, b) -> a + b;
    MathOperation subtraction = (a, b) -> a - b;
    MathOperation multiplication = (a, b) -> a * b;
    MathOperation division = (a, b) -> b != 0 ? a / b : 0;
    
    System.out.println("Addition: " + addition.operate(10, 5));      // 15
    System.out.println("Subtraction: " + subtraction.operate(10, 5)); // 5
    System.out.println("Multiplication: " + multiplication.operate(10, 5)); // 50
    System.out.println("Division: " + division.operate(10, 5));      // 2
    
    // Using default method
    addition.printOperation(20, 30);  // Result: 50
    
    // Using static method
    MathOperation staticAdd = MathOperation.getAddition();
    System.out.println("Static addition: " + staticAdd.operate(7, 8)); // 15
}
```

----------

### Problem 10: Find Second Highest Salary

**Question:**  Find the second highest salary using functional interfaces.

java

```java
public static void findSecondHighestSalary() {
    List<Employee> employees = Arrays.asList(
        new Employee("Alice", "IT", 70000),
        new Employee("Bob", "HR", 50000),
        new Employee("Charlie", "IT", 80000),
        new Employee("David", "Finance", 60000),
        new Employee("Eve", "HR", 80000),  // Same as Charlie
        new Employee("Frank", "IT", 90000)
    );
    
    // Extract salary using Function
    Function<Employee, Double> salaryExtractor = Employee::getSalary;
    
    // Find second highest
    Optional<Double> secondHighest = employees.stream()
        .map(salaryExtractor)
        .distinct()                    // Remove duplicates
        .sorted((a, b) -> Double.compare(b, a))  // Sort descending
        .skip(1)                       // Skip first (highest)
        .findFirst();
    
    secondHighest.ifPresent(salary -> 
        System.out.println("Second highest salary: $" + salary));
    // Output: Second highest salary: $80000.0
    
    // Alternative using BinaryOperator
    BinaryOperator<Double> max = BinaryOperator.maxBy(Double::compare);
}
```

----------

### Problem 11: Word Frequency Counter

**Question:**  Count frequency of each word in a list using functional interfaces.

java

```java
public static void wordFrequencyCounter() {
    List<String> words = Arrays.asList(
        "apple", "banana", "apple", "cherry", 
        "banana", "apple", "date", "cherry"
    );
    
    // Using Function to create identity
    Function<String, String> identity = word -> word;
    
    // Count frequencies
    Map<String, Long> frequency = words.stream()
        .collect(Collectors.groupingBy(
            identity,
            Collectors.counting()
        ));
    
    // Print using BiConsumer
    BiConsumer<String, Long> printer = (word, count) ->
        System.out.println(word + ": " + count);
    
    System.out.println("Word Frequencies:");
    frequency.forEach(printer);
    
    /* Output:
    apple: 3
    banana: 2
    cherry: 2
    date: 1
    */
    
    // Find most frequent word
    BinaryOperator<Map.Entry<String, Long>> maxEntry = 
        BinaryOperator.maxBy(Map.Entry.comparingByValue());
    
    frequency.entrySet().stream()
        .reduce(maxEntry)
        .ifPresent(entry -> 
            System.out.println("\nMost frequent: " + entry.getKey() + 
                             " (" + entry.getValue() + " times)"));
}
```

----------

### Problem 12: Lazy Evaluation with Supplier

**Question:**  Demonstrate lazy evaluation using Supplier.

java

```java
public static void lazyEvaluation() {
    System.out.println("=== Without Supplier (Eager) ===");
    String eagerResult = getExpensiveString();
    if (false) {  // Never executes
        System.out.println(eagerResult);
    }
    // Output: Computing expensive string... (STILL EXECUTED!)
    
    System.out.println("\n=== With Supplier (Lazy) ===");
    Supplier<String> lazyResult = () -> getExpensiveString();
    if (false) {  // Never executes
        System.out.println(lazyResult.get());
    }
    // Output: (Nothing - method not called!)
    
    System.out.println("\n=== Using Supplier ===");
    Supplier<String> supplier = () -> getExpensiveString();
    System.out.println(supplier.get());  // Now it executes
}

private static String getExpensiveString() {
    System.out.println("Computing expensive string...");
    // Simulate expensive operation
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Expensive Result";
}
```

----------

### Problem 13: Partition List

**Question:**  Partition a list of numbers into even and odd using Predicate.

java

```java
public static void partitionList() {
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
    Predicate<Integer> isEven = num -> num % 2 == 0;
    
    Map<Boolean, List<Integer>> partitioned = numbers.stream()
        .collect(Collectors.partitioningBy(isEven));
    
    System.out.println("Even numbers: " + partitioned.get(true));
    System.out.println("Odd numbers: " + partitioned.get(false));
    
    /* Output:
    Even numbers: [2, 4, 6, 8, 10]
    Odd numbers: [1, 3, 5, 7, 9]
    */
    
    // Calculate sum of each partition
    BiFunction<List<Integer>, Integer, Integer> sumList = 
        (list, identity) -> list.stream().reduce(identity, Integer::sum);
    
    int evenSum = sumList.apply(partitioned.get(true), 0);
    int oddSum = sumList.apply(partitioned.get(false), 0);
    
    System.out.println("Sum of even: " + evenSum);  // 30
    System.out.println("Sum of odd: " + oddSum);    // 25
}
```

----------

### Problem 14: Method Reference Examples

**Question:**  Convert lambda expressions to method references.

java

```java
public static void methodReferences() {
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
    
    // 1. Static method reference
    // Lambda: name -> Integer.parseInt(name)
    Function<String, Integer> parser = Integer::parseInt;
    
    // 2. Instance method reference on object
    String prefix = "Hello ";
    // Lambda: s -> prefix.concat(s)
    Function<String, String> greeter = prefix::concat;
    System.out.println(greeter.apply("World"));  // Hello World
    
    // 3. Instance method reference on arbitrary object
    // Lambda: s -> s.toUpperCase()
    Function<String, String> upperCase = String::toUpperCase;
    names.stream().map(upperCase).forEach(System.out::println);
    
    // 4. Constructor reference
    // Lambda: () -> new ArrayList<>()
    Supplier<List<String>> listSupplier = ArrayList::new;
    List<String> newList = listSupplier.get();
    
    // 5. Array constructor reference
    Function<Integer, String[]> arrayCreator = String[]::new;
    String[] array = arrayCreator.apply(5);  // Creates array of size 5
    
    System.out.println("Array length: " + array.length);  // 5
}
```

----------

### Problem 15: Complex Stream Operations

**Question:**  Perform complex operations on employee data.

java

```java
public static void complexStreamOperations() {
    List<Employee> employees = Arrays.asList(
        new Employee("Alice", "IT", 70000),
        new Employee("Bob", "HR", 50000),
        new Employee("Charlie", "IT", 80000),
        new Employee("David", "Finance", 60000),
        new Employee("Eve", "HR", 55000),
        new Employee("Frank", "IT", 90000),
        new Employee("Grace", "Finance", 65000)
    );
    
    // 1. Find top 3 earners
    System.out.println("Top 3 Earners:");
    employees.stream()
        .sorted((e1, e2) -> Double.compare(e2.getSalary(), e1.getSalary()))
        .limit(3)
        .forEach(e -> System.out.println(e.getName() + ": $" + e.getSalary()));
    
    // 2. Department with highest average salary
    Map<String, Double> avgSalaryByDept = employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.averagingDouble(Employee::getSalary)
        ));
    
    BinaryOperator<Map.Entry<String, Double>> maxEntry = 
        BinaryOperator.maxBy(Map.Entry.comparingByValue());
    
    avgSalaryByDept.entrySet().stream()
        .reduce(maxEntry)
        .ifPresent(entry -> 
            System.out.println("\nDepartment with highest avg salary: " + 
                             entry.getKey() + " ($" + entry.getValue() + ")"));
    
    // 3. Count employees per department
    Map<String, Long> countByDept = employees.stream()
        .collect(Collectors.groupingBy(
            Employee::getDepartment,
            Collectors.counting()
        ));
    
    System.out.println("\nEmployee count by department:");
    countByDept.forEach((dept, count) -> 
        System.out.println(dept + ": " + count));
    
    // 4. Get comma-separated names of IT employees
    String itEmployees = employees.stream()
        .filter(e -> e.getDepartment().equals("IT"))
        .map(Employee::getName)
        .collect(Collectors.joining(", "));
    
    System.out.println("\nIT Employees: " + itEmployees);
}
```

----------

## ğŸ“ Advanced Concepts

### Currying with Functional Interfaces

java

```java
// Traditional approach
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

// Curried version
Function<Integer, Function<Integer, Integer>> curriedAdd = 
    a -> b -> a + b;

// Usage
Function<Integer, Integer> add5 = curriedAdd.apply(5);
System.out.println(add5.apply(3));  // 8
System.out.println(add5.apply(10)); // 15

// One-liner usage
System.out.println(curriedAdd.apply(10).apply(20));  // 30
```

### Closure Example

java

```java
public Function<Integer, Integer> createMultiplier(int factor) {
    // 'factor' is captured in closure
    return number -> number * factor;
}

// Usage
Function<Integer, Integer> triple = createMultiplier(3);
Function<Integer, Integer> double = createMultiplier(2);

System.out.println(triple.apply(5));  // 15
System.out.println(double.apply(5));  // 10
```

----------



## ğŸ’¡ Best Practices

1.  **Use @FunctionalInterface annotation**  - Helps catch errors at compile time
2.  **Keep lambdas short**  - If complex, extract to method
3.  **Use method references**  - More readable than lambdas when applicable
4.  **Avoid side effects**  - Keep functions pure when possible
5.  **Use appropriate interface**  - Choose the right functional interface
6.  **Handle exceptions**  - Wrap checked exceptions in RuntimeException
7.  **Be mindful of captured variables**  - They must be effectively final

----------

## ğŸš¨ Common Pitfalls

### 1. Modifying Captured Variables

java

```java
// âŒ Wrong - Compile error
int count = 0;
Consumer<Integer> consumer = i -> count++;  // Error!

// âœ… Correct - Use wrapper or atomic
AtomicInteger count = new AtomicInteger(0);
Consumer<Integer> consumer = i -> count.incrementAndGet();
```

### 2. Multiple Abstract Methods

java

```java
// âŒ Wrong - Not a functional interface
interface NotFunctional {
    void method1();
    void method2();  // Two abstract methods!
}
```

### 3. Null Handling

java

```java
// âŒ Wrong - NullPointerException risk
Function<String, Integer> length = s -> s.length();

// âœ… Correct - Handle nulls
Function<String, Integer> safeLength = 
    s -> s != null ? s.length() : 0;
```

----------

## ğŸ¯ Summary

**Key Takeaways:**

-   Functional interfaces enable functional programming in Java
-   Lambda expressions provide concise syntax
-   Built-in interfaces cover most common use cases
-   Method references improve readability
-   Combine with Streams API for powerful data processing
-   Understanding closures and lazy evaluation is crucial

**When to Use:**

-   âœ… Short, simple operations
-   âœ… Stream API operations
-   âœ… Event handlers
-   âœ… Strategy pattern implementation
-   âŒ Complex business logic (use regular methods)
-   âŒ When debugging is priority (lambdas harder to debug)

----------



