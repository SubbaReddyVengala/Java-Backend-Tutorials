# Java 8 Functional Interfaces - Complete Tutorial

## ğŸ“š Table of Contents

1.  Introduction to Functional Interfaces
2.  Core Predefined Interfaces
3.  Memory Visualization & Analogies
4.  Advanced Examples
5.  Interview Problems with Solutions

----------

## ğŸ¯ Introduction to Functional Interfaces

### What is a Functional Interface?

A  **Functional Interface**  is an interface with  **exactly one abstract method**  (SAM - Single Abstract Method). It can have multiple default or static methods.

### Why Functional Interfaces?

-   Enable  **Lambda Expressions**  and  **Method References**
-   Support  **Functional Programming**  paradigm
-   Promote  **cleaner, more readable code**
-   Enable  **declarative programming style**

### @FunctionalInterface Annotation

java

```java
@FunctionalInterface
public interface MyFunction {
    void execute(); // Only one abstract method
    
    // Multiple default methods allowed
    default void log() {
        System.out.println("Logging...");
    }
    
    // Multiple static methods allowed
    static void info() {
        System.out.println("Info...");
    }
}
```

**Key Points:**

-   `@FunctionalInterface`  is optional but recommended (compile-time safety)
-   Compiler error if more than one abstract method exists
-   Inherited methods from Object don't count (e.g., toString(), equals())

----------

## ğŸ”§ Core Predefined Interfaces

### 1. Function<T, R> - The Transformer

**Memory Analogy:**  Think of a  **vending machine**  ğŸª

-   Insert money (Input T) â†’ Get snack (Output R)
-   Takes something, transforms it, returns something else

**Method Signature:**

java

```java
R apply(T t)
```

**Basic Example:**

java

```java
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        // Convert String to its length
        Function<String, Integer> stringLength = s -> s.length();
        System.out.println(stringLength.apply("Hello")); // Output: 5
        
        // Square a number
        Function<Integer, Integer> square = n -> n * n;
        System.out.println(square.apply(5)); // Output: 25
        
        // Convert to uppercase
        Function<String, String> toUpper = String::toUpperCase;
        System.out.println(toUpper.apply("java")); // Output: JAVA
    }
}
```

**Advanced Example - Function Chaining:**

java

```java
public class FunctionChaining {
    public static void main(String[] args) {
        Function<Integer, Integer> multiplyBy2 = x -> x * 2;
        Function<Integer, Integer> add10 = x -> x + 10;
        
        // andThen: execute first, then second
        // (5 * 2) + 10 = 20
        Integer result1 = multiplyBy2.andThen(add10).apply(5);
        System.out.println("andThen: " + result1); // 20
        
        // compose: execute second first, then first
        // (5 + 10) * 2 = 30
        Integer result2 = multiplyBy2.compose(add10).apply(5);
        System.out.println("compose: " + result2); // 30
    }
}
```

**Real-World Example:**

java

```java
public class DataTransformation {
    public static void main(String[] args) {
        Function<Employee, String> getName = Employee::getName;
        Function<String, String> formatName = name -> "Mr./Ms. " + name;
        
        Employee emp = new Employee("John", 30);
        String formattedName = getName.andThen(formatName).apply(emp);
        System.out.println(formattedName); // Mr./Ms. John
    }
}

class Employee {
    private String name;
    private int age;
    
    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}
```

----------

### 2. Predicate<T>  - The Validator

**Memory Analogy:**  Think of a  **bouncer at a club**  ğŸšª

-   Checks if you meet criteria (Input T) â†’ Yes/No (boolean)
-   Always returns true or false

**Method Signature:**

java

```java
boolean test(T t)
```

**Basic Example:**

java

```java
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        // Check if number is even
        Predicate<Integer> isEven = n -> n % 2 == 0;
        System.out.println(isEven.test(4)); // true
        System.out.println(isEven.test(5)); // false
        
        // Check if string is empty
        Predicate<String> isEmpty = String::isEmpty;
        System.out.println(isEmpty.test("")); // true
        
        // Check if age is adult
        Predicate<Integer> isAdult = age -> age >= 18;
        System.out.println(isAdult.test(20)); // true
    }
}
```

**Advanced Example - Predicate Chaining:**

java

```java
import java.util.function.Predicate;

public class PredicateChaining {
    public static void main(String[] args) {
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isGreaterThan10 = n -> n > 10;
        
        // AND: both conditions must be true
        Predicate<Integer> evenAndGreaterThan10 = isEven.and(isGreaterThan10);
        System.out.println(evenAndGreaterThan10.test(12)); // true
        System.out.println(evenAndGreaterThan10.test(8));  // false
        
        // OR: at least one condition must be true
        Predicate<Integer> evenOrGreaterThan10 = isEven.or(isGreaterThan10);
        System.out.println(evenOrGreaterThan10.test(15)); // true
        
        // NEGATE: opposite of the predicate
        Predicate<Integer> isOdd = isEven.negate();
        System.out.println(isOdd.test(5)); // true
    }
}
```

**Real-World Example - Filtering:**

java

```java
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class EmployeeFilter {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 25),
            new Employee("Bob", 35),
            new Employee("Charlie", 45),
            new Employee("Diana", 28)
        );
        
        Predicate<Employee> isYoung = e -> e.getAge() < 30;
        Predicate<Employee> nameStartsWithA = e -> e.getName().startsWith("A");
        
        List<Employee> filtered = employees.stream()
            .filter(isYoung.and(nameStartsWithA))
            .collect(Collectors.toList());
        
        filtered.forEach(e -> System.out.println(e.getName())); // Alice
    }
}
```

----------

### 3. Consumer<T>  - The Action Taker

**Memory Analogy:**  Think of a  **black hole**  ğŸ•³ï¸

-   Takes input (T) â†’ Performs action â†’ Returns nothing (void)
-   Consumes data without producing output

**Method Signature:**

java

```java
void accept(T t)
```

**Basic Example:**

java

```java
import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        // Print to console
        Consumer<String> printer = s -> System.out.println(s);
        printer.accept("Hello World"); // Hello World
        
        // Modify a list
        Consumer<List<Integer>> addElement = list -> list.add(100);
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3));
        addElement.accept(numbers);
        System.out.println(numbers); // [1, 2, 3, 100]
        
        // Database save operation (side effect)
        Consumer<Employee> saveToDb = emp -> {
            System.out.println("Saving to DB: " + emp.getName());
            // Actual DB save logic here
        };
        saveToDb.accept(new Employee("John", 30));
    }
}
```

**Advanced Example - Consumer Chaining:**

java

```java
import java.util.function.Consumer;

public class ConsumerChaining {
    public static void main(String[] args) {
        Consumer<String> printUpper = s -> System.out.println(s.toUpperCase());
        Consumer<String> printLower = s -> System.out.println(s.toLowerCase());
        
        // Chain consumers with andThen
        Consumer<String> combined = printUpper.andThen(printLower);
        combined.accept("Java"); 
        // Output:
        // JAVA
        // java
    }
}
```

**Real-World Example:**

java

```java
import java.util.*;
import java.util.function.Consumer;

public class ConsumerRealWorld {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 25),
            new Employee("Bob", 35)
        );
        
        // Multiple operations on each employee
        Consumer<Employee> giveRaise = e -> 
            System.out.println("Giving raise to " + e.getName());
        Consumer<Employee> sendEmail = e -> 
            System.out.println("Sending email to " + e.getName());
        Consumer<Employee> updateRecord = e -> 
            System.out.println("Updating record for " + e.getName());
        
        Consumer<Employee> processEmployee = giveRaise
            .andThen(sendEmail)
            .andThen(updateRecord);
        
        employees.forEach(processEmployee);
    }
}
```

----------

### 4. Supplier<T>  - The Factory

**Memory Analogy:**  Think of a  **factory**  ğŸ­ or  **magic box**

-   Takes nothing â†’ Produces output (T)
-   Supplies data without input

**Method Signature:**

java

```java
T get()
```

**Basic Example:**

java

```java
import java.util.function.Supplier;
import java.time.LocalDateTime;
import java.util.Random;

public class SupplierExample {
    public static void main(String[] args) {
        // Generate random number
        Supplier<Integer> randomInt = () -> new Random().nextInt(100);
        System.out.println(randomInt.get()); // Random number
        
        // Get current timestamp
        Supplier<LocalDateTime> currentTime = LocalDateTime::now;
        System.out.println(currentTime.get()); // Current date-time
        
        // Create new objects
        Supplier<Employee> employeeSupplier = () -> new Employee("Default", 0);
        Employee emp = employeeSupplier.get();
        System.out.println(emp.getName()); // Default
    }
}
```

**Real-World Example - Lazy Initialization:**

java

```java
import java.util.function.Supplier;

public class LazyInitialization {
    public static void main(String[] args) {
        // Expensive object creation - only when needed
        Supplier<ExpensiveObject> lazySupplier = () -> {
            System.out.println("Creating expensive object...");
            return new ExpensiveObject();
        };
        
        System.out.println("Supplier created, but object not yet created");
        
        // Object is created only when get() is called
        ExpensiveObject obj = lazySupplier.get();
        System.out.println("Object created");
    }
}

class ExpensiveObject {
    public ExpensiveObject() {
        // Simulate expensive operation
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Practical Use - Configuration:**

java

```java
public class ConfigurationExample {
    private static Supplier<String> dbUrlSupplier = () -> 
        System.getenv("DB_URL") != null ? 
        System.getenv("DB_URL") : "localhost:3306";
    
    private static Supplier<String> apiKeySupplier = () -> 
        System.getenv("API_KEY") != null ? 
        System.getenv("API_KEY") : "default-key";
    
    public static void main(String[] args) {
        System.out.println("DB URL: " + dbUrlSupplier.get());
        System.out.println("API Key: " + apiKeySupplier.get());
    }
}
```

----------

### 5. BiFunction<T, U, R> - Two-Input Transformer

**Memory Analogy:**  Think of a  **calculator**  ğŸ§®

-   Takes two inputs (T, U) â†’ Returns result (R)
-   Like addition: takes two numbers, returns sum

**Method Signature:**

java

```java
R apply(T t, U u)
```

**Basic Example:**

java

```java
import java.util.function.BiFunction;

public class BiFunctionExample {
    public static void main(String[] args) {
        // Add two integers
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        System.out.println(add.apply(5, 3)); // 8
        
        // Concatenate strings
        BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
        System.out.println(concat.apply("Hello", "World")); // Hello World
        
        // Calculate power
        BiFunction<Double, Double, Double> power = Math::pow;
        System.out.println(power.apply(2.0, 3.0)); // 8.0
    }
}
```

**Advanced Example:**

java

```java
import java.util.function.BiFunction;

public class BiFunctionAdvanced {
    public static void main(String[] args) {
        // Create Employee from name and age
        BiFunction<String, Integer, Employee> createEmployee = 
            (name, age) -> new Employee(name, age);
        
        Employee emp = createEmployee.apply("John", 30);
        System.out.println(emp.getName()); // John
        
        // Calculate discount price
        BiFunction<Double, Double, Double> applyDiscount = 
            (price, discount) -> price - (price * discount / 100);
        
        Double finalPrice = applyDiscount.apply(1000.0, 20.0);
        System.out.println("Final Price: " + finalPrice); // 800.0
        
        // BiFunction chaining with andThen
        BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
        java.util.function.Function<Integer, Integer> square = x -> x * x;
        
        // (3 * 4) then square = 12 * 12 = 144
        Integer result = multiply.andThen(square).apply(3, 4);
        System.out.println(result); // 144
    }
}
```

----------

### 6. BiConsumer<T, U> - Two-Input Action Taker

**Memory Analogy:**  Think of a  **two-handed operation**  ğŸ¤²

-   Takes two inputs (T, U) â†’ Performs action â†’ Returns nothing

**Method Signature:**

java

```java
void accept(T t, U u)
```

**Basic Example:**

java

```java
import java.util.function.BiConsumer;

public class BiConsumerExample {
    public static void main(String[] args) {
        // Print key-value pair
        BiConsumer<String, Integer> printKeyValue = 
            (key, value) -> System.out.println(key + " = " + value);
        printKeyValue.accept("Age", 25); // Age = 25
        
        // Add to map
        Map<String, Integer> map = new HashMap<>();
        BiConsumer<String, Integer> putInMap = (k, v) -> map.put(k, v);
        putInMap.accept("One", 1);
        putInMap.accept("Two", 2);
        System.out.println(map); // {One=1, Two=2}
    }
}
```

**Real-World Example - Map Processing:**

java

```java
import java.util.*;
import java.util.function.BiConsumer;

public class BiConsumerMapExample {
    public static void main(String[] args) {
        Map<String, Integer> employeeSalaries = new HashMap<>();
        employeeSalaries.put("Alice", 50000);
        employeeSalaries.put("Bob", 60000);
        employeeSalaries.put("Charlie", 55000);
        
        // Print all entries
        BiConsumer<String, Integer> printSalary = 
            (name, salary) -> System.out.println(name + " earns $" + salary);
        employeeSalaries.forEach(printSalary);
        
        // Give 10% raise to all
        BiConsumer<String, Integer> giveRaise = 
            (name, salary) -> employeeSalaries.put(name, (int)(salary * 1.1));
        employeeSalaries.forEach(giveRaise);
        
        System.out.println("\nAfter raise:");
        employeeSalaries.forEach(printSalary);
    }
}
```

**BiConsumer Chaining:**

java

```java
public class BiConsumerChaining {
    public static void main(String[] args) {
        BiConsumer<String, Integer> print = 
            (name, age) -> System.out.println(name + " is " + age);
        BiConsumer<String, Integer> validate = 
            (name, age) -> {
                if (age < 0) System.out.println("Invalid age");
            };
        
        BiConsumer<String, Integer> combined = validate.andThen(print);
        combined.accept("John", 30);
    }
}
```

----------

### 7. BiPredicate<T, U> - Two-Input Validator

**Memory Analogy:**  Think of a  **security checkpoint with two IDs**  ğŸ”

-   Takes two inputs (T, U) â†’ Returns boolean
-   Validates relationship between two things

**Method Signature:**

java

```java
boolean test(T t, U u)
```

**Basic Example:**

java

```java
import java.util.function.BiPredicate;

public class BiPredicateExample {
    public static void main(String[] args) {
        // Check if first number is greater
        BiPredicate<Integer, Integer> isGreater = (a, b) -> a > b;
        System.out.println(isGreater.test(5, 3)); // true
        System.out.println(isGreater.test(2, 5)); // false
        
        // Check if string contains substring
        BiPredicate<String, String> contains = String::contains;
        System.out.println(contains.test("Hello World", "World")); // true
        
        // Check if sum is even
        BiPredicate<Integer, Integer> isSumEven = 
            (a, b) -> (a + b) % 2 == 0;
        System.out.println(isSumEven.test(3, 5)); // true
    }
}
```

**Advanced Example:**

java

```java
import java.util.function.BiPredicate;

public class BiPredicateAdvanced {
    public static void main(String[] args) {
        BiPredicate<String, Integer> isValidUser = 
            (name, age) -> name != null && !name.isEmpty() && age >= 18;
        
        System.out.println(isValidUser.test("John", 25)); // true
        System.out.println(isValidUser.test("", 20)); // false
        System.out.println(isValidUser.test("Mike", 15)); // false
        
        // Chaining BiPredicates
        BiPredicate<Integer, Integer> isSumPositive = (a, b) -> (a + b) > 0;
        BiPredicate<Integer, Integer> isSumLessThan100 = (a, b) -> (a + b) < 100;
        
        BiPredicate<Integer, Integer> validRange = 
            isSumPositive.and(isSumLessThan100);
        
        System.out.println(validRange.test(30, 40)); // true
        System.out.println(validRange.test(60, 50)); // false (sum = 110)
    }
}
```

**Real-World Example - Authorization:**

java

```java
import java.util.function.BiPredicate;

public class AuthorizationExample {
    public static void main(String[] args) {
        BiPredicate<User, String> hasPermission = 
            (user, permission) -> user.getPermissions().contains(permission);
        
        User admin = new User("admin", Arrays.asList("READ", "WRITE", "DELETE"));
        User guest = new User("guest", Arrays.asList("READ"));
        
        System.out.println(hasPermission.test(admin, "WRITE")); // true
        System.out.println(hasPermission.test(guest, "WRITE")); // false
    }
}

class User {
    private String name;
    private List<String> permissions;
    
    public User(String name, List<String> permissions) {
        this.name = name;
        this.permissions = permissions;
    }
    
    public List<String> getPermissions() { return permissions; }
}
```

----------

## ğŸ§  Memory Visualization & Analogies

### Visual Comparison Table

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Interface      â”‚  Input  â”‚  Output  â”‚  Analogy            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Function       â”‚  T      â”‚  R       â”‚  Vending Machine    â”‚
â”‚  Predicate      â”‚  T      â”‚  boolean â”‚  Bouncer/Guard      â”‚
â”‚  Consumer       â”‚  T      â”‚  void    â”‚  Black Hole         â”‚
â”‚  Supplier       â”‚  -      â”‚  T       â”‚  Factory            â”‚
â”‚  BiFunction     â”‚  T, U   â”‚  R       â”‚  Calculator         â”‚
â”‚  BiConsumer     â”‚  T, U   â”‚  void    â”‚  Two-Handed Work    â”‚
â”‚  BiPredicate    â”‚  T, U   â”‚  boolean â”‚  Security Checkpointâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Memory Trick - "FPCS" Mnemonic

**F**unction -  **F**ormat/Transform  
**P**redicate -  **P**ass/Fail Test  
**C**onsumer -  **C**onsume (no return)  
**S**upplier -  **S**upply (no input)

----------

## ğŸ“‹ All Java 8 Functional Interfaces

### Core Interfaces (Most Used)

java

```java
Function<T, R>          // T -> R
BiFunction<T, U, R>     // (T, U) -> R
Predicate<T>            // T -> boolean
BiPredicate<T, U>       // (T, U) -> boolean
Consumer<T>             // T -> void
BiConsumer<T, U>        // (T, U) -> void
Supplier<T>             // () -> T
```

### Primitive Specializations (Avoid Boxing/Unboxing)

**Int Variants:**

java

```java
IntFunction<R>          // int -> R
ToIntFunction<T>        // T -> int
IntUnaryOperator        // int -> int
IntBinaryOperator       // (int, int) -> int
IntPredicate            // int -> boolean
IntConsumer             // int -> void
IntSupplier             // () -> int
```

**Double Variants:**

java

```java
DoubleFunction<R>       // double -> R
ToDoubleFunction<T>     // T -> double
DoubleUnaryOperator     // double -> double
DoubleBinaryOperator    // (double, double) -> double
DoublePredicate         // double -> boolean
DoubleConsumer          // double -> void
DoubleSupplier          // () -> double
```

**Long Variants:**

java

```java
LongFunction<R>         // long -> R
ToLongFunction<T>       // T -> long
LongUnaryOperator       // long -> long
LongBinaryOperator      // (long, long) -> long
LongPredicate           // long -> boolean
LongConsumer            // long -> void
LongSupplier            // () -> long
```

### Operator Interfaces (Special Functions)

java

```java
UnaryOperator<T>        // T -> T (extends Function)
BinaryOperator<T>       // (T, T) -> T (extends BiFunction)
```

**Example:**

java

```java
UnaryOperator<Integer> square = x -> x * x;
BinaryOperator<Integer> multiply = (a, b) -> a * b;

System.out.println(square.apply(5));        // 25
System.out.println(multiply.apply(3, 4));   // 12
```

----------

## ğŸš€ Advanced Examples

### Example 1: Custom Functional Interface

java

```java
@FunctionalInterface
interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
    
    // Can have default methods
    default void log() {
        System.out.println("TriFunction executed");
    }
}

public class CustomFunctionalInterface {
    public static void main(String[] args) {
        // Calculate volume of a box
        TriFunction<Integer, Integer, Integer, Integer> volume = 
            (length, width, height) -> length * width * height;
        
        int result = volume.apply(5, 4, 3);
        System.out.println("Volume: " + result); // 60
        volume.log();
    }
}
```

### Example 2: Combining Multiple Interfaces

java

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

public class CombinedExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // Predicate: filter names starting with 'A'
        Predicate<String> startsWithA = name -> name.startsWith("A");
        
        // Function: convert to uppercase
        Function<String, String> toUpper = String::toUpperCase;
        
        // Consumer: print result
        Consumer<String> printer = System.out::println;
        
        // Combine all
        names.stream()
             .filter(startsWithA)
             .map(toUpper)
             .forEach(printer); // ALICE
    }
}
```

### Example 3: Strategy Pattern with Functional Interfaces

java

```java
import java.util.function.BiFunction;

public class CalculatorStrategy {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        System.out.println(calc.calculate(10, 5, (a, b) -> a + b));  // 15
        System.out.println(calc.calculate(10, 5, (a, b) -> a - b));  // 5
        System.out.println(calc.calculate(10, 5, (a, b) -> a * b));  // 50
        System.out.println(calc.calculate(10, 5, (a, b) -> a / b));  // 2
    }
}

class Calculator {
    public int calculate(int a, int b, BiFunction<Integer, Integer, Integer> operation) {
        return operation.apply(a, b);
    }
}
```

### Example 4: Exception Handling with Functional Interfaces

java

```java
import java.util.function.Function;

@FunctionalInterface
interface CheckedFunction<T, R> {
    R apply(T t) throws Exception;
    
    static <T, R> Function<T, R> wrap(CheckedFunction<T, R> func) {
        return t -> {
            try {
                return func.apply(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class ExceptionHandlingExample {
    public static void main(String[] args) {
        Function<String, Integer> safeParser = 
            CheckedFunction.wrap(Integer::parseInt);
        
        try {
            System.out.println(safeParser.apply("123"));  // 123
            System.out.println(safeParser.apply("abc"));  // RuntimeException
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```

----------

## ğŸ’¼ Interview Problems with Solutions

### Problem 1: Filter and Transform List

**Question:**  Given a list of employees, filter those with salary > 50000 and return their names in uppercase.

java

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

class Employee {
    private String name;
    private int salary;
    
    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public int getSalary() { return salary; }
}

public class Solution1 {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 60000),
            new Employee("Bob", 45000),
            new Employee("Charlie", 70000),
            new Employee("Diana", 40000)
        );
        
        // Using Predicate and Function
        Predicate<Employee> highSalary = e -> e.getSalary() > 50000;
        Function<Employee, String> toUpperName = e -> e.getName().toUpperCase();
        
        List<String> result = employees.stream()
            .filter(highSalary)
            .map(toUpperName)
            .collect(Collectors.toList());
        
        System.out.println(result); // [ALICE, CHARLIE]
    }
}
```

### Problem 2: Custom Validator Chain

**Question:**  Create a user registration validator using predicates.

java

```java
import java.util.function.Predicate;

class User {
    private String email;
    private String password;
    private int age;
    
    public User(String email, String password, int age) {
        this.email = email;
        this.password = password;
        this.age = age;
    }
    
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public int getAge() { return age; }
}

public class Solution2 {
    public static void main(String[] args) {
        Predicate<User> isEmailValid = 
            u -> u.getEmail() != null && u.getEmail().contains("@");
        Predicate<User> isPasswordStrong = 
            u -> u.getPassword() != null && u.getPassword().length() >= 8;
        Predicate<User> isAgeValid = 
            u -> u.getAge() >= 18;
        
        Predicate<User> isValidUser = 
            isEmailValid.and(isPasswordStrong).and(isAgeValid);
        
        User user1 = new User("test@example.com", "password123", 25);
        User user2 = new User("invalid", "123", 15);
        
        System.out.println(isValidUser.test(user1)); // true
        System.out.println(isValidUser.test(user2)); // false
        
        // With detailed validation
        if (!isEmailValid.test(user2)) {
            System.out.println("Invalid email");
        }
        if (!isPasswordStrong.test(user2)) {
            System.out.println("Weak password");
        }
        if (!isAgeValid.test(user2)) {
            System.out.println("Age must be 18+");
        }
    }
}
```

### Problem 3: Data Processing Pipeline

**Question:**  Process product data - calculate discount, apply tax, format price.

java

```java
import java.util.function.*;

class Product {
    private String name;
    private double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
}

public class Solution3 {
    public static void main(String[] args) {
        Product laptop = new Product("Laptop", 1000.0);
        
        // Function pipeline
        Function<Double, Double> applyDiscount = price -> price * 0.9; // 10% off
        Function<Double, Double> addTax = price -> price * 1.18; // 18% tax
        Function<Double, String> formatPrice = price -> String.format("$%.2f", price);
        
        // Combine functions
        Function<Double, String> priceProcessor = 
            applyDiscount.andThen(addTax).andThen(formatPrice);
        
        String finalPrice = priceProcessor.apply(laptop.getPrice());
        System.out.println("Original: $" + laptop.getPrice());
        System.out.println("Final: " + finalPrice); // $1062.00
        
        // Alternative using compose
        Function<Product, Double> getPrice = Product::getPrice;
        Function<Product, String> fullPipeline = 
            getPrice.andThen(priceProcessor);
        
        System.out.println(fullPipeline.apply(laptop)); // $1062.00
    }
}
```

### Problem 4: Lazy Evaluation with Supplier

**Question:**  Implement a lazy logger that only executes expensive operations when needed.

java

```java
import java.util.function.Supplier;

public class Solution4 {
    private static boolean isDebugEnabled = false;
    
    public static void log(String level, Supplier<String> messageSupplier) {
        if (level.equals("DEBUG") && !isDebugEnabled) {
            return; // Don't evaluate expensive message
        }
        System.out.println("[" + level + "] " + messageSupplier.get());
    }
    
    public static String expensiveOperation() {
        System.out.println("Executing expensive operation...");
        // Simulate expensive computation
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Expensive result";
    }
    
    public static void main(String[] args) {
        System.out.println("Debug is disabled:");
        // This won't execute expensiveOperation() because debug is disabled
        log("DEBUG", () -> expensiveOperation());
        
        System.out.println("\nInfo message:");
        // This will execute
        log("INFO", () -> "Simple info message");
        
        // Enable debug
        isDebugEnabled = true;
        System.out.println("\nDebug is now enabled:");
        log("DEBUG", () -> expensiveOperation());
    }
}

/* Output:
Debug is disabled:

Info message:
[INFO] Simple info message

Debug is now enabled:
Executing expensive operation...
[DEBUG] Expensive result
*/
```

### Problem 5: Map Operations with BiConsumer

**Question:**  Process a shopping cart - calculate totals and apply discounts.

java

```java
import java.util.*;
import java.util.function.*;

public class Solution5 {
    public static void main(String[] args) {
        Map<String, Double> cart = new HashMap<>();
        cart.put("Laptop", 1000.0);
        cart.put("Mouse", 25.0);
        cart.put("Keyboard", 75.0);
        
        // BiConsumer to print items
        BiConsumer<String, Double> printItem = 
            (item, price) -> System.out.println(item + ": $" + price);
        
        // BiConsumer to apply 10% discount
        BiConsumer<String, Double> applyDiscount = 
            (item, price) -> cart.put(item, price * 0.9);
        
        System.out.println("Original prices:");
        cart.forEach(printItem);
        
        // Apply discount
        new HashMap<>(cart).forEach(applyDiscount); // Use copy to avoid ConcurrentModificationException
        
        System.out.println("\nAfter 10% discount:");
        cart.forEach(printItem);
        
        // Calculate total
        double[] total = {0}; // Array to allow modification in lambda
        BiConsumer<String, Double> addToTotal = 
            (item, price) -> total[0] += price;
        cart.forEach(addToTotal);
        
        System.out.println("\nTotal: $" + String.format("%.2f", total[0]));
    }
}

/* Output:
Original prices:
Laptop: $1000.0
Mouse: $25.0
Keyboard: $75.0

After 10% discount:
Laptop: $900.0
Mouse: $22.5
Keyboard: $67.5

Total: $990.00
*/
```

### Problem 6: Complex Filtering with BiPredicate

**Question:**  Filter student records based on multiple criteria.

java

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

class Student {
    private String name;
    private int score;
    private String grade;
    
    public Student(String name, int score, String grade) {
        this.name = name;
        this.score = score;
        this.grade = grade;
    }
    
    public String getName() { return name; }
    public int getScore() { return score; }
    public String getGrade() { return grade; }
    
    @Override
    public String toString() {
        return name + " (Score: " + score + ", Grade: " + grade + ")";
    }
}

public class Solution6 {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Alice", 85, "10th"),
            new Student("Bob", 92, "10th"),
            new Student("Charlie", 78, "9th"),
            new Student("Diana", 95, "10th"),
            new Student("Eve", 88, "9th")
        );
        
        // BiPredicate to check score and grade
        BiPredicate<Integer, String> isEligibleForAward = 
            (score, grade) -> score >= 90 && grade.equals("10th");
        
        // Find eligible students
        List<Student> awardWinners = students.stream()
            .filter(s -> isEligibleForAward.test(s.getScore(), s.getGrade()))
            .collect(Collectors.toList());
        
        System.out.println("Award Winners (Score >= 90 and Grade 10th):");
        awardWinners.forEach(System.out::println);
        
        // Alternative: using BiPredicate with Student objects
        BiPredicate<Student, Integer> hasMinScore = 
            (student, minScore) -> student.getScore() >= minScore;
        
        System.out.println("\nStudents with score >= 85:");
        students.stream()
            .filter(s -> hasMinScore.test(s, 85))
            .forEach(System.out::println);
    }
}

/* Output:
Award Winners (Score >= 90 and Grade 10th):
Bob (Score: 92, Grade: 10th)
Diana (Score: 95, Grade: 10th)

Students with score >= 85:
Alice (Score: 85, Grade: 10th)
Bob (Score: 92, Grade: 10th)
Diana (Score: 95, Grade: 10th)
Eve (Score: 88, Grade: 9th)
*/
```

### Problem 7: Function Composition

**Question:**  Create a text processing pipeline: trim â†’ lowercase â†’ remove spaces â†’ capitalize first letter.

java

```java
import java.util.function.Function;

public class Solution7 {
    public static void main(String[] args) {
        // Individual functions
        Function<String, String> trim = String::trim;
        Function<String, String> toLowerCase = String::toLowerCase;
        Function<String, String> removeSpaces = s -> s.replaceAll("\\s+", "");
        Function<String, String> capitalizeFirst = s -> 
            s.isEmpty() ? s : Character.toUpperCase(s.charAt(0)) + s.substring(1);
        
        // Compose pipeline
        Function<String, String> textProcessor = trim
            .andThen(toLowerCase)
            .andThen(removeSpaces)
            .andThen(capitalizeFirst);
        
        String input = "  Hello World From Java  ";
        String result = textProcessor.apply(input);
        
        System.out.println("Input: '" + input + "'");
        System.out.println("Output: '" + result + "'"); // Helloworldfromjava
        
        // Using compose (reverse order)
        Function<String, String> reverseProcessor = capitalizeFirst
            .compose(removeSpaces)
            .compose(toLowerCase)
            .compose(trim);
        
        String result2 = reverseProcessor.apply(input);
        System.out.println("Reverse compose: '" + result2 + "'");
    }
}
```

### Problem 8: Advanced BiFunction - Matrix Operations

**Question:**  Implement matrix operations using BiFunction.

java

```java
import java.util.function.BiFunction;

public class Solution8 {
    public static void main(String[] args) {
        int[][] matrix1 = {{1, 2}, {3, 4}};
        int[][] matrix2 = {{5, 6}, {7, 8}};
        
        // BiFunction for matrix addition
        BiFunction<int[][], int[][], int[][]> addMatrices = (m1, m2) -> {
            int[][] result = new int[m1.length][m1[0].length];
            for (int i = 0; i < m1.length; i++) {
                for (int j = 0; j < m1[0].length; j++) {
                    result[i][j] = m1[i][j] + m2[i][j];
                }
            }
            return result;
        };
        
        // BiFunction for matrix multiplication
        BiFunction<int[][], int[][], int[][]> multiplyMatrices = (m1, m2) -> {
            int[][] result = new int[m1.length][m2[0].length];
            for (int i = 0; i < m1.length; i++) {
                for (int j = 0; j < m2[0].length; j++) {
                    for (int k = 0; k < m1[0].length; k++) {
                        result[i][j] += m1[i][k] * m2[k][j];
                    }
                }
            }
            return result;
        };
        
        // Test addition
        System.out.println("Matrix Addition:");
        int[][] sum = addMatrices.apply(matrix1, matrix2);
        printMatrix(sum);
        
        // Test multiplication
        System.out.println("\nMatrix Multiplication:");
        int[][] product = multiplyMatrices.apply(matrix1, matrix2);
        printMatrix(product);
    }
    
    static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }
}

/* Output:
Matrix Addition:
6 8 
10 12 

Matrix Multiplication:
19 22 
43 50 
*/
```

### Problem 9: Factory Pattern with Supplier

**Question:**  Implement object factory using Supplier.

java

```java
import java.util.*;
import java.util.function.Supplier;

interface Animal {
    void makeSound();
}

class Dog implements Animal {
    public void makeSound() { System.out.println("Woof!"); }
}

class Cat implements Animal {
    public void makeSound() { System.out.println("Meow!"); }
}

class Bird implements Animal {
    public void makeSound() { System.out.println("Chirp!"); }
}

public class Solution9 {
    private static Map<String, Supplier<Animal>> animalFactory = new HashMap<>();
    
    static {
        animalFactory.put("dog", Dog::new);
        animalFactory.put("cat", Cat::new);
        animalFactory.put("bird", Bird::new);
    }
    
    public static Animal createAnimal(String type) {
        Supplier<Animal> supplier = animalFactory.get(type.toLowerCase());
        if (supplier == null) {
            throw new IllegalArgumentException("Unknown animal type: " + type);
        }
        return supplier.get();
    }
    
    public static void main(String[] args) {
        Animal dog = createAnimal("dog");
        Animal cat = createAnimal("cat");
        Animal bird = createAnimal("bird");
        
        dog.makeSound();  // Woof!
        cat.makeSound();  // Meow!
        bird.makeSound(); // Chirp!
        
        // Lazy list creation
        Supplier<List<String>> listSupplier = ArrayList::new;
        List<String> list = listSupplier.get();
        list.add("Item 1");
        System.out.println(list);
    }
}
```

### Problem 10: Real-World Scenario - Order Processing

**Question:**  Build a complete order processing system using multiple functional interfaces.

java

```java
import java.util.*;
import java.util.function.*;

class Order {
    private String id;
    private double amount;
    private String status;
    private String customerType; // "REGULAR", "PREMIUM", "VIP"
    
    public Order(String id, double amount, String customerType) {
        this.id = id;
        this.amount = amount;
        this.customerType = customerType;
        this.status = "PENDING";
    }
    
    // Getters and setters
    public String getId() { return id; }
    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public String getCustomerType() { return customerType; }
    
    @Override
    public String toString() {
        return String.format("Order[id=%s, amount=$%.2f, type=%s, status=%s]", 
            id, amount, customerType, status);
    }
}

public class Solution10 {
    public static void main(String[] args) {
        List<Order> orders = Arrays.asList(
            new Order("ORD001", 150.0, "REGULAR"),
            new Order("ORD002", 500.0, "PREMIUM"),
            new Order("ORD003", 1200.0, "VIP"),
            new Order("ORD004", 80.0, "REGULAR"),
            new Order("ORD005", 2000.0, "VIP")
        );
        
        // Predicate: Validate order
        Predicate<Order> isValidOrder = order -> 
            order.getAmount() > 0 && order.getAmount() < 10000;
        
        // Function: Calculate discount based on customer type
        Function<Order, Double> calculateDiscount = order -> {
            switch (order.getCustomerType()) {
                case "VIP": return order.getAmount() * 0.20;
                case "PREMIUM": return order.getAmount() * 0.10;
                default: return 0.0;
            }
        };
        
        // BiFunction: Apply discount
        BiFunction<Order, Double, Order> applyDiscount = (order, discount) -> {
            order.setAmount(order.getAmount() - discount);
            return order;
        };
        
        // Consumer: Process order (mark as processed)
        Consumer<Order> processOrder = order -> {
            order.setStatus("PROCESSED");
            System.out.println("Processing: " + order);
        };
        
        // BiConsumer: Send notification
        BiConsumer<Order, String> sendNotification = (order, message) -> 
            System.out.println("Notification to " + order.getId() + ": " + message);
        
        // Supplier: Generate order report
        Supplier<String> generateReport = () -> 
            "Report generated at: " + new Date();
        
        System.out.println("=== Order Processing System ===\n");
        
        // Process all orders
        orders.stream()
            .filter(isValidOrder)
            .forEach(order -> {
                double discount = calculateDiscount.apply(order);
                if (discount > 0) {
                    System.out.println("Applying discount of $" + 
                        String.format("%.2f", discount) + " to " + order.getId());
                    applyDiscount.apply(order, discount);
                }
                processOrder.accept(order);
                sendNotification.accept(order, "Your order has been processed!");
                System.out.println();
            });
        
        System.out.println(generateReport.get());
        
        // Calculate total revenue
        double totalRevenue = orders.stream()
            .filter(o -> o.getStatus().equals("PROCESSED"))
            .mapToDouble(Order::getAmount)
            .sum();
        
        System.out.println("\nTotal Revenue: $" + String.format("%.2f", totalRevenue));
    }
}

/* Output:
=== Order Processing System ===

Processing: Order[id=ORD001, amount=$150.00, type=REGULAR, status=PROCESSED]
Notification to ORD001: Your order has been processed!

Applying discount of $50.00 to ORD002
Processing: Order[id=ORD002, amount=$450.00, type=PREMIUM, status=PROCESSED]
Notification to ORD002: Your order has been processed!

Applying discount of $240.00 to ORD003
Processing: Order[id=ORD003, amount=$960.00, type=VIP, status=PROCESSED]
Notification to ORD003: Your order has been processed!

Processing: Order[id=ORD004, amount=$80.00, type=REGULAR, status=PROCESSED]
Notification to ORD004: Your order has been processed!

Applying discount of $400.00 to ORD005
Processing: Order[id=ORD005, amount=$1600.00, type=VIP, status=PROCESSED]
Notification to ORD005: Your order has been processed!

Report generated at: [Current Date]

Total Revenue: $3240.00
*/
```

----------

## ğŸ“ Interview Tips & Best Practices

### 1.  **When to Use Which Interface?**

java

```java
// Use Function when you transform data
Function<String, Integer> length = String::length;

// Use Predicate when you test/validate
Predicate<String> isEmpty = String::isEmpty;

// Use Consumer when you perform actions (side effects)
Consumer<String> print = System.out::println;

// Use Supplier when you generate/provide data
Supplier<Double> random = Math::random;
```

### 2.  **Avoid Common Mistakes**

java

```java
// âŒ Wrong: Creating new lambdas unnecessarily
list.forEach(x -> System.out.println(x));

// âœ… Correct: Use method reference
list.forEach(System.out::println);

// âŒ Wrong: Not handling null
Function<String, Integer> bad = s -> s.length(); // NullPointerException

// âœ… Correct: Handle null
Function<String, Integer> good = s -> s != null ? s.length() : 0;
```

### 3.  **Performance Considerations**

java

```java
// For primitive types, use specialized interfaces to avoid boxing
IntPredicate isEven = n -> n % 2 == 0; // Better performance
Predicate<Integer> isEvenBoxed = n -> n % 2 == 0; // Boxing overhead
```

### 4.  **Composability is Key**

java

```java
// Build complex logic from simple pieces
Predicate<String> isLong = s -> s.length() > 10;
Predicate<String> startsWithA = s -> s.startsWith("A");
Predicate<String> complex = isLong.and(startsWithA).negate();
```

----------

## ğŸ“ Summary Cheat Sheet

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  FUNCTIONAL INTERFACES                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Function<T,R>    â”‚ T â†’ R          â”‚ apply()              â•‘
â•‘ BiFunction<T,U,R>â”‚ (T,U) â†’ R      â”‚ apply()              â•‘
â•‘ Predicate<T>     â”‚ T â†’ boolean    â”‚ test()               â•‘
â•‘ BiPredicate<T,U> â”‚ (T,U) â†’ booleanâ”‚ test()               â•‘
â•‘ Consumer<T>      â”‚ T â†’ void       â”‚ accept()             â•‘
â•‘ BiConsumer<T,U>  â”‚ (T,U) â†’ void   â”‚ accept()             â•‘
â•‘ Supplier<T>      â”‚ () â†’ T         â”‚ get()                â•‘
â•‘ UnaryOperator<T> â”‚ T â†’ T          â”‚ apply()              â•‘
â•‘ BinaryOperator<T>â”‚ (T,T) â†’ T      â”‚ apply()              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY METHODS:
- Function: andThen(), compose()
- Predicate: and(), or(), negate()
- Consumer: andThen()
- Operator: extends Function/BiFunction

REMEMBER: Use primitive variants (IntPredicate, DoubleFunction, 
etc.) for better performance with primitives!
```

----------

## ğŸš€ Next Steps

1.  **Practice**: Implement these examples and modify them
2.  **Explore**: Look at Java Stream API which heavily uses these interfaces
3.  **Build**: Create your own functional interfaces for domain-specific needs
4.  **Refactor**: Convert existing code to use functional interfaces
5.  **Master**: Learn about method references and lambda best practices

Happy Learning! ğŸ‰
