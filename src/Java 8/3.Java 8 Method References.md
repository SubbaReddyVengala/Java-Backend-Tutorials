# Java 8 Method References - Complete Tutorial

## ğŸ“š Table of Contents

1.  Introduction
2.  Theory & Concepts
3.  Types of Method References
4.  Memory Visualization
5.  Simple Examples
6.  Interview Problems with Solutions

----------

## 1. Introduction

**Method References**  are a shorthand notation of a lambda expression to call a method. They make your code more readable and concise.

### ğŸ¯ Analogy

Think of method references as  **speed dial on your phone**:

-   Lambda Expression: Dialing the full phone number every time â†’  `(x) -> System.out.println(x)`
-   Method Reference: Using speed dial â†’  `System.out::println`

Both achieve the same result, but method references are shorter and cleaner!

----------

## 2. Theory & Concepts

### What are Method References?

Method references are compact, easy-to-read lambda expressions that refer to methods by their names using the  `::`  (double colon) operator.

**Syntax:**

```
ClassName::methodName
```

### When to Use?

Use method references when a lambda expression  **only calls an existing method**.

**Lambda Expression:**

java

```java
(args) -> Class.method(args)
```

**Method Reference:**

java

```java
Class::method
```

### Key Points

-   Introduced in Java 8
-   Uses  `::`  operator (called method reference operator)
-   Works with functional interfaces
-   More readable than lambda expressions
-   No performance difference from lambdas

----------

## 3. Types of Method References
<img width="871" height="502" alt="image" src="https://github.com/user-attachments/assets/5aa10fb3-e8f1-4572-bf04-4666051672d0" />




There are  **4 types**  of method references:

### 3.1 Reference to a Static Method

**Syntax:**  `ClassName::staticMethodName`

### Example 1ï¸âƒ£ â€” Static Method Reference

**Without Method Reference:**
``` java
Function<Integer, String> func = (num) -> String.valueOf(num);` 
```
**With Method Reference:**
``` java
Function<Integer, String> func = String::valueOf;` 
```
â¡ï¸ Both call the same method â€” `String.valueOf(num)` â€” but the latter is shorter and clearer.
**Example:**

java

```java
// Lambda Expression
Function<String, Integer> lambda = (String s) -> Integer.parseInt(s);

// Method Reference
Function<String, Integer> methodRef = Integer::parseInt;

// Usage
int num = methodRef.apply("123"); // Returns 123
```

**Real-World Example:**

java

```java
List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");

// Using lambda
numbers.stream()
       .map(s -> Integer.parseInt(s))
       .forEach(System.out::println);

// Using method reference (cleaner!)
numbers.stream()
       .map(Integer::parseInt)
       .forEach(System.out::println);
```

----------

### 3.2 Reference to an Instance Method of a Particular Object

**Syntax:**  `objectReference::instanceMethodName`
### Example 2ï¸âƒ£ â€” Instance Method of a Particular Object

**Without Method Reference:**
```java
Consumer<String> printer = (msg) -> System.out.println(msg);` 
```
**With Method Reference:**

`Consumer<String> printer = System.out::println;` 

**Explanation:**  
Here, `System.out` is an object (PrintStream), and we are referencing its method `println()`.
**Example:**

java

```java
class Printer {
    public void print(String message) {
        System.out.println("Printing: " + message);
    }
}

// Lambda Expression
Printer printer = new Printer();
Consumer<String> lambda = (s) -> printer.print(s);

// Method Reference
Consumer<String> methodRef = printer::print;

// Usage
methodRef.accept("Hello World"); // Prints: Printing: Hello World
```

**Real-World Example:**

java

```java
List<String> messages = Arrays.asList("Error", "Warning", "Info");

Logger logger = new Logger();

// Using lambda
messages.forEach(msg -> logger.log(msg));

// Using method reference
messages.forEach(logger::log);
```

----------

### 3.3 Reference to an Instance Method of an Arbitrary Object

**Syntax:**  `ClassName::instanceMethodName`

This is the  **trickiest**  type! The first parameter becomes the object on which the method is called.

**Without Method Reference:**
``` java
List<String> names = Arrays.asList("Subbu", "Reddy", "Java");
names.forEach(name -> System.out.println(name.toUpperCase()));
```
**With Method Reference:**
``` java
names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);` 
```
â¡ï¸ Each element in the stream (String) calls its `toUpperCase()` method.

**Example:**

java

```java
// Lambda Expression
BiPredicate<String, String> lambda = (s1, s2) -> s1.equals(s2);

// Method Reference
BiPredicate<String, String> methodRef = String::equals;

// Usage
boolean result = methodRef.test("Hello", "Hello"); // true
```

**Memory Visualization:**

```
Lambda: (s1, s2) -> s1.equals(s2)
                    â†“
Method Ref: String::equals
            
How it works:
- First parameter (s1) becomes the object calling the method
- Remaining parameters (s2) become arguments to the method
```

**Real-World Example:**

java

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// Using lambda
words.stream()
     .map(s -> s.toUpperCase())
     .forEach(System.out::println);

// Using method reference
words.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

----------

### 3.4 Reference to a Constructor

**Syntax:**  `ClassName::new`
**Without Method Reference:**
``` java
Supplier<List<String>> supplier = () -> new  ArrayList<>();` 
```
**With Method Reference:**
``` java
Supplier<List<String>> supplier = ArrayList::new;` 
```
â¡ï¸ Both create new `ArrayList` instances.

**Example:**

java

```java
// Lambda Expression
Supplier<List<String>> lambda = () -> new ArrayList<>();

// Method Reference
Supplier<List<String>> methodRef = ArrayList::new;

// Usage
List<String> list = methodRef.get();
```

**With Parameters:**

java

```java
// Lambda Expression
Function<String, StringBuilder> lambda = (s) -> new StringBuilder(s);

// Method Reference
Function<String, StringBuilder> methodRef = StringBuilder::new;

// Usage
StringBuilder sb = methodRef.apply("Hello");
```

**Real-World Example:**

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Using lambda
List<Person> people = names.stream()
                           .map(name -> new Person(name))
                           .collect(Collectors.toList());

// Using constructor reference
List<Person> people = names.stream()
                           .map(Person::new)
                           .collect(Collectors.toList());
```

----------

## 4. Memory Visualization
Letâ€™s visualize it step-by-step ğŸ§ 

### Example: `System.out::println`

**Memory Flow:**
<img width="657" height="447" alt="image" src="https://github.com/user-attachments/assets/39b8bfde-1ccd-4766-94aa-4e5cfa0741c0" />



There are  **4 types**  of method references:

### 3.1 Reference to a Static Method

**Syntax:**  `ClassName::staticMethodName`

### Example 1ï¸âƒ£ â€” Static Method Reference

**Without Method Reference:**
``` java
Function<Integer, String> func = (num) -> String.valueOf(num);` 
```
**With Method Reference:**
``` java
Function<Integer, String> func = String::valueOf;` 
```
â¡ï¸ Both call the same method â€” `String.valueOf(num)` â€” but the latter is shorter and clearer.
**Example:**

java

```java
// Lambda Expression
Function<String, Integer> lambda = (String s) -> Integer.parseInt(s);

// Method Reference
Function<String, Integer> methodRef = Integer::parseInt;

// Usage
int num = methodRef.apply("123"); // Returns 123
```

**Real-World Example:**

java

```java
List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");

// Using lambda
numbers.stream()
       .map(s -> Integer.parseInt(s))
       .forEach(System.out::println);

// Using method reference (cleaner!)
numbers.stream()
       .map(Integer::parseInt)
       .forEach(System.out::println);
```

----------

### 3.2 Reference to an Instance Method of a Particular Object

**Syntax:**  `objectReference::instanceMethodName`
### Example 2ï¸âƒ£ â€” Instance Method of a Particular Object

**Without Method Reference:**
```java
Consumer<String> printer = (msg) -> System.out.println(msg);` 
```
**With Method Reference:**

`Consumer<String> printer = System.out::println;` 

**Explanation:**  
Here, `System.out` is an object (PrintStream), and we are referencing its method `println()`.
**Example:**

java

```java
class Printer {
    public void print(String message) {
        System.out.println("Printing: " + message);
    }
}

// Lambda Expression
Printer printer = new Printer();
Consumer<String> lambda = (s) -> printer.print(s);

// Method Reference
Consumer<String> methodRef = printer::print;

// Usage
methodRef.accept("Hello World"); // Prints: Printing: Hello World
```

**Real-World Example:**

java

```java
List<String> messages = Arrays.asList("Error", "Warning", "Info");

Logger logger = new Logger();

// Using lambda
messages.forEach(msg -> logger.log(msg));

// Using method reference
messages.forEach(logger::log);
```

----------

### 3.3 Reference to an Instance Method of an Arbitrary Object

**Syntax:**  `ClassName::instanceMethodName`

This is the  **trickiest**  type! The first parameter becomes the object on which the method is called.

**Without Method Reference:**
``` java
List<String> names = Arrays.asList("Subbu", "Reddy", "Java");
names.forEach(name -> System.out.println(name.toUpperCase()));
```
**With Method Reference:**
``` java
names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);` 
```
â¡ï¸ Each element in the stream (String) calls its `toUpperCase()` method.

**Example:**

java

```java
// Lambda Expression
BiPredicate<String, String> lambda = (s1, s2) -> s1.equals(s2);

// Method Reference
BiPredicate<String, String> methodRef = String::equals;

// Usage
boolean result = methodRef.test("Hello", "Hello"); // true
```

**Memory Visualization:**

```
Lambda: (s1, s2) -> s1.equals(s2)
                    â†“
Method Ref: String::equals
            
How it works:
- First parameter (s1) becomes the object calling the method
- Remaining parameters (s2) become arguments to the method
```

**Real-World Example:**

java

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// Using lambda
words.stream()
     .map(s -> s.toUpperCase())
     .forEach(System.out::println);

// Using method reference
words.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

----------

### 3.4 Reference to a Constructor

**Syntax:**  `ClassName::new`
**Without Method Reference:**
``` java
Supplier<List<String>> supplier = () -> new  ArrayList<>();` 
```
**With Method Reference:**
``` java
Supplier<List<String>> supplier = ArrayList::new;` 
```
â¡ï¸ Both create new `ArrayList` instances.

**Example:**

java

```java
// Lambda Expression
Supplier<List<String>> lambda = () -> new ArrayList<>();

// Method Reference
Supplier<List<String>> methodRef = ArrayList::new;

// Usage
List<String> list = methodRef.get();
```

**With Parameters:**

java

```java
// Lambda Expression
Function<String, StringBuilder> lambda = (s) -> new StringBuilder(s);

// Method Reference
Function<String, StringBuilder> methodRef = StringBuilder::new;

// Usage
StringBuilder sb = methodRef.apply("Hello");
```

**Real-World Example:**

java

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Using lambda
List<Person> people = names.stream()
                           .map(name -> new Person(name))
                           .collect(Collectors.toList());

// Using constructor reference
List<Person> people = names.stream()
                           .map(Person::new)
                           .collect(Collectors.toList());
```

----------

## 4. Memory Visualization
Letâ€™s visualize it step-by-step ğŸ§ 

### Example: `System.out::println`

**Memory Flow:**


ğŸ“Œ The lambda is **not creating new code** â€” it just **delegates** to the existing method in memory.
### How Method References Work in Memory

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAMBDA EXPRESSION                                      â”‚
â”‚  (x) -> System.out.println(x)                          â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Lambda     â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Anonymous      â”‚         â”‚
â”‚  â”‚   Object     â”‚         â”‚  Method Body    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  METHOD REFERENCE                                       â”‚
â”‚  System.out::println                                    â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Method     â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Existing       â”‚         â”‚
â”‚  â”‚   Reference  â”‚         â”‚  Method         â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Memory Efficiency: Both occupy similar memory at runtime,
but method references reuse existing methods!
```

### Comparison Table
<img width="811" height="243" alt="image" src="https://github.com/user-attachments/assets/54616854-1a6d-4f1e-b933-8008b00bf912" />
## 5. Simple Examples

### Example 1: Sorting with Method References

java

```java
import java.util.*;

public class SortingExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Banana", "Apple", "Cherry", "Date");
        
        // Using lambda
        fruits.sort((s1, s2) -> s1.compareTo(s2));
        
        // Using method reference (cleaner!)
        fruits.sort(String::compareTo);
        
        System.out.println(fruits); // [Apple, Banana, Cherry, Date]
    }
}
```

### Example 2: Filtering and Processing

java

```java
import java.util.*;
import java.util.stream.*;

public class FilterExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "", "Charlie", "");
        
        // Filter empty strings and convert to uppercase
        List<String> result = names.stream()
                                   .filter(s -> !s.isEmpty())  // Lambda
                                   .map(String::toUpperCase)    // Method reference
                                   .collect(Collectors.toList());
        
        System.out.println(result); // [ALICE, BOB, CHARLIE]
    }
}
```

### Example 3: Working with Objects

java

```java
class Employee {
    private String name;
    private int salary;
    
    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public int getSalary() { return salary; }
    
    @Override
    public String toString() {
        return name + ": $" + salary;
    }
}

public class EmployeeExample {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 50000),
            new Employee("Bob", 60000),
            new Employee("Charlie", 55000)
        );
        
        // Get all employee names using method reference
        List<String> names = employees.stream()
                                      .map(Employee::getName)
                                      .collect(Collectors.toList());
        
        System.out.println(names); // [Alice, Bob, Charlie]
        
        // Sort by salary
        employees.sort(Comparator.comparing(Employee::getSalary));
        
        employees.forEach(System.out::println);
        // Alice: $50000
        // Charlie: $55000
        // Bob: $60000
    }
}
```

----------

## 6. Interview Problems with Solutions

### Problem 1: Convert Lambda to Method Reference

**Question:**  Convert the following lambda expressions to method references:

java

```java
// a) List<String> -> print each element
list.forEach(s -> System.out.println(s));

// b) List<Integer> -> convert to binary string
list.stream().map(i -> Integer.toBinaryString(i));

// c) List<String> -> check if empty
list.stream().filter(s -> s.isEmpty());

// d) Create ArrayList
Supplier<List<String>> supplier = () -> new ArrayList<>();
```

**Answer:**

java

```java
// a) Reference to instance method of particular object
list.forEach(System.out::println);

// b) Reference to static method
list.stream().map(Integer::toBinaryString);

// c) Reference to instance method of arbitrary object
list.stream().filter(String::isEmpty);

// d) Reference to constructor
Supplier<List<String>> supplier = ArrayList::new;
```

----------

### Problem 2: Identify Method Reference Type

**Question:**  Identify the type of each method reference:

java

```java
// a) Integer::parseInt
// b) System.out::println
// c) String::toLowerCase
// d) ArrayList::new
```

**Answer:**

java

```java
// a) Static method reference
// b) Instance method reference of a particular object
// c) Instance method reference of an arbitrary object
// d) Constructor reference
```

----------

### Problem 3: Remove Duplicates and Sort

**Question:**  Given a list of strings with duplicates, remove duplicates, convert to uppercase, and sort them using method references.

**Solution:**

java

```java
import java.util.*;
import java.util.stream.*;

public class RemoveDuplicates {
    public static void main(String[] args) {
        List<String> items = Arrays.asList("apple", "banana", "Apple", 
                                           "cherry", "banana", "date");
        
        List<String> result = items.stream()
                                   .map(String::toLowerCase)      // Normalize
                                   .distinct()                    // Remove duplicates
                                   .map(String::toUpperCase)      // Convert to uppercase
                                   .sorted(String::compareTo)      // Sort
                                   .collect(Collectors.toList());
        
        result.forEach(System.out::println);
        // Output: APPLE, BANANA, CHERRY, DATE
    }
}
```

----------

### Problem 4: Custom Object Processing

**Question:**  Given a list of Person objects, extract all email addresses, convert them to lowercase, and collect them into a Set.

**Solution:**

java

```java
import java.util.*;
import java.util.stream.*;

class Person {
    private String name;
    private String email;
    
    public Person(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    public String getEmail() { return email; }
}

public class EmailExtractor {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", "ALICE@EXAMPLE.COM"),
            new Person("Bob", "bob@example.com"),
            new Person("Charlie", "CHARLIE@EXAMPLE.COM")
        );
        
        Set<String> emails = people.stream()
                                   .map(Person::getEmail)           // Method reference
                                   .map(String::toLowerCase)        // Method reference
                                   .collect(Collectors.toSet());
        
        emails.forEach(System.out::println);
        // alice@example.com
        // bob@example.com
        // charlie@example.com
    }
}
```

----------

### Problem 5: When NOT to Use Method References

**Question:**  Which of the following lambda expressions CANNOT be converted to method references?

java

```java
// a) x -> x * 2
// b) (x, y) -> x + y
// c) s -> s.length()
// d) () -> new Random().nextInt()
```

**Answer:**

java

```java
// a) CANNOT - custom logic, not calling an existing method directly
// b) CANNOT - custom logic using an operator
// c) CAN - String::length (instance method of arbitrary object)
// d) CANNOT - creating object and calling method in sequence
```

**Rule of Thumb:**  Method references work only when you're  **directly calling an existing method**  without any additional logic.

----------

### Problem 6: Complex Scenario

**Question:**  Create a program that reads a list of transactions, filters out negative amounts, groups them by category, and calculates the sum for each category using method references wherever possible.

**Solution:**

java

```java
import java.util.*;
import java.util.stream.*;

class Transaction {
    private String category;
    private double amount;
    
    public Transaction(String category, double amount) {
        this.category = category;
        this.amount = amount;
    }
    
    public String getCategory() { return category; }
    public double getAmount() { return amount; }
}

public class TransactionAnalyzer {
    public static void main(String[] args) {
        List<Transaction> transactions = Arrays.asList(
            new Transaction("Food", 50.0),
            new Transaction("Transport", -20.0),
            new Transaction("Food", 30.0),
            new Transaction("Entertainment", 100.0),
            new Transaction("Transport", 25.0),
            new Transaction("Food", -10.0)
        );
        
        Map<String, Double> categorySum = transactions.stream()
            .filter(t -> t.getAmount() > 0)                    // Lambda (has logic)
            .collect(Collectors.groupingBy(
                Transaction::getCategory,                       // Method reference
                Collectors.summingDouble(Transaction::getAmount) // Method reference
            ));
        
        categorySum.forEach((category, sum) -> 
            System.out.println(category + ": $" + sum));
        
        // Output:
        // Food: $80.0
        // Transport: $25.0
        // Entertainment: $100.0
    }
}
```

----------

## ğŸ“ Quick Reference Card

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  TYPE                    â”‚  SYNTAX           â”‚  EXAMPLE    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Static Method           â”‚  Class::method    â”‚  Math::abs  â•‘
â•‘  Instance (Particular)   â”‚  obj::method      â”‚  str::trim  â•‘
â•‘  Instance (Arbitrary)    â”‚  Class::method    â”‚  String::length â•‘
â•‘  Constructor             â”‚  Class::new       â”‚  ArrayList::new â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

----------
## ğŸ§ª  Practical Examples

### Example 1: Sorting
``` java
List<String> list = Arrays.asList("Banana", "Apple", "Mango"); // Lambda 
Collections.sort(list, (a, b) -> a.compareToIgnoreCase(b)); // Method Reference 
Collections.sort(list, String::compareToIgnoreCase);` 
```
----------

### Example 2: Stream API + Method References
``` java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

numbers.stream()
       .map(String::valueOf)
       .forEach(System.out::println);` 
``` 
----------

### Example 3: Constructor Reference with Stream
``` java
Stream<String> stream = Stream.of("Java", "Spring", "AWS");

List<String> list = stream.collect(Collectors.toCollection(ArrayList::new));` 
```
----------

## ğŸ’¼ 8. Real-World Example (Banking Domain)
``` java
List<Transaction> transactions = getTransactions(); // Lambda transactions.forEach(tx -> logger.info(tx::toString)); // Method Reference transactions.forEach(System.out::println); // OR Mapping IDs List<Integer> ids = transactions.stream()
                                .map(Transaction::getId)
                                .collect(Collectors.toList());` 
``` 
**Advantage:** Cleaner pipeline + better readability.

----------

## ğŸ¯ 9. Interview Questions and Answers

----------

### ğŸ§© Q1. What is a method reference in Java 8?

**Answer:**  
Itâ€™s a shorthand notation of a lambda expression that directly calls an existing method using `::` operator.

----------

### ğŸ§© Q2. What are the different types of method references?

**Answer:**

1.  Static method reference â†’ `ClassName::staticMethod`
    
2.  Instance method of a particular object â†’ `instance::method`
    
3.  Instance method of arbitrary object â†’ `ClassName::instanceMethod`
    
4.  Constructor reference â†’ `ClassName::new`
    

----------

### ğŸ§© Q3. How is `System.out::println` represented internally?

**Answer:**  
Itâ€™s equivalent to a lambda:

`x -> System.out.println(x)` 

It refers to the `println` method of the `System.out` object.

----------

### ğŸ§© Q4. Can method references be used for overloaded methods?

**Answer:**  
âœ… Yes, but the compiler should be able to **infer the correct method** from context.  
Otherwise, youâ€™ll get an ambiguous method reference error.

----------

### ğŸ§© Q5. What happens if method reference doesnâ€™t match functional interface signature?

**Answer:**  
âŒ Compile-time error.  
Because the referenced method must match the **abstract method** of the functional interface (parameter types and return type).

----------

### ğŸ§© Q6. When should you prefer method reference over lambda?

**Answer:**  
When your lambda only **calls one existing method**.  
For example:

`list.forEach(System.out::println);` 

is cleaner than

`list.forEach(x -> System.out.println(x));` 

----------

## ğŸ§  10. Memory Trick for Remembering
<img width="836" height="386" alt="image" src="https://github.com/user-attachments/assets/c5209c93-b037-4ec0-b43d-98b45ef9b17e" />



----------

## ğŸ§® 11. Coding Practice Problems

----------

### ğŸ”¹ Problem 1 â€” Convert Strings to Uppercase

**Input:**
``` java
List<String> list = Arrays.asList("subbu", "reddy", "java");` 
```
**Output using Method Reference:**
``` java
list.stream().map(String::toUpperCase).forEach(System.out::println);` 
```
----------

### ğŸ”¹ Problem 2 â€” Sort Integers in Descending Order
``` java
List<Integer> nums = Arrays.asList(10, 5, 2, 20);
nums.sort(Integer::compare);
Collections.reverse(nums);
nums.forEach(System.out::println);` 
```
----------

### ğŸ”¹ Problem 3 â€” Constructor Reference Example
``` java
Supplier<List<String>> supplier = ArrayList::new;
List<String> names = supplier.get();
names.add("Subbu");
System.out.println(names);` 
```
----------

### ğŸ”¹ Problem 4 â€” Reference Static Method
``` java
List<Double> values = Arrays.asList(4.0, 9.0, 16.0);
values.stream().map(Math::sqrt).forEach(System.out::println);` 
```
----------

### ğŸ”¹ Problem 5 â€” Custom Class Example
``` java
class  Person {
    String name;
    Person(String name) { this.name = name; } void  greet() { System.out.println("Hello, " + name); }
} public  class  Demo { public  static  void  main(String[] args) {
        List<String> names = Arrays.asList("Subbu", "Reddy"); // Constructor Reference List<Person> people = names.stream()
                                   .map(Person::new)
                                   .toList(); // Instance Method Reference people.forEach(Person::greet);
    }
}
``` 
## ğŸ’¡ Pro Tips

1.  **Readability First:**  Use method references when they make code clearer, not just shorter
2.  **Lambda for Logic:**  If you need custom logic beyond calling a method, use lambda expressions
3.  **IDE Support:**  Modern IDEs can automatically convert between lambda and method references
4.  **Chaining:**  Method references work great in stream pipelines
5.  **Debugging:**  Lambdas might be easier to debug with breakpoints

----------

## ğŸ§  Memory Tips

**Mnemonic for 4 Types:**  **SIAC**

-   **S**tatic method reference
-   **I**nstance method (particular object)
-   **I**nstance method (arbitrary object)
-   **C**onstructor reference

**Remember the :: operator as:**

-   "Go to" operator
-   "Points to" operator
-   "References" operator

----------

## Summary

Method references are syntactic sugar for lambda expressions that:

-   Make code more readable and concise
-   Reuse existing methods
-   Work seamlessly with functional interfaces
-   Have the same performance as lambdas
-   Come in 4 flavors: static, instance (2 types), and constructor

Master them to write cleaner, more maintainable Java code!
