
# Spring Cloud Gateway: A Comprehensive Tutorial

## 🏛️ What is Spring Cloud Gateway?

Spring Cloud Gateway is a  **reactive, non-blocking API Gateway**  built on top of Spring Framework 5, Spring Boot 2, and Project Reactor. It provides a simple yet effective way to route requests to microservices and apply cross-cutting concerns like security, monitoring, and resilience.

### 🧠 Memory Visualization

```
┌─────────────────────────────────────────────────┐
│         SPRING CLOUD GATEWAY                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │  Route   │  │ Predicate│  │  Filter  │      │
│  │  Engine  │→ │  Engine  │→ │  Chain   │      │
│  └──────────┘  └──────────┘  └──────────┘      │
└─────────────────────────────────────────────────┘
         ↓                    ↓
    [Routing Table]      [Filter Pipeline]
```

----------

## 🚪 What is an API Gateway?

An  **API Gateway**  is a server that acts as an intermediary between clients and backend microservices. It's the single entry point for all client requests.

### 🎯 Real-World Analogy

Think of an API Gateway as a  **Hotel Receptionist**:

-   **Without Receptionist**: Guests would need to know which room each service is in (housekeeping, room service, concierge)
-   **With Receptionist**: Guests ask one person who routes them to the right service

```
Client Request → API Gateway → Route to Appropriate Microservice
    (Guest)    →  (Receptionist) →  (Hotel Department)
```

----------

## 🤔 Why Do We Need an API Gateway?

### Problem Scenario: E-Commerce Without Gateway

```
Mobile App ────────┐
                   ├──→ User Service (localhost:8081)
Web Browser ───────┤
                   ├──→ Order Service (localhost:8082)
Third-Party API ───┤
                   ├──→ Product Service (localhost:8083)
Admin Portal ──────┘
                   └──→ Payment Service (localhost:8084)
```

**Challenges**:

1.  Clients must know all service URLs
2.  Cross-cutting concerns duplicated in each service
3.  Protocol differences (HTTP, WebSocket, gRPC)
4.  No centralized authentication
5.  Difficult to implement rate limiting

### Solution: With API Gateway

```
All Clients → API Gateway (localhost:8080) → Microservices
                    │
                    ├─→ Authentication
                    ├─→ Rate Limiting
                    ├─→ Logging
                    ├─→ Load Balancing
                    └─→ Request Routing
```

----------

## ✅ Advantages of an API Gateway

### 1.  **Single Entry Point**

java

```java
// Before: Client needs to know all endpoints
userService.call("http://localhost:8081/users")
orderService.call("http://localhost:8082/orders")

// After: Client calls one gateway
gateway.call("http://localhost:8080/users")
gateway.call("http://localhost:8080/orders")
```

### 2.  **Simplified Client Code**

-   Clients don't manage multiple endpoints
-   Protocol translation handled centrally

### 3.  **Cross-Cutting Concerns**

-   **Authentication/Authorization**: Centralized security
-   **Rate Limiting**: Prevent API abuse
-   **Logging/Monitoring**: Unified observability
-   **Caching**: Improve performance

### 4.  **Protocol Translation**

```
Client (REST) → Gateway → Backend Service (gRPC/WebSocket)
```

### 5.  **Load Balancing & Resilience**

-   Distribute requests across service instances
-   Circuit breaker patterns
-   Retry mechanisms

### 6.  **Request/Response Transformation**

```
Client Request:  { "userId": 123 }
                      ↓
Gateway Transform:   { "user_id": 123, "timestamp": "..." }
                      ↓
Backend Service receives enriched request
```

----------

## ❌ Disadvantages of an API Gateway

### 1.  **Single Point of Failure**

```
All Clients → [Gateway DOWN] ✗ All Services Unreachable
```

**Mitigation**: Deploy multiple gateway instances with load balancer

### 2.  **Increased Latency**

```
Without Gateway: Client → Service (50ms)
With Gateway:    Client → Gateway → Service (50ms + 20ms overhead)
```

### 3.  **Additional Complexity**

-   Another component to manage, deploy, and monitor
-   Requires proper configuration management

### 4.  **Development Bottleneck**

-   All routing rules centralized
-   Can become a change bottleneck

### 5.  **Increased Resource Consumption**

-   Memory and CPU overhead
-   Network hop overhead

----------

## 📚 API Gateway Terminologies

### 1.  **Route**  🛣️

A  **Route**  is the fundamental building block of the gateway. It defines:

-   **ID**: Unique identifier
-   **Destination URI**: Where to forward the request
-   **Predicates**: Conditions to match
-   **Filters**: Modifications to apply

#### Memory Model

```
┌─────────────────────────────────┐
│         ROUTE OBJECT            │
├─────────────────────────────────┤
│ id: "user-service-route"        │
│ uri: "lb://USER-SERVICE"        │
│ predicates: [Path=/users/**]    │
│ filters: [AddRequestHeader...]  │
└─────────────────────────────────┘
```

#### Configuration Example

yaml

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service-route
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/**
          filters:
            - AddRequestHeader=X-Request-Source, Gateway
```

----------

### 2.  **Predicate**  🔍

A  **Predicate**  is a condition that must be true for a route to be matched. It's a Java 8 Function that tests the incoming request.

#### Analogy: Security Guard Checklist

```
Security Guard (Predicate) checks:
✓ Does person have valid ID? (Header exists?)
✓ Is person on guest list? (Path matches?)
✓ Is it during visiting hours? (Time constraint?)
```

#### Common Predicate Types
<img width="827" height="412" alt="image" src="https://github.com/user-attachments/assets/1ea54d99-c6ee-4ea3-90b9-9e8e90f044c6" />




#### Code Example

java

```java
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("user-route", r -> r
            .path("/api/users/**")
            .and()
            .method(HttpMethod.GET)
            .and()
            .header("X-API-Version", "v1")
            .uri("lb://USER-SERVICE"))
        .build();
}
```

----------

### 3.  **Filter**  🔧

A  **Filter**  modifies the incoming request or outgoing response. Filters can be applied globally or per-route.

#### Analogy: Airport Security Layers

```
Passenger (Request) passes through:
1. Document Check (Authentication Filter)
2. Security Scan (Validation Filter)
3. Customs (Authorization Filter)
4. Gate Assignment (Routing Filter)
```

#### Filter Types

**Pre-Filters**  (Before routing):

-   Authentication
-   Request logging
-   Header manipulation
-   Rate limiting

**Post-Filters**  (After routing):

-   Response modification
-   Response logging
-   Header addition
-   Error handling

#### Memory Flow

```
Request → [Pre-Filters] → [Route] → Backend Service
                                           ↓
Response ← [Post-Filters] ←────────────────┘
```

#### Common Filters

yaml

```yaml
filters:
  # Add headers
  - AddRequestHeader=X-Request-ID, ${UUID}
  - AddResponseHeader=X-Response-Time, ${responseTime}
  
  # Remove headers
  - RemoveRequestHeader=Cookie
  - RemoveResponseHeader=X-Internal-Info
  
  # Rewrite paths
  - RewritePath=/api/(?<segment>.*), /${segment}
  
  # Strip prefix
  - StripPrefix=1  # /api/users/123 → /users/123
  
  # Set status
  - SetStatus=201
  
  # Retry
  - name: Retry
    args:
      retries: 3
      statuses: BAD_GATEWAY
      
  # Circuit Breaker
  - name: CircuitBreaker
    args:
      name: myCircuitBreaker
      fallbackUri: forward:/fallback
      
  # Rate Limiter
  - name: RequestRateLimiter
    args:
      redis-rate-limiter.replenishRate: 10
      redis-rate-limiter.burstCapacity: 20
```

----------

## 🔄 Routing in API Gateway Spring Boot

### **Static Routing**  📍

Static routing uses  **hardcoded URIs**  defined at application startup.

#### Configuration (application.yml)

yaml

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: http://localhost:8081
          predicates:
            - Path=/users/**
            
        - id: order-service
          uri: http://localhost:8082
          predicates:
            - Path=/orders/**
```

#### Programmatic Configuration

java

```java
@Configuration
public class StaticRoutingConfig {
    
    @Bean
    public RouteLocator staticRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-route", r -> r
                .path("/users/**")
                .uri("http://localhost:8081"))
            .route("order-route", r -> r
                .path("/orders/**")
                .uri("http://localhost:8082"))
            .build();
    }
}
```

**Use Cases**:

-   Small applications with few services
-   Development/testing environments
-   Services with fixed locations

----------

### **Dynamic Routing**  🔄

Dynamic routing uses  **service discovery**  (Eureka, Consul) to locate services at runtime.

#### Configuration

yaml

```yaml
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true  # Enable automatic route creation
          lower-case-service-id: true
      routes:
        - id: user-service
          uri: lb://USER-SERVICE  # Load balanced URI
          predicates:
            - Path=/users/**
```

#### How It Works

```
1. Client Request: GET /users/123

2. Gateway queries Eureka:
   "Where is USER-SERVICE?"

3. Eureka responds:
   - Instance 1: localhost:8081
   - Instance 2: localhost:8082
   - Instance 3: localhost:8083

4. Gateway load balances request:
   → localhost:8082/users/123
```

#### Programmatic Configuration

java

```java
@Configuration
public class DynamicRoutingConfig {
    
    @Bean
    public RouteLocator dynamicRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r
                .path("/users/**")
                .uri("lb://USER-SERVICE"))
            .route("order-service", r -> r
                .path("/orders/**")
                .filters(f -> f.circuitBreaker(c -> c
                    .setName("orderCircuitBreaker")
                    .setFallbackUri("forward:/fallback/orders")))
                .uri("lb://ORDER-SERVICE"))
            .build();
    }
}
```

**Advantages**:

-   Automatic service discovery
-   Load balancing
-   High availability
-   Dynamic scaling

----------

## 📦 How to Include Spring Cloud Gateway

### Step 1: Maven Dependencies

xml

```xml
<properties>
    <spring-cloud.version>2023.0.0</spring-cloud.version>
</properties>

<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    
    <!-- Service Discovery (Optional) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    
    <!-- Resilience4j Circuit Breaker (Optional) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### Step 2: Gradle Dependencies

gradle

```gradle
ext {
    set('springCloudVersion', "2023.0.0")
}

dependencies {
    implementation 'org.springframework.cloud:spring-cloud-starter-gateway'
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
    implementation 'org.springframework.cloud:spring-cloud-starter-circuitbreaker-reactor-resilience4j'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}
```

### Step 3: Enable Gateway

java

```java
@SpringBootApplication
@EnableDiscoveryClient // Optional: for service discovery
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

----------

## 🚫 How to Disable Spring Cloud Gateway

### Method 1: Exclude Auto-Configuration

java

```java
@SpringBootApplication(exclude = {
    GatewayAutoConfiguration.class,
    GatewayClassPathWarningAutoConfiguration.class
})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Method 2: Application Properties

yaml

```yaml
spring:
  cloud:
    gateway:
      enabled: false
```

### Method 3: Profile-Based Disabling

yaml

```yaml
# application-dev.yml
spring:
  cloud:
    gateway:
      enabled: false

# application-prod.yml
spring:
  cloud:
    gateway:
      enabled: true
```

----------

## 🏗️ Real-World Case Study: E-Commerce Microservices

### Business Context

**ShopEasy Inc.**  is an e-commerce platform with the following challenges:

-   Mobile app, web browser, and third-party integrations
-   10+ microservices with different domains
-   Need for centralized authentication and rate limiting
-   Legacy services using older APIs
-   Requirement for API versioning

### Architecture Before Gateway

```
Mobile App ──┐
Web App ─────┼──→ User Service (8081)
             ├──→ Product Service (8082)
Partners ────┼──→ Order Service (8083)
             ├──→ Payment Service (8084)
             ├──→ Inventory Service (8085)
             └──→ Notification Service (8086)
```

**Problems**:

1.  Each client managed 6 different URLs
2.  Authentication logic duplicated in each service
3.  No rate limiting for external partners
4.  Difficult to version APIs
5.  No centralized logging

----------

### Architecture After Gateway

```
All Clients → API Gateway (8080)
                    ↓
        ┌───────────┼───────────┐
        ↓           ↓           ↓
   User Service  Product   Order Service
    (8081)       Service     (8083)
                 (8082)
```

----------

## 💻 Implementation: Step-by-Step Guide

### Project Structure

```
api-gateway/
├── src/main/java/com/shopeasy/gateway/
│   ├── ApiGatewayApplication.java
│   ├── config/
│   │   ├── GatewayConfig.java
│   │   └── SecurityConfig.java
│   ├── filter/
│   │   ├── AuthenticationFilter.java
│   │   ├── LoggingFilter.java
│   │   └── RateLimitFilter.java
│   └── controller/
│       └── FallbackController.java
├── src/main/resources/
│   └── application.yml
└── pom.xml
```

----------

### 1. Main Application Class

java

```java
package com.shopeasy.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

----------

### 2. Application Configuration (application.yml)

yaml

```yaml
server:
  port: 8080

spring:
  application:
    name: api-gateway
    
  cloud:
    gateway:
      # Global CORS configuration
      globalcors:
        corsConfigurations:
          '[/**]':
            allowedOrigins: "*"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
            allowedHeaders: "*"
            
      # Route definitions
      routes:
        # User Service Routes
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
            - Method=GET,POST,PUT,DELETE
          filters:
            - StripPrefix=1
            - name: CircuitBreaker
              args:
                name: userServiceCircuitBreaker
                fallbackUri: forward:/fallback/users
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE
                backoff:
                  firstBackoff: 50ms
                  maxBackoff: 500ms
                  
        # Product Service Routes
        - id: product-service
          uri: lb://PRODUCT-SERVICE
          predicates:
            - Path=/api/products/**
          filters:
            - StripPrefix=1
            - AddRequestHeader=X-Gateway-Source, API-Gateway
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenishRate: 100
                  burstCapacity: 200
                  requestedTokens: 1
                  
        # Order Service Routes  
        - id: order-service
          uri: lb://ORDER-SERVICE
          predicates:
            - Path=/api/orders/**
            - Header=Authorization, Bearer (.*)
          filters:
            - StripPrefix=1
            - name: RewritePath
              args:
                regexp: "/api/orders/(?<segment>.*)"
                replacement: "/orders/${segment}"
                
        # Payment Service Routes
        - id: payment-service
          uri: lb://PAYMENT-SERVICE
          predicates:
            - Path=/api/payments/**
          filters:
            - StripPrefix=1
            - name: CircuitBreaker
              args:
                name: paymentCircuitBreaker
                fallbackUri: forward:/fallback/payment
                
        # Legacy API Version 1 (Deprecated)
        - id: legacy-user-service-v1
          uri: http://legacy-server:9090
          predicates:
            - Path=/api/v1/users/**
            - Header=X-API-Version, v1
          filters:
            - AddResponseHeader=X-API-Deprecated, true
            - AddResponseHeader=X-API-Sunset, 2025-12-31

# Eureka Client Configuration
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  instance:
    preferIpAddress: true

# Actuator for monitoring
management:
  endpoints:
    web:
      exposure:
        include: health,info,gateway
  endpoint:
    gateway:
      enabled: true

# Logging
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    com.shopeasy.gateway: INFO
```

----------

### 3. Custom Global Filter

java

```java
package com.shopeasy.gateway.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Component
public class LoggingFilter implements GlobalFilter, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(LoggingFilter.class);

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // Generate unique request ID
        String requestId = UUID.randomUUID().toString();
        
        // Get request details
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().toString();
        String method = request.getMethod().toString();
        String clientIp = request.getRemoteAddress().getAddress().getHostAddress();
        
        // Log incoming request
        logger.info("Request ID: {} | Method: {} | Path: {} | Client IP: {}", 
            requestId, method, path, clientIp);
        
        // Add request ID to headers
        ServerHttpRequest modifiedRequest = request.mutate()
            .header("X-Request-ID", requestId)
            .build();
        
        // Record start time
        long startTime = System.currentTimeMillis();
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build())
            .then(Mono.fromRunnable(() -> {
                long duration = System.currentTimeMillis() - startTime;
                int statusCode = exchange.getResponse().getStatusCode().value();
                
                logger.info("Request ID: {} | Status: {} | Duration: {}ms", 
                    requestId, statusCode, duration);
            }));
    }

    @Override
    public int getOrder() {
        return -1; // Execute first
    }
}
```

----------

### 4. Authentication Filter

java

```java
package com.shopeasy.gateway.filter;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class AuthenticationFilter extends AbstractGatewayFilterFactory<AuthenticationFilter.Config> {

    public AuthenticationFilter() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            
            // Check if Authorization header exists
            if (!request.getHeaders().containsKey("Authorization")) {
                return this.onError(exchange, "Missing authorization header", HttpStatus.UNAUTHORIZED);
            }
            
            String authHeader = request.getHeaders().get("Authorization").get(0);
            
            // Validate token (simplified - in production use JWT validation)
            if (!authHeader.startsWith("Bearer ")) {
                return this.onError(exchange, "Invalid authorization format", HttpStatus.UNAUTHORIZED);
            }
            
            String token = authHeader.substring(7);
            
            // Validate token (mock validation)
            if (!isValidToken(token)) {
                return this.onError(exchange, "Invalid or expired token", HttpStatus.UNAUTHORIZED);
            }
            
            // Extract user info from token and add to headers
            String userId = extractUserId(token);
            ServerHttpRequest modifiedRequest = request.mutate()
                .header("X-User-ID", userId)
                .build();
            
            return chain.filter(exchange.mutate().request(modifiedRequest).build());
        };
    }

    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(httpStatus);
        return response.setComplete();
    }

    private boolean isValidToken(String token) {
        // Mock validation - implement actual JWT validation
        return token != null && token.length() > 10;
    }

    private String extractUserId(String token) {
        // Mock extraction - implement actual JWT parsing
        return "user123";
    }

    public static class Config {
        // Configuration properties if needed
    }
}
```

----------

### 5. Custom Route Configuration

java

```java
package com.shopeasy.gateway.config;

import com.shopeasy.gateway.filter.AuthenticationFilter;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    private final AuthenticationFilter authenticationFilter;

    public GatewayConfig(AuthenticationFilter authenticationFilter) {
        this.authenticationFilter = authenticationFilter;
    }

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // Public routes - no authentication
            .route("public-products", r -> r
                .path("/api/public/products/**")
                .filters(f -> f
                    .stripPrefix(2)
                    .addResponseHeader("X-Response-Source", "Gateway"))
                .uri("lb://PRODUCT-SERVICE"))
            
            // Protected routes - authentication required
            .route("protected-orders", r -> r
                .path("/api/orders/**")
                .filters(f -> f
                    .filter(authenticationFilter.apply(new AuthenticationFilter.Config()))
                    .stripPrefix(1))
                .uri("lb://ORDER-SERVICE"))
            
            // Admin routes - special handling
            .route("admin-routes", r -> r
                .path("/api/admin/**")
                .and()
                .header("X-Admin-Role", "true")
                .filters(f -> f
                    .filter(authenticationFilter.apply(new AuthenticationFilter.Config()))
                    .stripPrefix(2)
                    .addRequestHeader("X-Admin-Access", "true"))
                .uri("lb://ADMIN-SERVICE"))
            
            // Redirect old API to new
            .route("redirect-old-api", r -> r
                .path("/old-api/**")
                .filters(f -> f.redirect(301, "https://new-api.shopeasy.com"))
                .uri("no://op"))
            
            .build();
    }
}
```

----------

### 6. Fallback Controller

java

```java
package com.shopeasy.gateway.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/fallback")
public class FallbackController {

    @GetMapping("/users")
    public ResponseEntity<Map<String, Object>> userServiceFallback() {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "User service is temporarily unavailable");
        response.put("status", "SERVICE_UNAVAILABLE");
        response.put("timestamp", LocalDateTime.now());
        response.put("suggestion", "Please try again later");
        
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }

    @GetMapping("/payment")
    public ResponseEntity<Map<String, Object>> paymentServiceFallback() {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Payment service is temporarily unavailable");
        response.put("status", "SERVICE_UNAVAILABLE");
        response.put("timestamp", LocalDateTime.now());
        response.put("action", "Your payment will be processed when service is restored");
        
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }
}
```

----------

### 7. Custom Predicate Factory

java

```java
package com.shopeasy.gateway.predicate;

import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import java.time.LocalTime;
import java.util.function.Predicate;

@Component
public class BusinessHoursRoutePredicateFactory 
    extends AbstractRoutePredicateFactory<BusinessHoursRoutePredicateFactory.Config> {

    public BusinessHoursRoutePredicateFactory() {
        super(Config.class);
    }

    @Override
    public Predicate<ServerWebExchange> apply(Config config) {
        return exchange -> {
            LocalTime now = LocalTime.now();
            LocalTime start = LocalTime.parse(config.getStartTime());
            LocalTime end = LocalTime.parse(config.getEndTime());
            
            return now.isAfter(start) && now.isBefore(end);
        };
    }

    public static class Config {
        private String startTime;
        private String endTime;

        public String getStartTime() {
            return startTime;
        }

        public void setStartTime(String startTime) {
            this.startTime = startTime;
        }

        public String getEndTime() {
            return endTime;
        }

        public void setEndTime(String endTime) {
            this.endTime = endTime;
        }
    }
}
```

Usage:

yaml

```yaml
routes:
  - id: business-hours-service
    uri: lb://BUSINESS-SERVICE
    predicates:
      - Path=/api/business/**
      - name: BusinessHours
        args:
          startTime: "09:00"
          endTime: "17:00"
```

----------

## 🧪 How to Test API Gateway

### Testing Strategy Overview

```
┌─────────────────────────────────────────────┐
│         Testing Pyramid                      │
├─────────────────────────────────────────────┤
│              E2E Tests                       │
│         ▲                                    │
│        ▲ ▲  Integration Tests               │
│       ▲   ▲                                  │
│      ▲     ▲  Unit Tests                     │
│     ▲▲▲▲▲▲▲▲▲                               │
└─────────────────────────────────────────────┘
```

----------

### 1. Unit Testing Routes

java

```java
package com.shopeasy.gateway;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.test.context.ActiveProfiles;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@ActiveProfiles("test")
public class GatewayRoutesTest {

    @Autowired
    private RouteLocator routeLocator;

    @Test
    public void testRoutesAreLoaded() {
        assertThat(routeLocator.getRoutes().collectList().block())
            .isNotEmpty()
            .hasSize(5); // Expected number of routes
    }

    @Test
    public void testUserServiceRouteExists() {
        boolean exists = routeLocator.getRoutes()
            .any(route -> route.getId().equals("user-service"))
            .block();
        
        assertThat(exists).isTrue();
    }
}
```

----------

### 2. Integration Testing with MockServer

#### Add MockServer Dependency

xml

```xml
<dependency>
    <groupId>org.mock-server</groupId>
    <artifactId>mockserver-netty</artifactId>
    <version>5.15.0</version>
    <scope>test</scope>
</dependency>
```

#### Integration Test Class

java

```java
package com.shopeasy.gateway;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.mockserver.integration.ClientAndServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ActiveProfiles;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockserver.model.HttpRequest.request;
import static org.mockserver.model.HttpResponse.response;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
public class GatewayIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    private static ClientAndServer mockServer;

    @BeforeAll
    public static void startServer() {
        mockServer = ClientAndServer.startClientAndServer(8081);
    }

    @AfterAll
    public static void stopServer() {
        mockServer.stop();
    }

    @Test
    public void testUserServiceRouting() {
        // Setup mock response
        mockServer
            .when(request()
                .withMethod("GET")
                .withPath("/users/123"))
            .respond(response()
                .withStatusCode(200)
                .withBody("{\"id\":123,\"name\":\"John Doe\"}"));

        // Call through gateway
        ResponseEntity<String> response = restTemplate.getForEntity(
            "/api/users/123", 
            String.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).contains("John Doe");
    }

    @Test
    public void testAuthenticationFilter() {
        ResponseEntity<String> response = restTemplate.getForEntity(
            "/api/orders/123", 
            String.class
        );

        // Should fail without authentication
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
    }
}
```

----------

### 3. Testing with Postman/cURL

#### Test Case 1: Basic Route

bash

```bash
# Test user service routing
curl -X GET http://localhost:8080/api/users/123 \
  -H "Content-Type: application/json"

# Expected Response:
# Status: 200 OK
# Body: {"id": 123, "name": "John Doe", "email": "john@example.com"}
```

#### Test Case 2: Authentication Required

bash

```bash
# Without token - should fail
curl -X GET http://localhost:8080/api/orders/456

# Expected Response:
# Status: 401 Unauthorized
# Body: {"error": "Missing authorization header"}

# With token - should succeed
curl -X GET http://localhost:8080/api/orders/456 \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Expected Response:
# Status: 200 OK
# Body: {"orderId": 456, "status": "DELIVERED"}
```

#### Test Case 3: Rate Limiting

bash

```bash
# Send 250 requests quickly
for i in {1..250}; do
  curl -X GET http://localhost:8080/api/products/1 &
done

# First 200 should succeed (burst capacity)
# Remaining 50 should get:
# Status: 429 Too Many Requests
# Body: {"error": "Rate limit exceeded"}
```

#### Test Case 4: Circuit Breaker

bash

```bash
# Stop the order service to trigger circuit breaker
docker stop order-service

# Try to access order endpoint
curl -X GET http://localhost:8080/api/orders/123

# Expected Response (fallback):
# Status: 503 Service Unavailable
# Body: {
#   "message": "Order service is temporarily unavailable",
#   "status": "SERVICE_UNAVAILABLE",
#   "timestamp": "2025-10-31T10:30:00"
# }
```

#### Test Case 5: Header Manipulation

bash

```bash
# Send request and observe headers
curl -v -X GET http://localhost:8080/api/products/1

# Response should include:
# X-Request-ID: 550e8400-e29b-41d4-a716-446655440000
# X-Response-Source: Gateway
# X-Response-Time: 45ms
```

----------

### 4. Load Testing with Apache Bench

bash

```bash
# Test 1000 requests with 10 concurrent users
ab -n 1000 -c 10 -H "Authorization: Bearer test-token" \
  http://localhost:8080/api/users/123

# Sample Output:
# Requests per second:    850.25 [#/sec]
# Time per request:       11.761 [ms] (mean)
# Time per request:       1.176 [ms] (mean, across all concurrent requests)
# Transfer rate:          500.42 [Kbytes/sec] received
```

----------

### 5. Testing with JMeter

#### JMeter Test Plan Structure

```
Test Plan
└── Thread Group (100 users, 10 sec ramp-up)
    ├── HTTP Request: GET /api/products
    ├── HTTP Request: GET /api/users/{id}
    ├── HTTP Request: POST /api/orders
    └── Listeners
        ├── View Results Tree
        ├── Summary Report
        └── Aggregate Graph
```

#### Sample JMeter Configuration (XML)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testname="Gateway Load Test">
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments">
        <collectionProp name="Arguments.arguments">
          <elementProp name="GATEWAY_HOST" elementType="Argument">
            <stringProp name="Argument.value">localhost</stringProp>
          </elementProp>
          <elementProp name="GATEWAY_PORT" elementType="Argument">
            <stringProp name="Argument.value">8080</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
    </TestPlan>
    
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testname="User Load">
        <intProp name="ThreadGroup.num_threads">100</intProp>
        <intProp name="ThreadGroup.ramp_time">10</intProp>
        <longProp name="ThreadGroup.duration">60</longProp>
      </ThreadGroup>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

----------

### 6. Automated Testing with REST Assured

java

```java
package com.shopeasy.gateway;

import io.restassured.RestAssured;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class GatewayRestAssuredTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setup() {
        RestAssured.port = port;
        RestAssured.basePath = "/api";
    }

    @Test
    public void testProductServiceRoute() {
        given()
            .when()
                .get("/products/1")
            .then()
                .statusCode(200)
                .body("id", equalTo(1))
                .body("name", notNullValue())
                .header("X-Response-Source", "Gateway");
    }

    @Test
    public void testAuthenticationRequired() {
        given()
            .when()
                .get("/orders/123")
            .then()
                .statusCode(401)
                .body("error", containsString("authorization"));
    }

    @Test
    public void testWithAuthentication() {
        given()
            .header("Authorization", "Bearer valid-token-here")
            .when()
                .get("/orders/123")
            .then()
                .statusCode(200)
                .body("orderId", equalTo(123))
                .header("X-Request-ID", notNullValue());
    }

    @Test
    public void testRateLimiting() {
        // Send multiple requests rapidly
        for (int i = 0; i < 250; i++) {
            given()
                .when()
                    .get("/products/1")
                .then()
                    .statusCode(anyOf(is(200), is(429)));
        }
    }
}
```

----------

### 7. Monitoring and Observability Testing

#### Test Actuator Endpoints

bash

```bash
# Check gateway health
curl http://localhost:8080/actuator/health

# Response:
# {
#   "status": "UP",
#   "components": {
#     "gateway": {"status": "UP"},
#     "diskSpace": {"status": "UP"},
#     "ping": {"status": "UP"}
#   }
# }

# Get all routes
curl http://localhost:8080/actuator/gateway/routes | jq

# Get specific route details
curl http://localhost:8080/actuator/gateway/routes/user-service | jq

# Refresh routes
curl -X POST http://localhost:8080/actuator/gateway/refresh

# Get global filters
curl http://localhost:8080/actuator/gateway/globalfilters | jq
```

----------

### 8. End-to-End Testing Scenario

#### Complete E2E Test

java

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class EndToEndTest {

    @Autowired
    private TestRestTemplate restTemplate;

    private static String authToken;
    private static Long userId;
    private static Long orderId;

    @Test
    @Order(1)
    public void testUserRegistration() {
        String requestBody = """
            {
                "username": "testuser",
                "email": "test@example.com",
                "password": "SecurePass123"
            }
            """;

        ResponseEntity<Map> response = restTemplate.postForEntity(
            "/api/users/register",
            requestBody,
            Map.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        userId = ((Number) response.getBody().get("id")).longValue();
    }

    @Test
    @Order(2)
    public void testUserLogin() {
        String requestBody = """
            {
                "email": "test@example.com",
                "password": "SecurePass123"
            }
            """;

        ResponseEntity<Map> response = restTemplate.postForEntity(
            "/api/auth/login",
            requestBody,
            Map.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        authToken = (String) response.getBody().get("token");
    }

    @Test
    @Order(3)
    public void testBrowseProducts() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + authToken);

        ResponseEntity<List> response = restTemplate.exchange(
            "/api/products",
            HttpMethod.GET,
            new HttpEntity<>(headers),
            List.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotEmpty();
    }

    @Test
    @Order(4)
    public void testCreateOrder() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + authToken);
        headers.setContentType(MediaType.APPLICATION_JSON);

        String requestBody = """
            {
                "userId": %d,
                "items": [
                    {"productId": 1, "quantity": 2},
                    {"productId": 3, "quantity": 1}
                ]
            }
            """.formatted(userId);

        ResponseEntity<Map> response = restTemplate.exchange(
            "/api/orders",
            HttpMethod.POST,
            new HttpEntity<>(requestBody, headers),
            Map.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        orderId = ((Number) response.getBody().get("orderId")).longValue();
    }

    @Test
    @Order(5)
    public void testProcessPayment() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + authToken);
        headers.setContentType(MediaType.APPLICATION_JSON);

        String requestBody = """
            {
                "orderId": %d,
                "amount": 299.99,
                "paymentMethod": "CREDIT_CARD"
            }
            """.formatted(orderId);

        ResponseEntity<Map> response = restTemplate.exchange(
            "/api/payments",
            HttpMethod.POST,
            new HttpEntity<>(requestBody, headers),
            Map.class
        );

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().get("status")).isEqualTo("SUCCESS");
    }
}
```

----------

## 📊 Performance Metrics and Benchmarks

### Real-World Performance Data from ShopEasy Implementation

#### Before Gateway

```
Average Response Time: 120ms
95th Percentile: 250ms
99th Percentile: 500ms
Error Rate: 2.5%
Throughput: 5000 req/sec
```

#### After Gateway (with optimizations)

```
Average Response Time: 145ms (+25ms overhead)
95th Percentile: 280ms
99th Percentile: 550ms
Error Rate: 0.8% (improved by rate limiting & circuit breakers)
Throughput: 4800 req/sec
Circuit Breaker Success: 99.5%
Rate Limiting: 1000 requests blocked/minute
```

### Memory Footprint

```
Gateway Service:
- Initial Heap: 512MB
- Max Heap: 2GB
- Average Usage: 800MB
- GC Pause: <50ms (G1GC)
```

----------

## 🎯 Best Practices and Production Tips

### 1. Security Best Practices

yaml

```yaml
# HTTPS Configuration
server:
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    key-store-type: PKCS12
    
# Security Headers
spring:
  cloud:
    gateway:
      default-filters:
        - SecureHeaders
        - name: AddResponseHeader
          args:
            name: X-Frame-Options
            value: DENY
        - name: AddResponseHeader
          args:
            name: X-Content-Type-Options
            value: nosniff
```

### 2. Production Logging Configuration

yaml

```yaml
logging:
  level:
    root: INFO
    com.shopeasy.gateway: DEBUG
    org.springframework.cloud.gateway: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
  file:
    name: /var/log/gateway/application.log
    max-size: 10MB
    max-history: 30
```

### 3. Resilience Configuration

yaml

```yaml
resilience4j:
  circuitbreaker:
    instances:
      userServiceCircuitBreaker:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        
  retry:
    instances:
      userServiceRetry:
        maxAttempts: 3
        waitDuration: 500ms
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2
```

### 4. Caching Strategy

java

```java
@Configuration
public class CachingConfig {
    
    @Bean
    public RouteLocator cachedRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("cached-products", r -> r
                .path("/api/products/**")
                .filters(f -> f
                    .setResponseHeader("Cache-Control", "max-age=3600")
                    .setResponseHeader("ETag", UUID.randomUUID().toString()))
                .uri("lb://PRODUCT-SERVICE"))
            .build();
    }
}
```

### 5. Monitoring and Alerting

yaml

```yaml
management:
  metrics:
    export:
      prometheus:
        enabled: true
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus,gateway
  health:
    circuitbreakers:
      enabled: true
```

----------

## 🔍 Troubleshooting Common Issues

### Issue 1: Routes Not Working

**Symptom**: 404 Not Found for all requests

**Solutions**:

bash

```bash
# Check if routes are loaded
curl http://localhost:8080/actuator/gateway/routes

# Verify service registration
curl http://localhost:8761/eureka/apps

# Check logs
tail -f logs/application.log | grep "Route"

# Common fixes:
# 1. Ensure @EnableDiscoveryClient is present
# 2. Verify Eureka connection
# 3. Check route predicates syntax
```

### Issue 2: Service Discovery Not Working

**Symptom**: "503 Service Unavailable" or "UNKNOWN_HOST"

**Solution**:

yaml

```yaml
# Add to application.yml
eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.application.name}:${random.value}
  client:
    register-with-eureka: true
    fetch-registry: true
    healthcheck:
      enabled: true
```

### Issue 3: High Memory Usage

**Solution**:

yaml

```yaml
# Optimize buffer sizes
spring:
  codec:
    max-in-memory-size: 10MB  # Default 256KB

# JVM options
JAVA_OPTS: "-Xms512m -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200"
```

### Issue 4: Slow Response Times

**Debugging**:

java

```java
@Component
public class PerformanceFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        long start = System.currentTimeMillis();
        return chain.filter(exchange)
            .doFinally(signalType -> {
                long duration = System.currentTimeMillis() - start;
                if (duration > 1000) {
                    logger.warn("Slow request: {} took {}ms", 
                        exchange.getRequest().getPath(), duration);
                }
            });
    }
}
```

----------

## 📈 Advanced Patterns and Architectures

### 1. Multi-Region Gateway Pattern

```
          Internet
              |
       [Global Load Balancer]
         /            \
    US-Gateway     EU-Gateway
        |              |
   US-Services    EU-Services
```

### 2. Backend for Frontend (BFF) Pattern

```
Mobile App  →  Mobile-Gateway  →  Microservices
Web App     →  Web-Gateway     →  Microservices  
IoT Device  →  IoT-Gateway     →  Microservices
```

### 3. Gateway Aggregation Pattern

java

```java
@GetMapping("/dashboard")
public Mono<Dashboard> getDashboard(@RequestHeader("Authorization") String token) {
    Mono<User> user = webClient.get()
        .uri("lb://USER-SERVICE/profile")
        .header("Authorization", token)
        .retrieve()
        .bodyToMono(User.class);
        
    Mono<List<Order>> orders = webClient.get()
        .uri("lb://ORDER-SERVICE/recent")
        .header("Authorization", token)
        .retrieve()
        .bodyToFlux(Order.class)
        .collectList();
        
    Mono<Recommendations> recommendations = webClient.get()
        .uri("lb://RECOMMENDATION-SERVICE/suggestions")
        .header("Authorization", token)
        .retrieve()
        .bodyToMono(Recommendations.class);
    
    return Mono.zip(user, orders, recommendations)
        .map(tuple -> new Dashboard(
            tuple.getT1(),
            tuple.getT2(),
            tuple.getT3()
        ));
}
```

----------

## 🎓 Conclusion

### Key Takeaways

1.  **Spring Cloud Gateway**  provides a powerful, reactive API Gateway solution
2.  **Routes, Predicates, and Filters**  are the core building blocks
3.  **Dynamic routing**  with service discovery enables scalable architectures
4.  **Cross-cutting concerns**  are centralized and simplified
5.  **Resilience patterns**  (circuit breakers, retries) protect your services

### When to Use Spring Cloud Gateway

✅  **Use When**:

-   Building microservices architecture
-   Need centralized authentication/authorization
-   Require rate limiting and throttling
-   Want to implement circuit breakers
-   Need protocol translation
-   Multiple client types (mobile, web, IoT)

❌  **Don't Use When**:

-   Monolithic application
-   Ultra-low latency requirements (<5ms)
-   Simple application with 1-2 services
-   Team lacks reactive programming knowledge

### Performance Summary
<img width="817" height="212" alt="image" src="https://github.com/user-attachments/assets/27eb1323-fc69-4f2e-8f2b-981e4c835a40" />


### Real-World Impact (ShopEasy Case Study)

**Before Gateway**:

-   12 client-side URL configurations
-   Duplicate auth logic in 8 services
-   No rate limiting (API abuse incidents)
-   Difficult deployment coordination

**After Gateway**:

-   1 client-side URL
-   Centralized authentication
-   99.2% reduction in API abuse
-   Independent service deployments
-   70% reduction in cross-cutting concern code



----------

## 📝 Quick Reference Card

### Essential Commands

bash

```bash
# Start Gateway
mvn spring-boot:run

# Build Docker Image
docker build -t api-gateway:1.0 .

# Run with Profile
java -jar gateway.jar --spring.profiles.active=prod

# Check Routes
curl http://localhost:8080/actuator/gateway/routes

# Refresh Configuration
curl -X POST http://localhost:8080/actuator/gateway/refresh
```

### Common Route Patterns

yaml

```yaml
# Basic Route
- Path=/api/users/**

# Multiple Paths
- Path=/api/users/**,/api/admin/**

# With Headers
- Header=X-API-Version, v[1-2]

# With Query Params
- Query=page, [0-9]+

# Time-based
- Between=09:00,17:00

# Method-based
- Method=GET,POST

# Host-based
- Host=**.example.com
```

### Common Filters

yaml

```yaml
# Strip Prefix
- StripPrefix=1

# Add Headers
- AddRequestHeader=X-Custom, value
- AddResponseHeader=X-Source, gateway

# Rewrite Path
- RewritePath=/old/(.*), /new/$\{1}

# Rate Limit
- RequestRateLimiter=10,20

# Circuit Breaker
- CircuitBreaker=myBreaker
```

----------

**End of Tutorial**

This comprehensive guide covered Spring Cloud Gateway from basics to production-ready implementation with real-world examples from the ShopEasy e-commerce platform.
