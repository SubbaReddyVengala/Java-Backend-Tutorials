
# Distributed Tracing with Spring Cloud Sleuth and Zipkin: A Complete Tutorial

## Table of Contents

1.  What is Logging & Tracing?
2.  What are Sleuth and Zipkin?
3.  Real-World Case Study
4.  Theory and Core Concepts
5.  Setting Up Zipkin Server
6.  Hands-On Implementation
7.  Testing and Visualization
8. Conclusion

----------

## <a name="logging-tracing"></a>1. What is Logging & Tracing?

### The Problem: Lost in the Microservices Maze

**Analogy: The Restaurant Chain Mystery** 🍕

Imagine you ordered a pizza online, and it arrived cold and wrong. You call to complain, but:

-   The website team says: "We sent the order correctly!"
-   The kitchen says: "We cooked it perfectly!"
-   The delivery driver says: "It was hot when I got it!"

**Who's responsible?** Without a tracking system, it's impossible to know where things went wrong.

### Traditional Logging vs Distributed Tracing

#### **Traditional Logging** (Monolithic Applications)

```
[2025-11-01 10:15:23] User requested order #12345
[2025-11-01 10:15:24] Processing payment for order #12345
[2025-11-01 10:15:25] Order #12345 completed
```
✅ **Simple**: Everything in one place  
✅ **Easy to follow**: Linear flow  

#### **Distributed Tracing** (Microservices)
```
Service A: [TraceID: abc123] Received user request
Service B: [TraceID: abc123] Processing payment
Service C: [TraceID: abc123] Sending notification
Service D: [TraceID: abc123] Updating inventory
```
✅ **Correlation**: Same TraceID across services  
✅ **Complete picture**: See the entire journey  

### Memory Visualization: The Thread Through Services

Think of a **TraceID** like a colored thread 🧵:
```
User Request → [🔴 RED THREAD abc123]
    ↓
Service A (Order) → Still 🔴 RED THREAD abc123
    ↓
Service B (Payment) → Still 🔴 RED THREAD abc123
    ↓
Service C (Notification) → Still 🔴 RED THREAD abc123
```

You can **follow the red thread** through the entire system!

---

## <a name="sleuth-zipkin-intro"></a>2. What are Sleuth and Zipkin?

### Spring Cloud Sleuth: The Detective 🕵️

**What it does:**
- Automatically adds **TraceID** and **SpanID** to every log
- Works behind the scenes (no code changes needed)
- Propagates IDs across service boundaries

**Key Concepts:**

#### **Trace**: The Entire Journey
```
Trace (abc123) = Complete request flow from start to finish
```

#### **Span**: Individual Steps
```
Span (span-1): Service A processing
Span (span-2): Service B processing  
Span (span-3): Service C processing
```

**Analogy: Tracking a Package** 📦
- **Trace** = The package's tracking number (stays the same)
- **Span** = Each stop on the journey (warehouse → truck → delivery)

### Zipkin: The Timeline Visualizer 📊

**What it does:**
- Collects trace data from all services
- Stores it in a database
- Provides a beautiful UI to visualize request flows
- Shows timing information and bottlenecks

**Analogy: Flight Tracker**
Just like FlightRadar24 shows you where planes are, Zipkin shows you where your requests are!

---

## <a name="case-study"></a>3. Real-World Case Study

### Scenario: E-Commerce Order System Failure

**The Incident:**
```
Date: October 15, 2025
Issue: 30% of orders failing
Customer Impact: $50,000 lost revenue per hour
```

#### **Without Distributed Tracing:**
```
Timeline: 6 hours to identify root cause

Hour 1-2: Check Order Service logs ❌ Nothing found
Hour 3-4: Check Payment Service logs ❌ Nothing found  
Hour 5: Check Inventory Service logs ❌ Nothing found
Hour 6: Finally found! Notification Service timeout
```

**Problem**: Each team only saw their own logs!

#### **With Distributed Tracing (Sleuth + Zipkin):**
```
Timeline: 15 minutes to identify root cause

Minute 1-5: Search failed orders in Zipkin
Minute 5-10: See complete trace with timing
Minute 10-15: Identify Notification Service taking 30 seconds
```

**Solution Found**: Notification Service had a database connection pool exhaustion.

### Visual Comparison:

**Before (Manual Investigation):**
```
Order Service: ✅ 100ms
    ↓ [Mystery Black Hole]
Payment Service: ✅ 150ms
    ↓ [Mystery Black Hole]
Inventory Service: ✅ 200ms
    ↓ [Mystery Black Hole]
Notification: ❌ 30,000ms (Found after 6 hours!)
```

**After (Zipkin Dashboard):**
```
Timeline View:
|Order-100ms|Payment-150ms|Inventory-200ms|Notification-30,000ms|
                                          ↑
                                    BOTTLENECK VISIBLE!
```

---

## <a name="theory"></a>4. Theory and Core Concepts

### The Anatomy of Distributed Tracing

#### **1. Trace ID (The Master Identifier)**
- **Format**: `a1b2c3d4e5f6g7h8` (64-bit or 128-bit)
- **Lifespan**: Created at entry point, dies at completion
- **Purpose**: Link all operations for a single request

#### **2. Span ID (The Operation Identifier)**
- **Format**: `span-12345678`
- **Lifespan**: Created per operation, dies when operation completes
- **Purpose**: Identify individual work units

#### **3. Parent Span ID**
- **Purpose**: Create hierarchy (which span called this span)

### Visual Example: Online Shopping Request
```
TraceID: purchase-789xyz

User clicks "Buy Now"
│
├─ Span-1 (Order Service) [100ms]
│  │
│  ├─ Span-2 (Payment Service) [150ms]  [Parent: Span-1]
│  │  │
│  │  └─ Span-3 (Bank API Call) [120ms]  [Parent: Span-2]
│  │
│  └─ Span-4 (Inventory Service) [80ms]  [Parent: Span-1]
│
└─ Span-5 (Notification Service) [50ms]  [Parent: Span-1]
```

### How Sleuth Works Under the Hood

**Magic Happens in HTTP Headers:**

http

```http
GET /api/payment HTTP/1.1
X-B3-TraceId: a1b2c3d4e5f6g7h8
X-B3-SpanId: span-12345678
X-B3-ParentSpanId: span-00000001
X-B3-Sampled: 1
```

**Analogy: Passport Stamps** 🛂
- Each country (service) stamps your passport (adds span)
- Your passport number (TraceID) stays the same
- Each stamp (span) shows where you've been

### Sampling Strategy

**Problem**: Tracing every request = too much data!

**Solution**: Sample a percentage
```
100% Sampling = Every request traced (Dev/Testing)
10% Sampling = 1 in 10 requests traced (Production)
1% Sampling = 1 in 100 requests traced (High-traffic production)
```

**Memory Aid:** Think of **quality control** in manufacturing—you don't test every single product, just a representative sample.

----------

## <a name="zipkin-setup"></a>5. Setting Up Zipkin Server

### Method 1: Download JAR (Quickest)

#### **Step 1: Download**

bash

```bash
curl -sSL https://zipkin.io/quickstart.sh | bash -s
```

Or manually:

bash

```bash
wget https://search.maven.org/remote_content?g=io.zipkin&a=zipkin-server&v=LATEST&c=exec -O zipkin.jar
```

#### **Step 2: Run**

bash

```bash
java -jar zipkin.jar
```

#### **Step 3: Verify**

Open browser: `http://localhost:9411`

### Method 2: Docker (Recommended for Production)

bash

```bash
docker run -d -p 9411:9411 openzipkin/zipkin
```

### Method 3: Docker Compose (With Storage)

yaml

```yaml
version: '3.8'
services:
  zipkin:
    image: openzipkin/zipkin
    ports:
      - "9411:9411"
    environment:
      - STORAGE_TYPE=mysql
      - MYSQL_HOST=mysql
      - MYSQL_USER=zipkin
      - MYSQL_PASS=zipkin
  
  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MYSQL_DATABASE=zipkin
      - MYSQL_USER=zipkin
      - MYSQL_PASSWORD=zipkin
```

### Understanding Zipkin Architecture
```
┌─────────────────┐
│ Microservice A  │────┐
└─────────────────┘    │
                       │  HTTP POST /api/v2/spans
┌─────────────────┐    │
│ Microservice B  │────┼────► ┌──────────────┐
└─────────────────┘    │      │ Zipkin Server│
                       │      │   (Port 9411)│
┌─────────────────┐    │      └──────────────┘
│ Microservice C  │────┘              │
└─────────────────┘                   │
                                      ▼
                              ┌──────────────┐
                              │   Storage    │
                              │ (In-Memory/  │
                              │  MySQL/ES)   │
                              └──────────────┘
```

---

## <a name="implementation"></a>6. Hands-On Implementation

### Architecture We'll Build
```
User Request
    ↓
┌─────────────────────────┐
│  Service A (Order)      │  Port: 8081
│  "I'm the entry point"  │
└─────────────────────────┘
    │
    ├──────► ┌─────────────────────────┐
    │        │ Service B (Payment)     │  Port: 8082
    │        │ "I process payments"    │
    │        └─────────────────────────┘
    │
    └──────► ┌─────────────────────────┐
             │ Service C (Inventory)   │  Port: 8083
             │ "I check stock"         │
             └─────────────────────────┘

All services send traces to:
┌─────────────────────────┐
│ Zipkin Server           │  Port: 9411
└─────────────────────────┘
```

### Step 1: Create Service A (Order Service)

#### **pom.xml**

xml

```xml
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Cloud Sleuth -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    
    <!-- Zipkin Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin</artifactId>
    </dependency>
    
    <!-- RestTemplate Support -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2021.0.5</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

#### **application.properties**

properties

```properties
# Service Configuration
spring.application.name=order-service
server.port=8081

# Zipkin Configuration
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0

# Logging Configuration
logging.level.org.springframework.web=DEBUG
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]
```

**Explanation:**

-   `spring.application.name`: Service identifier in Zipkin
-   `spring.zipkin.base-url`: Where to send trace data
-   `spring.sleuth.sampler.probability=1.0`: Trace 100% of requests (use 0.1 for 10% in production)
-   `logging.pattern.level`: Custom log format showing TraceID and SpanID

#### **AppConfig.java**

java

```java
package com.example.orderservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**Why RestTemplate Bean?**

-   Sleuth automatically instruments RestTemplate
-   Automatically propagates TraceID and SpanID in HTTP headers
-   No manual header management needed!

#### **OrderController.java**

java

```java
package com.example.orderservice.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class OrderController {
    
    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);
    
    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping("/order")
    public String createOrder() {
        logger.info("Order Service: Received order request");
        
        // Call Payment Service
        logger.info("Order Service: Calling Payment Service");
        String paymentResponse = restTemplate.getForObject(
            "http://localhost:8082/payment", 
            String.class
        );
        logger.info("Order Service: Payment Response - {}", paymentResponse);
        
        // Call Inventory Service
        logger.info("Order Service: Calling Inventory Service");
        String inventoryResponse = restTemplate.getForObject(
            "http://localhost:8083/inventory", 
            String.class
        );
        logger.info("Order Service: Inventory Response - {}", inventoryResponse);
        
        logger.info("Order Service: Order completed successfully");
        return "Order Created! Payment: " + paymentResponse + 
               ", Inventory: " + inventoryResponse;
    }
}
```

**Key Points:**

-   ✅ Sleuth automatically adds TraceID/SpanID to logs
-   ✅ RestTemplate automatically propagates trace context
-   ✅ No manual trace management code needed!

----------

### Step 2: Create Service B (Payment Service)

#### **application.properties**

properties

```properties
spring.application.name=payment-service
server.port=8082

spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0

logging.level.org.springframework.web=DEBUG
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]
```

#### **AppConfig.java**

java

```java
package com.example.paymentservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### **PaymentController.java**

java

```java
package com.example.paymentservice.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PaymentController {
    
    private static final Logger logger = LoggerFactory.getLogger(PaymentController.class);
    
    @GetMapping("/payment")
    public String processPayment() {
        logger.info("Payment Service: Processing payment");
        
        // Simulate payment processing
        try {
            Thread.sleep(150); // Simulate 150ms processing
        } catch (InterruptedException e) {
            logger.error("Payment Service: Error during processing", e);
        }
        
        logger.info("Payment Service: Payment successful");
        return "Payment Successful";
    }
}
```

----------

### Step 3: Create Service C (Inventory Service)

#### **application.properties**

properties

```properties
spring.application.name=inventory-service
server.port=8083

spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0

logging.level.org.springframework.web=DEBUG
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]
```

#### **AppConfig.java**

java

```java
package com.example.inventoryservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### **InventoryController.java**

java

```java
package com.example.inventoryservice.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class InventoryController {
    
    private static final Logger logger = LoggerFactory.getLogger(InventoryController.class);
    
    @GetMapping("/inventory")
    public String checkInventory() {
        logger.info("Inventory Service: Checking stock");
        
        // Simulate inventory check
        try {
            Thread.sleep(80); // Simulate 80ms processing
        } catch (InterruptedException e) {
            logger.error("Inventory Service: Error during check", e);
        }
        
        logger.info("Inventory Service: Stock available");
        return "Stock Available";
    }
}
```

----------

## <a name="testing"></a>7. Testing and Visualization

### Step 1: Start All Services

bash

```bash
# Terminal 1: Start Zipkin
java -jar zipkin.jar

# Terminal 2: Start Order Service
cd order-service
mvn spring-boot:run

# Terminal 3: Start Payment Service
cd payment-service
mvn spring-boot:run

# Terminal 4: Start Inventory Service
cd inventory-service
mvn spring-boot:run
```

### Step 2: Make a Request

bash

```bash
curl http://localhost:8081/order
```

### Step 3: Check Log Files

#### **Order Service Logs:**
```
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Received order request
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Calling Payment Service
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Payment Response - Payment Successful
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Calling Inventory Service
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Inventory Response - Stock Available
INFO [order-service,a1b2c3d4e5f6g7h8,span-001] Order Service: Order completed successfully
```

**Notice:** Same TraceID `a1b2c3d4e5f6g7h8` throughout!

#### **Payment Service Logs:**
```
INFO [payment-service,a1b2c3d4e5f6g7h8,span-002] Payment Service: Processing payment
INFO [payment-service,a1b2c3d4e5f6g7h8,span-002] Payment Service: Payment successful
```

**Notice:** Same TraceID, different SpanID!

#### **Inventory Service Logs:**
```
INFO [inventory-service,a1b2c3d4e5f6g7h8,span-003] Inventory Service: Checking stock
INFO [inventory-service,a1b2c3d4e5f6g7h8,span-003] Inventory Service: Stock available
```

### Step 4: Visualize in Zipkin

1. **Open Zipkin:** `http://localhost:9411`

2. **Search for Traces:**
   - Select "order-service" from dropdown
   - Click "Run Query"

3. **What You'll See:**
```
Timeline View:
┌────────────────────────────────────────────────┐
│ order-service (300ms total)                    │
│ ├─ payment-service (150ms)                     │
│ └─ inventory-service (80ms)                    │
└────────────────────────────────────────────────┘
```

4.  **Click on a Trace** to see:
    -   Complete request flow
    -   Time spent in each service
    -   HTTP status codes
    -   Any errors or exceptions

----------

## Advanced Features

### 1. Custom Spans (Manual Instrumentation)

Sometimes you want to trace specific code blocks:

java

```java
import org.springframework.cloud.sleuth.Span;
import org.springframework.cloud.sleuth.Tracer;
import org.springframework.beans.factory.annotation.Autowired;

@RestController
public class OrderController {
    
    @Autowired
    private Tracer tracer;
    
    @GetMapping("/order")
    public String createOrder() {
        // Create custom span for database operation
        Span databaseSpan = tracer.nextSpan().name("database-query");
        try (Tracer.SpanInScope ws = tracer.withSpan(databaseSpan.start())) {
            // Your database code here
            logger.info("Executing complex database query");
            Thread.sleep(200);
        } catch (Exception e) {
            databaseSpan.error(e);
        } finally {
            databaseSpan.end();
        }
        
        return "Order completed";
    }
}
```

**Result in Zipkin:**
```
order-service
├─ database-query (200ms)  ← Your custom span!
├─ payment-service (150ms)
└─ inventory-service (80ms)
```

### 2. Adding Custom Tags

java

```java
import org.springframework.cloud.sleuth.Span;
import org.springframework.cloud.sleuth.Tracer;

@Autowired
private Tracer tracer;

public void processOrder(Order order) {
    Span span = tracer.currentSpan();
    
    // Add custom tags
    span.tag("order.id", order.getId());
    span.tag("order.amount", String.valueOf(order.getAmount()));
    span.tag("customer.id", order.getCustomerId());
    
    // Now searchable in Zipkin!
}
```

**Benefit:** Search for all traces with `order.amount > 1000`

### 3. Asynchronous Operations

java

```java
import org.springframework.scheduling.annotation.Async;
import org.springframework.cloud.sleuth.annotation.NewSpan;

@Service
public class NotificationService {
    
    @Async
    @NewSpan("send-email")  // Creates new span automatically
    public void sendEmail(String orderId) {
        logger.info("Sending email for order: {}", orderId);
        // Email sending logic
    }
}
```

---

## <a name="conclusion"></a>8. Conclusion

### What We Learned

1. **Distributed Tracing Fundamentals:**
   - TraceID links all operations for a request
   - SpanID identifies individual operations
   - Critical for debugging microservices

2. **Sleuth Benefits:**
   - ✅ Automatic trace context propagation
   - ✅ Zero-code instrumentation
   - ✅ Works with RestTemplate, Feign, WebClient

3. **Zipkin Benefits:**
   - ✅ Visual timeline of request flows
   - ✅ Identify performance bottlenecks instantly
   - ✅ Search and filter traces by service/time/tags

### Best Practices

#### **1. Sampling Strategy**
```
Development:   100% (probability=1.0)
Staging:       50%  (probability=0.5)
Production:    10%  (probability=0.1)
High-Traffic:  1%   (probability=0.01)
```

#### **2. Meaningful Log Messages**

java

```java
// ❌ Bad
logger.info("Processing");

// ✅ Good
logger.info("Processing order {} for customer {}", orderId, customerId);
```

#### **3. Production Storage**

Don't use in-memory Zipkin in production!

yaml

```yaml
# Use Elasticsearch or MySQL
STORAGE_TYPE=elasticsearch
ES_HOSTS=http://elasticsearch:9200
```

#### **4. Security Considerations**

properties

```properties
# Don't log sensitive data
logging.level.org.springframework.security=WARN

# Sanitize tags
span.tag("credit.card", maskCreditCard(cardNumber));
```

### Memory Aid: The Three Pillars
```
🏛️ DISTRIBUTED TRACING TEMPLE

Pillar 1: SLEUTH (The Tagger)
   - Adds TraceID/SpanID automatically
   - Propagates context seamlessly

Pillar 2: ZIPKIN (The Visualizer)
   - Collects and stores traces
   - Beautiful UI for analysis

Pillar 3: LOGS (The Evidence)
   - Correlated by TraceID
   - Complete audit trail
```

### Real-World Impact

**Before Distributed Tracing:**

-   🐌 6 hours average time to debug production issues
-   😰 Multiple teams involved, pointing fingers
-   💸 Lost revenue during outages

**After Distributed Tracing:**

-   ⚡ 15 minutes average time to debug
-   🎯 Pinpoint exact service/operation causing issues
-   💰 Faster resolution = happy customers

### Next Steps

1.  **Experiment:** Build the example and break things intentionally
2.  **Explore:** Try adding delays, errors, and see them in Zipkin
3.  **Extend:** Add custom spans for critical business logic
4.  **Production:** Start with 10% sampling and scale up monitoring

### Resources

-   **Zipkin Documentation:** [https://zipkin.io](https://zipkin.io)
-   **Spring Cloud Sleuth:** [https://spring.io/projects/spring-cloud-sleuth](https://spring.io/projects/spring-cloud-sleuth)
-   **OpenTelemetry:** [https://opentelemetry.io](https://opentelemetry.io) (Next-gen standard)

----------

**Remember:** Distributed tracing is like having X-ray vision for your microservices. Once you start using it, you'll wonder how you ever lived without it! 🔍✨
