# Fault Tolerance in Microservices using Resilience4j: A Complete Guide

## What is Fault Tolerance in Microservices?

**Fault Tolerance** is the ability of a system to continue operating correctly even when some of its components fail. In microservices architecture, where multiple services communicate over a network, failures are inevitable.

### Real-World Analogy

Think of a **traffic system in a city**:

-   If one road is blocked (service down), traffic is rerouted through alternate roads (fallback mechanism)
-   Traffic lights control the flow to prevent congestion (rate limiting)
-   During peak hours, some routes have restrictions (circuit breaker)
-   Emergency vehicles get priority lanes (bulkhead)

### Why Fault Tolerance Matters?

**Real-World Case Study: The 2021 Facebook Outage**

-   Facebook, Instagram, and WhatsApp went down for 6+ hours
-   A configuration change caused cascading failures
-   Services couldn't reach each other, causing a complete shutdown
-   **Impact**: $60+ million in lost revenue, millions of affected users

**Key Lesson**: Without fault tolerance mechanisms, a single failure point can bring down an entire ecosystem.

----------

## Core Modules of Resilience4j

Resilience4j is a lightweight fault tolerance library inspired by Netflix Hystrix. It provides several modules:
<img width="911" height="243" alt="image" src="https://github.com/user-attachments/assets/7dec9420-60d0-4e82-b558-c0aeb215f5c9" />


### Memory Visualization

```
┌─────────────────────────────────────────┐
│        YOUR MICROSERVICE                │
│                                         │
│  ┌──────────┐  ┌──────────┐           │
│  │ Rate     │  │ Circuit  │           │
│  │ Limiter  │→ │ Breaker  │→ [API]   │
│  └──────────┘  └──────────┘     ↓     │
│                               ┌────┐   │
│  ┌──────────┐  ┌──────────┐  │Bulk│   │
│  │ Retry    │  │ Time     │  │head│   │
│  │          │  │ Limiter  │  └────┘   │
│  └──────────┘  └──────────┘           │
└─────────────────────────────────────────┘
```

----------

## Common Setup for All Examples

### Prerequisites

-   Java 11 or higher
-   Spring Boot 3.x
-   Maven or Gradle
-   Spring Tool Suite (STS) or IntelliJ IDEA

----------

## Create a Spring Boot Project

### Step 1: Create Project Structure

**Using Spring Initializr (start.spring.io)**

-   **Project**: Maven
-   **Language**: Java
-   **Spring Boot**: 3.2.0
-   **Group**: com.example
-   **Artifact**: resilience4j-demo
-   **Package**: com.example.resilience

### Step 2: Add Dependencies

**pom.xml**

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>resilience4j-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>resilience4j-demo</name>
    <description>Fault Tolerance with Resilience4j</description>
    
    <properties>
        <java.version>17</java.version>
        <resilience4j.version>2.1.0</resilience4j.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot AOP (Required for Resilience4j annotations) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        
        <!-- Spring Boot Actuator (For monitoring) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Resilience4j Spring Boot 3 Starter -->
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-spring-boot3</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <!-- Individual Resilience4j modules -->
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-circuitbreaker</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-ratelimiter</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-retry</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-bulkhead</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <dependency>
            <groupId>io.github.resilience4j</groupId>
            <artifactId>resilience4j-timelimiter</artifactId>
            <version>${resilience4j.version}</version>
        </dependency>
        
        <!-- Lombok (Optional, for cleaner code) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### Step 3: Main Application Class

java

```java
package com.example.resilience;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Resilience4jDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(Resilience4jDemoApplication.class, args);
    }
}
```

---

## 1. Rate Limiter

### What is Rate Limiting?

**Definition**: Rate Limiting restricts the number of requests a service can handle within a specific time window.

### Real-World Analogy
Imagine a **bank ATM**:
- Only allows 5 transactions per minute per card
- If you try a 6th transaction, you get "Please wait" message
- After a minute, you can try again

### Real-World Case Study: Twitter API Rate Limiting
- Twitter allows 900 requests per 15-minute window for authenticated users
- Exceeding this returns HTTP 429 (Too Many Requests)
- **Purpose**: Prevents abuse, ensures fair usage, protects server resources

### When to Use Rate Limiting?
- ✅ Protecting APIs from overload
- ✅ Preventing DDoS attacks
- ✅ Ensuring fair usage among clients
- ✅ Controlling costs (e.g., paid third-party API calls)

### Memory Visualization
```
Time Window: 10 seconds
Max Requests: 3

Request 1 → ✓ Allowed (1/3)
Request 2 → ✓ Allowed (2/3)
Request 3 → ✓ Allowed (3/3)
Request 4 → ✗ REJECTED! (Rate limit exceeded)
[Wait 10 seconds]
Request 5 → ✓ Allowed (1/3)
```

----------

## Rate Limiting Example

### Step 1: Common Setup (Already Done Above)

### Step 2: Create RestController with RateLimiter

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;

@RestController
@RequestMapping("/api")
public class RateLimiterController {
    
    private int attempt = 0;
    
    /**
     * This endpoint is protected by RateLimiter
     * Configuration name: "basicRateLimiter" (defined in application.properties)
     */
    @GetMapping("/rate-limiter")
    @RateLimiter(name = "basicRateLimiter", fallbackMethod = "rateLimiterFallback")
    public String rateLimiterDemo() {
        attempt++;
        return String.format("Success! Attempt: %d, Time: %s", 
                           attempt, LocalDateTime.now());
    }
    
    /**
     * Fallback method when rate limit is exceeded
     * Must have the same return type and parameters as the original method
     * Plus an additional Exception parameter
     */
    public String rateLimiterFallback(Exception ex) {
        return "Rate limit exceeded! Too many requests. Please try after some time. " +
               "Error: " + ex.getMessage();
    }
    
    /**
     * Another example: API to fetch user details
     */
    @GetMapping("/users")
    @RateLimiter(name = "userServiceRateLimiter", fallbackMethod = "userServiceFallback")
    public String getUserDetails() {
        // Simulate fetching user data from database
        return "User Details: { id: 123, name: 'John Doe', email: 'john@example.com' }";
    }
    
    public String userServiceFallback(Exception ex) {
        return "User service is busy. Please try again later.";
    }
}
```

### Step 3: Update application.properties

properties

```properties
# Application Configuration
spring.application.name=resilience4j-demo
server.port=8080

# =====================================================
# RATE LIMITER CONFIGURATIONS
# =====================================================

# Basic Rate Limiter Configuration
# Allows 3 requests per 10-second window
resilience4j.ratelimiter.instances.basicRateLimiter.limit-for-period=3
resilience4j.ratelimiter.instances.basicRateLimiter.limit-refresh-period=10s
resilience4j.ratelimiter.instances.basicRateLimiter.timeout-duration=0s
resilience4j.ratelimiter.instances.basicRateLimiter.allow-health-indicator-to-fail=true
resilience4j.ratelimiter.instances.basicRateLimiter.subscribe-for-events=true
resilience4j.ratelimiter.instances.basicRateLimiter.register-health-indicator=true

# User Service Rate Limiter Configuration
# More restrictive: 2 requests per 5 seconds
resilience4j.ratelimiter.instances.userServiceRateLimiter.limit-for-period=2
resilience4j.ratelimiter.instances.userServiceRateLimiter.limit-refresh-period=5s
resilience4j.ratelimiter.instances.userServiceRateLimiter.timeout-duration=0s

# Actuator endpoints for monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus
management.endpoint.health.show-details=always
management.health.ratelimiters.enabled=true
```

### Configuration Parameters Explained
<img width="911" height="257" alt="image" src="https://github.com/user-attachments/assets/8c056fea-0b74-4139-8e89-ccfcdf2cece8" />
### Step 4: How to Test the RateLimiter?

#### Method 1: Using Browser

1.  Open browser and navigate to: `http://localhost:8080/api/rate-limiter`
2.  Refresh quickly 3 times → You'll see success
3.  Refresh 4th time → You'll see rate limit error
4.  Wait 10 seconds and try again → Works again

#### Method 2: Using cURL (Command Line)

bash

```bash
# Test basic rate limiter (3 requests allowed)
curl http://localhost:8080/api/rate-limiter
curl http://localhost:8080/api/rate-limiter
curl http://localhost:8080/api/rate-limiter
curl http://localhost:8080/api/rate-limiter  # This will be rejected

# Test user service rate limiter (2 requests allowed)
curl http://localhost:8080/api/users
curl http://localhost:8080/api/users
curl http://localhost:8080/api/users  # This will be rejected
```

#### Method 3: Using Postman

1.  Create a new GET request to `http://localhost:8080/api/rate-limiter`
2.  Click "Send" button 3 times rapidly
3.  4th request will return the fallback message

#### Method 4: Automated Testing Script

bash

```bash
#!/bin/bash
# Save as test-rate-limiter.sh

echo "Testing Rate Limiter..."
for i in {1..5}
do
  echo "Request $i:"
  curl -s http://localhost:8080/api/rate-limiter
  echo -e "\n"
  sleep 1
done
```

#### Expected Output

**First 3 Requests:**
```
Success! Attempt: 1, Time: 2024-10-31T10:30:45
Success! Attempt: 2, Time: 2024-10-31T10:30:46
Success! Attempt: 3, Time: 2024-10-31T10:30:47
```

**4th Request:**
```
Rate limit exceeded! Too many requests. Please try after some time. 
Error: RateLimiter 'basicRateLimiter' does not permit further calls
```

---

## 2. Retry

### What is Retry?

**Definition**: Retry mechanism automatically retries failed operations a certain number of times before giving up.

### Real-World Analogy
Think of **calling a friend whose phone is busy**:
- 1st attempt: Busy tone
- Wait 5 seconds
- 2nd attempt: Busy tone
- Wait 5 seconds
- 3rd attempt: Connected!

### Real-World Case Study: AWS S3 SDK
- AWS SDK has built-in retry logic
- By default, retries 3 times with exponential backoff
- **Scenario**: Network glitch causes S3 upload to fail
- Instead of failing immediately, SDK retries automatically
- **Result**: Improved reliability without code changes

### When to Use Retry?
- ✅ Transient network failures
- ✅ Temporary service unavailability
- ✅ Database deadlocks
- ✅ External API timeouts
- ❌ **Don't use for**: Business logic errors, authentication failures, invalid input

### Memory Visualization
```
Attempt 1 → ✗ FAILED (Wait 1s)
Attempt 2 → ✗ FAILED (Wait 2s - exponential backoff)
Attempt 3 → ✓ SUCCESS! Return result

If all 3 fail → Call fallback method
```

----------

## Retry Example

### Step 1: Common Setup (Already Done)

### Step 2: Create RestController with Retry

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.retry.annotation.Retry;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.Random;

@RestController
@RequestMapping("/api")
public class RetryController {
    
    private int attempt = 0;
    private Random random = new Random();
    
    /**
     * This endpoint demonstrates Retry mechanism
     * It randomly fails to simulate transient errors
     */
    @GetMapping("/retry")
    @Retry(name = "basicRetry", fallbackMethod = "retryFallback")
    public String retryDemo() {
        attempt++;
        System.out.println("Attempt: " + attempt + " at " + LocalDateTime.now());
        
        // Simulate random failure (70% failure rate)
        if (random.nextInt(10) < 7) {
            System.out.println("Attempt " + attempt + " failed!");
            throw new RuntimeException("Service temporarily unavailable");
        }
        
        System.out.println("Attempt " + attempt + " succeeded!");
        String response = String.format("Success after %d attempts at %s", 
                                      attempt, LocalDateTime.now());
        attempt = 0; // Reset for next call
        return response;
    }
    
    /**
     * Fallback method when all retry attempts fail
     */
    public String retryFallback(Exception ex) {
        System.out.println("All retry attempts failed. Calling fallback.");
        attempt = 0; // Reset counter
        return "Service is currently unavailable after multiple retry attempts. " +
               "Please try again later. Error: " + ex.getMessage();
    }
    
    /**
     * Example: External payment service with retry
     */
    @GetMapping("/payment")
    @Retry(name = "paymentRetry", fallbackMethod = "paymentFallback")
    public String processPayment() {
        System.out.println("Processing payment... " + LocalDateTime.now());
        
        // Simulate payment gateway timeout
        if (random.nextBoolean()) {
            throw new RuntimeException("Payment gateway timeout");
        }
        
        return "Payment processed successfully!";
    }
    
    public String paymentFallback(Exception ex) {
        return "Payment failed after retries. Transaction rolled back. " +
               "Please try again or contact support.";
    }
    
    /**
     * Example: Database operation with retry
     */
    @GetMapping("/database")
    @Retry(name = "databaseRetry", fallbackMethod = "databaseFallback")
    public String fetchFromDatabase() {
        System.out.println("Querying database... " + LocalDateTime.now());
        
        // Simulate database deadlock
        if (random.nextInt(10) < 5) {
            throw new RuntimeException("Database deadlock detected");
        }
        
        return "Database query executed successfully!";
    }
    
    public String databaseFallback(Exception ex) {
        return "Database operation failed. Using cached data instead.";
    }
}
```

### Step 3: Update application.properties

properties

```properties
# =====================================================
# RETRY CONFIGURATIONS
# =====================================================

# Basic Retry Configuration
# Retries 3 times with 2-second wait between attempts
resilience4j.retry.instances.basicRetry.max-attempts=3
resilience4j.retry.instances.basicRetry.wait-duration=2s
resilience4j.retry.instances.basicRetry.enable-exponential-backoff=false
resilience4j.retry.instances.basicRetry.retry-exceptions=java.lang.RuntimeException
resilience4j.retry.instances.basicRetry.ignore-exceptions=java.lang.NullPointerException

# Payment Service Retry Configuration
# Exponential backoff: 1s, 2s, 4s
resilience4j.retry.instances.paymentRetry.max-attempts=3
resilience4j.retry.instances.paymentRetry.wait-duration=1s
resilience4j.retry.instances.paymentRetry.enable-exponential-backoff=true
resilience4j.retry.instances.paymentRetry.exponential-backoff-multiplier=2

# Database Retry Configuration
# More aggressive: 5 attempts with 500ms wait
resilience4j.retry.instances.databaseRetry.max-attempts=5
resilience4j.retry.instances.databaseRetry.wait-duration=500ms
resilience4j.retry.instances.databaseRetry.enable-exponential-backoff=false
```

### Configuration Parameters Explained
<img width="922" height="365" alt="image" src="https://github.com/user-attachments/assets/94ad1eda-882e-442e-9ed3-e62c19dec2dc" />



### Step 4: How to Test the Retry?

#### Method 1: Watch Console Logs

bash

```bash
# Start the application and watch the console
# You'll see retry attempts being logged

curl http://localhost:8080/api/retry
```

**Console Output:**
```
Attempt: 1 at 2024-10-31T10:45:30
Attempt 1 failed!
Attempt: 2 at 2024-10-31T10:45:32
Attempt 2 failed!
Attempt: 3 at 2024-10-31T10:45:34
Attempt 3 succeeded!
```

#### Method 2: Test All Retry Scenarios

bash

```bash
# Test basic retry
curl http://localhost:8080/api/retry

# Test payment retry with exponential backoff
curl http://localhost:8080/api/payment

# Test database retry
curl http://localhost:8080/api/database
```

#### Method 3: Load Testing Script

bash

```bash
#!/bin/bash
# Save as test-retry.sh

echo "Testing Retry Mechanism..."
for i in {1..10}
do
  echo "=== Test Run $i ==="
  curl -s http://localhost:8080/api/retry
  echo -e "\n"
  sleep 5
done
```

---

## 3. Circuit Breaker

### What is Circuit Breaker?

**Definition**: Circuit Breaker prevents cascading failures by temporarily blocking calls to a failing service, giving it time to recover.

### Real-World Analogy
Think of an **electrical circuit breaker in your home**:
- Normal operation: Electricity flows (CLOSED state)
- Electrical overload detected: Breaker trips (OPEN state)
- No electricity flows, preventing fire
- After cooling down: You can manually reset it (HALF-OPEN state)
- If stable: Breaker stays closed; if still faulty: Opens again

### Circuit Breaker States
```
┌─────────────────────────────────────────────┐
│                                             │
│  CLOSED (Normal Operation)                  │
│  ✓ Requests flow through                    │
│  ✓ Monitors failure rate                    │
│                                             │
└────────────┬────────────────────────────────┘
             │ Failure threshold reached
             │ (e.g., 50% failures)
             ↓
┌─────────────────────────────────────────────┐
│                                             │
│  OPEN (Service Down)                        │
│  ✗ All requests rejected immediately        │
│  ✗ Fallback method called                   │
│  ⏰ Wait for timeout period                 │
│                                             │
└────────────┬────────────────────────────────┘
             │ Timeout elapsed
             │ (e.g., 60 seconds)
             ↓
┌─────────────────────────────────────────────┐
│                                             │
│  HALF-OPEN (Testing Recovery)               │
│  🔍 Limited requests allowed                │
│  🔍 Testing if service recovered            │
│                                             │
└─────┬───────────────────────┬───────────────┘
      │ Success               │ Still failing
      ↓                       ↓
   CLOSED                   OPEN
```

### Real-World Case Study: Netflix API Gateway

**Scenario**: Movie recommendation service goes down

**Without Circuit Breaker:**

-   Every request waits for timeout (e.g., 30 seconds)
-   Threads pile up waiting
-   Memory exhausted
-   Entire application crashes (cascading failure)

**With Circuit Breaker:**

-   After detecting failures, circuit opens
-   Requests fail fast (milliseconds, not seconds)
-   Application remains responsive
-   Recommendation service gets time to recover
-   **Result**: Users see cached recommendations instead of crashing

### When to Use Circuit Breaker?

✅ **Use When:**

-   Calling external services (APIs, databases, microservices)
-   Service has known reliability issues
-   Need to prevent cascading failures
-   Want graceful degradation

❌ **Don't Use For:**

-   Internal method calls within same application
-   Operations that must always complete
-   Critical transactions (use retry instead)

----------

## Circuit Breaker Example

### Step 1: Common Setup (Already Done)

### Step 2: Create RestController with Circuit Breaker

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.Random;

@RestController
@RequestMapping("/api")
public class CircuitBreakerController {
    
    private Random random = new Random();
    private int callCount = 0;
    
    /**
     * This endpoint demonstrates Circuit Breaker
     * It simulates an unreliable external service
     */
    @GetMapping("/circuit-breaker")
    @CircuitBreaker(name = "basicCircuitBreaker", fallbackMethod = "circuitBreakerFallback")
    public String circuitBreakerDemo() {
        callCount++;
        System.out.println("Call #" + callCount + " at " + LocalDateTime.now());
        
        // Simulate 60% failure rate to trigger circuit breaker
        if (random.nextInt(10) < 6) {
            System.out.println("Call #" + callCount + " failed!");
            throw new RuntimeException("External service failed");
        }
        
        System.out.println("Call #" + callCount + " succeeded!");
        return String.format("Success! Call #%d at %s", callCount, LocalDateTime.now());
    }
    
    /**
     * Fallback method when circuit is OPEN
     * This provides graceful degradation
     */
    public String circuitBreakerFallback(Exception ex) {
        System.out.println("Circuit is OPEN. Returning fallback response.");
        return "Service is temporarily unavailable. Showing cached data instead. " +
               "Circuit Breaker is OPEN to protect the system.";
    }
    
    /**
     * Example: Weather service with circuit breaker
     */
    @GetMapping("/weather")
    @CircuitBreaker(name = "weatherService", fallbackMethod = "weatherFallback")
    public String getWeather() {
        System.out.println("Fetching weather data...");
        
        // Simulate weather API failures
        if (random.nextInt(10) < 5) {
            throw new RuntimeException("Weather API timeout");
        }
        
        return "Weather: Sunny, 25°C";
    }
    
    public String weatherFallback(Exception ex) {
        return "Weather service unavailable. Last known: Sunny, 24°C (1 hour ago)";
    }
    
    /**
     * Example: Stock price service
     */
    @GetMapping("/stock-price")
    @CircuitBreaker(name = "stockService", fallbackMethod = "stockFallback")
    public String getStockPrice() {
        System.out.println("Fetching stock price...");
        
        // Simulate stock API failures
        if (random.nextInt(10) < 7) {
            throw new RuntimeException("Stock API error");
        }
        
        return "AAPL: $175.43 (+2.5%)";
    }
    
    public String stockFallback(Exception ex) {
        return "Stock price service unavailable. Last known: AAPL: $173.20 (15 mins ago)";
    }
    
    /**
     * Health check endpoint to monitor circuit state
     */
    @GetMapping("/circuit-health")
    public String getCircuitHealth() {
        return "Check circuit breaker health at: " +
               "http://localhost:8080/actuator/health";
    }
}
```

### Step 3: Update application.properties

properties

```properties
# =====================================================
# CIRCUIT BREAKER CONFIGURATIONS
# =====================================================

# Basic Circuit Breaker Configuration
# Opens after 50% failure rate in a sliding window of 10 calls
resilience4j.circuitbreaker.instances.basicCircuitBreaker.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.basicCircuitBreaker.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.basicCircuitBreaker.sliding-window-size=10
resilience4j.circuitbreaker.instances.basicCircuitBreaker.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.basicCircuitBreaker.wait-duration-in-open-state=10s
resilience4j.circuitbreaker.instances.basicCircuitBreaker.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.basicCircuitBreaker.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.basicCircuitBreaker.register-health-indicator=true
resilience4j.circuitbreaker.instances.basicCircuitBreaker.record-exceptions=java.lang.RuntimeException

# Weather Service Circuit Breaker
# More lenient: 60% failure threshold
resilience4j.circuitbreaker.instances.weatherService.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.weatherService.sliding-window-size=10
resilience4j.circuitbreaker.instances.weatherService.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.weatherService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.weatherService.permitted-number-of-calls-in-half-open-state=5

# Stock Service Circuit Breaker
# Strict: 40% failure threshold, longer open time
resilience4j.circuitbreaker.instances.stockService.failure-rate
```


properties

```properties
# Stock Service Circuit Breaker (continued)
# Strict: 40% failure threshold, longer open time
resilience4j.circuitbreaker.instances.stockService.failure-rate-threshold=40
resilience4j.circuitbreaker.instances.stockService.sliding-window-size=20
resilience4j.circuitbreaker.instances.stockService.minimum-number-of-calls=10
resilience4j.circuitbreaker.instances.stockService.wait-duration-in-open-state=60s
resilience4j.circuitbreaker.instances.stockService.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.stockService.automatic-transition-from-open-to-half-open-enabled=true

# Enable Circuit Breaker health indicators
management.health.circuitbreakers.enabled=true
```

### Configuration Parameters Explained

| Parameter | Description | Example Value | Impact |
|-----------|-------------|---------------|---------|
| `failure-rate-threshold` | Percentage of failures to open circuit | 50 | Circuit opens at 50% failures |
| `sliding-window-type` | Type of window for measurement | COUNT_BASED or TIME_BASED | How failures are tracked |
| `sliding-window-size` | Number of calls or time window | 10 calls or 10s | Sample size for calculation |
| `minimum-number-of-calls` | Min calls before circuit can open | 5 | Prevents premature opening |
| `wait-duration-in-open-state` | Time circuit stays open | 10s | Recovery time |
| `permitted-number-of-calls-in-half-open-state` | Test calls in half-open | 3 | Verification before closing |
| `automatic-transition-from-open-to-half-open-enabled` | Auto transition to half-open | true | No manual intervention needed |

### Visual Timeline Example
```
Time: 0s - Circuit: CLOSED
├─ Call 1: ✓ Success (1/10)
├─ Call 2: ✗ Failed (2/10)
├─ Call 3: ✗ Failed (3/10)
├─ Call 4: ✗ Failed (4/10)
├─ Call 5: ✗ Failed (5/10) → 80% failure rate
│  
Time: 1s - Circuit: OPEN (threshold exceeded!)
├─ Call 6: ⚡ Rejected immediately (fallback)
├─ Call 7: ⚡ Rejected immediately (fallback)
├─ Call 8: ⚡ Rejected immediately (fallback)
│  
Time: 11s - Circuit: HALF-OPEN (wait duration elapsed)
├─ Call 9: ✓ Success (1/3 test calls)
├─ Call 10: ✓ Success (2/3 test calls)
├─ Call 11: ✓ Success (3/3 test calls)
│  
Time: 12s - Circuit: CLOSED (service recovered!)
└─ Normal operation resumes
```

### Step 4: How to Test Circuit Breaker?

#### Method 1: Manual Testing with cURL

bash

```bash
# Test 1: Make multiple calls to trigger circuit breaker
echo "Making 15 calls to trigger circuit breaker..."
for i in {1..15}
do
  echo "Call $i:"
  curl -s http://localhost:8080/api/circuit-breaker
  echo -e "\n"
  sleep 1
done

# After circuit opens, you'll see fallback responses

# Test 2: Wait for circuit to move to HALF-OPEN
echo "Waiting 10 seconds for circuit to enter HALF-OPEN state..."
sleep 10

# Test 3: Make test calls
echo "Making test calls in HALF-OPEN state..."
for i in {1..5}
do
  echo "Test call $i:"
  curl -s http://localhost:8080/api/circuit-breaker
  echo -e "\n"
  sleep 1
done
```

#### Method 2: Monitor Circuit State via Actuator

bash

```bash
# Check overall health
curl http://localhost:8080/actuator/health | json_pp

# Check specific circuit breaker metrics
curl http://localhost:8080/actuator/metrics/resilience4j.circuitbreaker.calls

# Check circuit breaker state
curl http://localhost:8080/actuator/circuitbreakers
```

**Example Health Response:**

json

```json
{
  "status": "UP",
  "components": {
    "circuitBreakers": {
      "status": "UP",
      "details": {
        "basicCircuitBreaker": {
          "status": "UP",
          "details": {
            "state": "CLOSED",
            "failureRate": "20.0%",
            "slowCallRate": "0.0%",
            "bufferedCalls": 10,
            "failedCalls": 2,
            "slowCalls": 0,
            "notPermittedCalls": 0
          }
        }
      }
    }
  }
}
```

#### Method 3: Advanced Testing Script

bash

```bash
#!/bin/bash
# Save as test-circuit-breaker.sh

BASE_URL="http://localhost:8080/api/circuit-breaker"
HEALTH_URL="http://localhost:8080/actuator/health"

echo "=== Circuit Breaker Test Suite ==="
echo ""

# Function to get circuit state
get_circuit_state() {
  curl -s $HEALTH_URL | grep -o '"state":"[^"]*"' | cut -d'"' -f4
}

# Phase 1: Trigger circuit opening
echo "Phase 1: Making calls to trigger circuit breaker..."
for i in {1..15}
do
  response=$(curl -s $BASE_URL)
  state=$(get_circuit_state)
  echo "Call $i - Circuit State: $state"
  
  if [[ $response == *"Circuit Breaker is OPEN"* ]]; then
    echo "✓ Circuit opened after $i calls!"
    break
  fi
  sleep 0.5
done

echo ""
echo "Phase 2: Testing OPEN state (all calls should be rejected)..."
for i in {1..5}
do
  response=$(curl -s $BASE_URL)
  if [[ $response == *"cached data"* ]]; then
    echo "✓ Call $i: Correctly rejected with fallback"
  fi
  sleep 1
done

echo ""
echo "Phase 3: Waiting for HALF-OPEN state (10 seconds)..."
sleep 10

echo ""
echo "Phase 4: Testing HALF-OPEN state..."
for i in {1..5}
do
  state=$(get_circuit_state)
  response=$(curl -s $BASE_URL)
  echo "Test call $i - Circuit State: $state"
  sleep 1
done

echo ""
echo "Final circuit state: $(get_circuit_state)"
echo "=== Test Complete ==="
```

#### Method 4: Using Postman Collection

Create a Postman collection with these requests:

1. **Trigger Circuit Breaker**
   - Method: GET
   - URL: `http://localhost:8080/api/circuit-breaker`
   - Tests: Run 15 times with 1-second delay

2. **Check Health**
   - Method: GET
   - URL: `http://localhost:8080/actuator/health`

3. **Weather Service**
   - Method: GET
   - URL: `http://localhost:8080/api/weather`

4. **Stock Price Service**
   - Method: GET
   - URL: `http://localhost:8080/api/stock-price`

---

## 4. Bulkhead

### What is Bulkhead?

**Definition**: Bulkhead isolates resources to prevent one failing component from consuming all available resources and bringing down the entire system.

### Real-World Analogy

Think of a **ship's bulkhead compartments**:
- A ship is divided into watertight compartments
- If one compartment floods (leak), only that section fills with water
- Other compartments remain dry
- Ship stays afloat even with one damaged section
```
┌─────────────────────────────────────┐
│           SHIP (Your App)           │
├──────────┬──────────┬───────────────┤
│ Cabin 1  │ Cabin 2  │ Cabin 3      │
│ (Users)  │ (Orders) │ (Payments)   │
│   🚢     │   🚢     │   🚢         │
│          │          │              │
│  💧💧💧  │          │              │
│  FLOODED │  SAFE    │   SAFE       │
└──────────┴──────────┴───────────────┘
```

### Real-World Case Study: Amazon Prime Day 2018

**Problem**:

-   One AWS service experienced high load
-   Consumed all thread pools
-   Other services couldn't get threads
-   Cascading failure affected entire platform

**Solution with Bulkhead**:

-   Each service gets dedicated thread pool
-   Recommendation service overload → Only its threads affected
-   Checkout, cart, search services remain operational
-   **Result**: Partial degradation instead of complete outage

### Types of Bulkhead

1.  **Semaphore-based** (Lightweight)
    -   Uses semaphores to limit concurrent calls
    -   No separate thread pool
    -   Fast but less isolation
2.  **Thread Pool-based** (Strong Isolation)
    -   Dedicated thread pool for each service
    -   Complete isolation
    -   More overhead but better protection

### When to Use Bulkhead?

✅ **Use When:**

-   Calling multiple external services
-   Need to prevent resource starvation
-   Want to isolate critical from non-critical operations
-   Different services have different performance characteristics

❌ **Don't Use For:**

-   Single service applications
-   Operations that don't block threads
-   When thread overhead is too expensive

----------

## Bulkhead Example

### Step 1: Common Setup (Already Done)

### Step 2: Create RestController with Bulkhead

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.bulkhead.annotation.Bulkhead;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicInteger;

@RestController
@RequestMapping("/api")
public class BulkheadController {
    
    private AtomicInteger userServiceCalls = new AtomicInteger(0);
    private AtomicInteger orderServiceCalls = new AtomicInteger(0);
    
    /**
     * User Service with Bulkhead Protection
     * Maximum 3 concurrent calls allowed
     */
    @GetMapping("/user-service")
    @Bulkhead(name = "userServiceBulkhead", fallbackMethod = "userServiceFallback", type = Bulkhead.Type.SEMAPHORE)
    public String getUserService() throws InterruptedException {
        int callNumber = userServiceCalls.incrementAndGet();
        System.out.println("User Service - Call #" + callNumber + 
                         " started at " + LocalDateTime.now());
        
        // Simulate long-running operation (5 seconds)
        Thread.sleep(5000);
        
        System.out.println("User Service - Call #" + callNumber + 
                         " completed at " + LocalDateTime.now());
        return String.format("User Service Response - Call #%d completed successfully", 
                           callNumber);
    }
    
    /**
     * Fallback when User Service bulkhead is full
     */
    public String userServiceFallback(Exception ex) {
        return "User Service is busy. Maximum concurrent requests reached. " +
               "Please try again later. (Bulkhead Protection Active)";
    }
    
    /**
     * Order Service with Bulkhead Protection
     * Maximum 5 concurrent calls allowed
     */
    @GetMapping("/order-service")
    @Bulkhead(name = "orderServiceBulkhead", fallbackMethod = "orderServiceFallback", type = Bulkhead.Type.SEMAPHORE)
    public String getOrderService() throws InterruptedException {
        int callNumber = orderServiceCalls.incrementAndGet();
        System.out.println("Order Service - Call #" + callNumber + 
                         " started at " + LocalDateTime.now());
        
        // Simulate processing (3 seconds)
        Thread.sleep(3000);
        
        System.out.println("Order Service - Call #" + callNumber + 
                         " completed at " + LocalDateTime.now());
        return String.format("Order Service Response - Call #%d completed successfully", 
                           callNumber);
    }
    
    public String orderServiceFallback(Exception ex) {
        return "Order Service is at capacity. Please try again in a moment.";
    }
    
    /**
     * Thread Pool Bulkhead Example
     * Uses dedicated thread pool with max 3 threads
     */
    @GetMapping("/payment-service")
    @Bulkhead(name = "paymentServiceBulkhead", fallbackMethod = "paymentServiceFallback", type = Bulkhead.Type.THREADPOOL)
    public String getPaymentService() throws InterruptedException {
        System.out.println("Payment Service - Thread: " + 
                         Thread.currentThread().getName() + 
                         " at " + LocalDateTime.now());
        
        // Simulate payment processing (4 seconds)
        Thread.sleep(4000);
        
        return "Payment processed successfully in thread: " + 
               Thread.currentThread().getName();
    }
    
    public String paymentServiceFallback(Exception ex) {
        return "Payment service thread pool full. Transaction queued for later processing.";
    }
    
    /**
     * Critical service with tight bulkhead (only 2 concurrent)
     */
    @GetMapping("/critical-service")
    @Bulkhead(name = "criticalServiceBulkhead", fallbackMethod = "criticalServiceFallback")
    public String getCriticalService() throws InterruptedException {
        System.out.println("Critical Service - Processing at " + LocalDateTime.now());
        Thread.sleep(6000);
        return "Critical operation completed successfully";
    }
    
    public String criticalServiceFallback(Exception ex) {
        return "Critical service protecting resources. Request rejected to maintain system stability.";
    }
    
    /**
     * Status endpoint to show current system load
     */
    @GetMapping("/bulkhead-status")
    public String getBulkheadStatus() {
        return String.format(
            "System Status:\n" +
            "- User Service Calls: %d\n" +
            "- Order Service Calls: %d\n" +
            "- Check detailed metrics at: /actuator/metrics/resilience4j.bulkhead.available.concurrent.calls",
            userServiceCalls.get(),
            orderServiceCalls.get()
        );
    }
}
```

### Step 3: Update application.properties

properties

```properties
# =====================================================
# BULKHEAD CONFIGURATIONS
# =====================================================

# User Service Bulkhead (Semaphore-based)
# Allows maximum 3 concurrent calls
resilience4j.bulkhead.instances.userServiceBulkhead.max-concurrent-calls=3
resilience4j.bulkhead.instances.userServiceBulkhead.max-wait-duration=0ms

# Order Service Bulkhead (Semaphore-based)
# More permissive: 5 concurrent calls
resilience4j.bulkhead.instances.orderServiceBulkhead.max-concurrent-calls=5
resilience4j.bulkhead.instances.orderServiceBulkhead.max-wait-duration=0ms

# Payment Service Bulkhead (Thread Pool-based)
# Dedicated thread pool with 3 core threads
resilience4j.thread-pool-bulkhead.instances.paymentServiceBulkhead.max-thread-pool-size=3
resilience4j.thread-pool-bulkhead.instances.paymentServiceBulkhead.core-thread-pool-size=2
resilience4j.thread-pool-bulkhead.instances.paymentServiceBulkhead.queue-capacity=5
resilience4j.thread-pool-bulkhead.instances.paymentServiceBulkhead.keep-alive-duration=20ms

# Critical Service Bulkhead
# Very restrictive: only 2 concurrent calls
resilience4j.bulkhead.instances.criticalServiceBulkhead.max-concurrent-calls=2
resilience4j.bulkhead.instances.criticalServiceBulkhead.max-wait-duration=100ms

# Enable Bulkhead health indicators
management.health.bulkheads.enabled=true
```

### Configuration Parameters Explained

| Parameter | Description | Example Value | Type |
|-----------|-------------|---------------|------|
| `max-concurrent-calls` | Maximum parallel requests | 3 | Semaphore |
| `max-wait-duration` | Max time to wait for permission | 0ms (no wait) | Semaphore |
| `max-thread-pool-size` | Maximum threads in pool | 3 | Thread Pool |
| `core-thread-pool-size` | Minimum active threads | 2 | Thread Pool |
| `queue-capacity` | Queue size for waiting requests | 5 | Thread Pool |
| `keep-alive-duration` | Idle thread timeout | 20ms | Thread Pool |

### Visual Comparison: Semaphore vs Thread Pool
```
SEMAPHORE BULKHEAD (Lightweight)
┌─────────────────────────────────┐
│   Request Thread Pool (Tomcat)  │
│   ┌───┐ ┌───┐ ┌───┐ ┌───┐      │
│   │ R1│ │ R2│ │ R3│ │ R4│      │
│   └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘      │
│     │     │     │     │         │
│   ┌─▼─────▼─────▼─────▼───┐    │
│   │  Semaphore (limit=3)  │    │
│   │  ✓ ✓ ✓ ✗             │    │
│   └───────────────────────┘    │
└─────────────────────────────────┘

THREAD POOL BULKHEAD (Strong Isolation)
┌─────────────────────────────────┐
│   Request Thread Pool (Tomcat)  │
│   ┌───┐ ┌───┐ ┌───┐            │
│   │ R1│ │ R2│ │ R3│            │
│   └─┬─┘ └─┬─┘ └─┬─┘            │
│     │     │     │               │
│   ┌─▼─────▼─────▼──────────┐   │
│   │   Task Queue (size=5)  │   │
│   └────────┬───────────────┘   │
│            │                    │
│   ┌────────▼───────────────┐   │
│   │ Dedicated Thread Pool  │   │
│   │  ┌───┐ ┌───┐ ┌───┐    │   │
│   │  │ T1│ │ T2│ │ T3│    │   │
│   │  └───┘ └───┘ └───┘    │   │
│   └────────────────────────┘   │
└─────────────────────────────────┘
```

### Step 4: How to Test Bulkhead?

#### Method 1: Concurrent Testing with Multiple Terminals

**Terminal 1:**

bash

```bash
curl http://localhost:8080/api/user-service
```

**Terminal 2 (simultaneously):**

bash

```bash
curl http://localhost:8080/api/user-service
```

**Terminal 3 (simultaneously):**

bash

```bash
curl http://localhost:8080/api/user-service
```

**Terminal 4 (this should be rejected):**

bash

```bash
curl http://localhost:8080/api/user-service
# Expected: "User Service is busy. Maximum concurrent requests reached."
```

#### Method 2: Automated Concurrent Test Script

bash

```bash
#!/bin/bash
# Save as test-bulkhead.sh

echo "=== Bulkhead Concurrent Test ==="
echo "Testing User Service Bulkhead (max 3 concurrent)"
echo ""

# Launch 6 concurrent requests
for i in {1..6}
do
  (
    echo "Launching request $i at $(date +%H:%M:%S)"
    response=$(curl -s http://localhost:8080/api/user-service)
    echo "Request $i response at $(date +%H:%M:%S): $response"
  ) &
done

# Wait for all background jobs to complete
wait

echo ""
echo "=== Test Complete ==="
```

#### Method 3: Load Testing with Apache Bench

bash

```bash
# Install Apache Bench (if not already installed)
# Ubuntu/Debian: sudo apt-get install apache2-utils
# Mac: brew install httpd

# Test User Service (3 concurrent limit)
ab -n 20 -c 6 http://localhost:8080/api/user-service

# Test Order Service (5 concurrent limit)
ab -n 20 -c 8 http://localhost:8080/api/order-service

# Analysis:
# - Successful requests: Stayed within bulkhead limit
# - Failed requests: Exceeded limit, received fallback
```

#### Method 4: Monitor Bulkhead Metrics

bash

```bash
# Check available concurrent calls
curl http://localhost:8080/actuator/metrics/resilience4j.bulkhead.available.concurrent.calls | json_pp

# Check max allowed concurrent calls
curl http://localhost:8080/actuator/metrics/resilience4j.bulkhead.max.allowed.concurrent.calls | json_pp

# Check health status
curl http://localhost:8080/actuator/health | json_pp
```

**Example Metrics Output:**

json

```json
{
  "name": "resilience4j.bulkhead.available.concurrent.calls",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 1.0
    }
  ],
  "availableTags": [
    {
      "tag": "name",
      "values": ["userServiceBulkhead", "orderServiceBulkhead"]
    }
  ]
}
```

#### Method 5: Visual Monitoring Script

bash

```bash
#!/bin/bash
# Save as monitor-bulkhead.sh

while true; do
  clear
  echo "=== Bulkhead Monitoring Dashboard ==="
  echo "Time: $(date)"
  echo ""
  
  # Get User Service stats
  user_available=$(curl -s http://localhost:8080/actuator/metrics/resilience4j.bulkhead.available.concurrent.calls?tag=name:userServiceBulkhead | grep -o '"value":[0-9.]*' | cut -d: -f2)
  
  echo "User Service Bulkhead (Max: 3)"
  echo "Available: $user_available"
  echo "In Use: $((3 - ${user_available%.*}))"
  echo ""
  
  # Status
  curl -s http://localhost:8080/api/bulkhead-status
  echo ""
  echo "Press Ctrl+C to stop monitoring"
  
  sleep 2
done
```

---

## 5. Time Limiter (Timeout Handling)

### What is Time Limiting?

**Definition**: Time Limiter sets a maximum time duration for an operation to complete. If it exceeds this time, the operation is cancelled.

### Real-World Analogy

Think of a **restaurant drive-through**:
- You order food at the speaker
- Expected wait time: 3 minutes
- If it takes longer than 5 minutes → You're told to park and they'll bring it out
- This prevents the drive-through line from backing up
```
┌──────────────────────────────────┐
│      Operation Timeline          │
├──────────────────────────────────┤
│                                  │
│  Start ──────────────→ 3s limit │
│    │                      ↑      │
│    │                      │      │
│    ▼                  TIMEOUT!   │
│  If completes < 3s: ✓ Success   │
│  If completes > 3s: ✗ Cancelled │
│                                  │
└──────────────────────────────────┘
```

### Real-World Case Study: Uber Ride Matching

**Scenario**: Finding a driver for your ride

**Without Time Limiter:**

-   Search for drivers indefinitely
-   User waits 10+ minutes staring at "Finding driver..." screen
-   Poor user experience
-   App appears frozen

**With Time Limiter (30 seconds):**

-   Search for 30 seconds
-   If no driver found → Show message: "No drivers available nearby"
-   User can try again or use alternative
-   **Result**: Clear feedback, better UX

### When to Use Time Limiter?

✅ **Use When:**

-   Calling slow external services
-   Database queries that might hang
-   File uploads/downloads
-   Network operations with unpredictable duration
-   Need to guarantee response time SLAs

❌ **Don't Use For:**

-   Operations that must complete (e.g., financial transactions)
-   Batch processing where time doesn't matter
-   Operations with natural quick completion

----------

## Time Limiter Example

### Step 1: Common Setup (Already Done)

### Step 2: Create RestController with TimeLimiter

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.concurrent.CompletableFuture;

@RestController
@RequestMapping("/api")
public class TimeLimiterController {
    
    /**
     * Basic Time Limiter Example
     * Timeout: 3 seconds
     */
    @GetMapping("/time-limiter")
    @TimeLimiter(name = "basicTimeLimiter", fallbackMethod = "timeLimiterFallback")
    public CompletableFuture<String> timeLimiterDemo(
            @RequestParam(defaultValue = "2") int delaySeconds) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println("Operation started at " + LocalDateTime.now() + 
                                 " with " + delaySeconds + "s delay");
                
                // Simulate time-consuming operation
                Thread.sleep(delaySeconds * 1000L);
                
                System.out.println("Operation completed at " + LocalDateTime.now());
                return String.format("Operation completed successfully after %d seconds", 
                                   delaySeconds);
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Operation interrupted");
            }
        });
    }
    
    /**
     * Fallback method when operation times out
     * MUST return CompletableFuture for async methods
     */
    public CompletableFuture<String> timeLimiterFallback(
            int delaySeconds, Exception ex) {
        
        System.out.println("Operation timed out at " + LocalDateTime.now());
        return CompletableFuture.completedFuture(
            "Operation timed out! The service took too long to respond. " +
            "Timeout limit exceeded. Please try again with a shorter operation."
        );
    }
    
    /**
     * Example: External API call with timeout
     */
    @GetMapping("/external-api")
    @TimeLimiter(name = "externalApiTimeLimiter", fallbackMethod = "externalApiFallback")
    public CompletableFuture<String> callExternalApi() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println("Calling external API at " + LocalDateTime.now());
                
                // Simulate external API call (random delay 1-6 seconds)
                int delay = (int) (Math.random() * 6) + 1;
                Thread.sleep(delay * 1000L);
                
                return "External API response: Data fetched successfully after " + 
                       delay + " seconds";
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("API call interrupted");
            }
        });
    }
    
    public CompletableFuture<String> externalApiFallback(Exception ex) {
        return CompletableFuture.completedFuture(
            "External API timed out. Using cached data instead."
        );
    }
    
    /**
     * Example: Database query with timeout
     */
    @GetMapping("/database-query")
    @TimeLimiter(name = "databaseTimeLimiter", fallbackMethod = "databaseFallback")
    public CompletableFuture<String> executeSlowQuery() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println("Executing database query at " + LocalDateTime.now());
                
                // Simulate slow database query (4 seconds)
                Thread.sleep(4000);
                
                return "Database query results: [1000 rows fetched]";
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Query interrupted");
            }
        });
    }
    
    public CompletableFuture<String> databaseFallback(Exception ex) {
        return CompletableFuture.completedFuture(
            "Database query timed out. Returning summary data instead of full results."
        );
    }
    
    /**
     * Example: File processing with timeout
     */
    @GetMapping("/process-file")
    @TimeLimiter(name = "fileProcessingTimeLimiter", fallbackMethod = "fileProcessingFallback")
    public CompletableFuture<String> processLargeFile(
            @RequestParam(defaultValue = "5") int processingTime) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println("Processing file at " + LocalDateTime.now());
                
                // Simulate file processing
                for (int i = 0; i < processingTime; i++) {
                    Thread.sleep(1000);
                    System.out.println("Processing... " + ((i + 1) * 20) + "% complete");
                }
                
                return "File processed successfully! Total time: " + processingTime + "s";
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("File processing interrupted");
            }
        });
    }
    
    public CompletableFuture<String> fileProcessingFallback(
            int processingTime, Exception ex) {
        
        return CompletableFuture.completedFuture(
            "File processing timed out. File queued for background processing. " +
            "You'll receive an email when complete."
        );
    }
    
    /**
     * Test endpoint to demonstrate different timeout scenarios
     */
    @GetMapping("/test-timeout")
    public String testTimeoutScenarios() {
        return "Test different timeout scenarios:\n\n" +
               "1. Fast operation (completes in time):\n" +
               "   GET /api/time-limiter?delaySeconds=2\n\n" +
               "2. Slow operation (times out):\n" +
               "   GET /api/time-limiter?delaySeconds=5\n\n" +
               "3. External API (random):\n" +
               "   GET /api/external-api\n\n" +
               "4. Slow database query:\n" +
               "   GET /api/database-query\n\n" +
               "5. File processing:\n" +
               "   GET /api/process-file?processingTime=5";
    }
}
```

### Step 3:


### Step 3: Update application.properties

properties

```properties
# =====================================================
# TIME LIMITER CONFIGURATIONS
# =====================================================

# Basic Time Limiter Configuration
# Timeout after 3 seconds
resilience4j.timelimiter.instances.basicTimeLimiter.timeout-duration=3s
resilience4j.timelimiter.instances.basicTimeLimiter.cancel-running-future=true

# External API Time Limiter
# Shorter timeout: 2 seconds (APIs should respond quickly)
resilience4j.timelimiter.instances.externalApiTimeLimiter.timeout-duration=2s
resilience4j.timelimiter.instances.externalApiTimeLimiter.cancel-running-future=true

# Database Time Limiter
# Longer timeout: 5 seconds (complex queries may take time)
resilience4j.timelimiter.instances.databaseTimeLimiter.timeout-duration=5s
resilience4j.timelimiter.instances.databaseTimeLimiter.cancel-running-future=true

# File Processing Time Limiter
# Very short timeout: 3 seconds (should use async processing for large files)
resilience4j.timelimiter.instances.fileProcessingTimeLimiter.timeout-duration=3s
resilience4j.timelimiter.instances.fileProcessingTimeLimiter.cancel-running-future=true
```

### Configuration Parameters Explained
<img width="910" height="232" alt="image" src="https://github.com/user-attachments/assets/c0de05ec-a20c-43ea-a1aa-2415962ee950" />



### Important Notes About CompletableFuture

**Why TimeLimiter requires CompletableFuture?**

TimeLimiter works asynchronously. Regular synchronous methods block the calling thread, making timeout enforcement difficult. CompletableFuture allows:

1.  **Non-blocking execution**: Operation runs in a separate thread
2.  **Timeout enforcement**: Main thread can cancel after timeout
3.  **Resource efficiency**: Doesn't block request-handling threads

**Comparison:**

java

```java
// ❌ WRONG: Synchronous method (blocks thread)
@TimeLimiter(name = "example")
public String synchronousMethod() {
    Thread.sleep(5000);
    return "Done";
}

// ✓ CORRECT: Asynchronous method (non-blocking)
@TimeLimiter(name = "example")
public CompletableFuture<String> asynchronousMethod() {
    return CompletableFuture.supplyAsync(() -> {
        Thread.sleep(5000);
        return "Done";
    });
}
```

### Step 4: How to Test TimeLimiter?

#### Method 1: Test Fast Operations (Completes Within Timeout)

bash

```bash
# This should succeed (2 seconds < 3 seconds timeout)
curl "http://localhost:8080/api/time-limiter?delaySeconds=2"

# Expected output:
# Operation completed successfully after 2 seconds
```

#### Method 2: Test Slow Operations (Exceeds Timeout)

bash

```bash
# This should timeout (5 seconds > 3 seconds timeout)
curl "http://localhost:8080/api/time-limiter?delaySeconds=5"

# Expected output:
# Operation timed out! The service took too long to respond...
```

#### Method 3: Test All Endpoints

bash

```bash
#!/bin/bash
# Save as test-timelimiter.sh

echo "=== Time Limiter Test Suite ==="
echo ""

echo "Test 1: Fast operation (should succeed)"
curl -s "http://localhost:8080/api/time-limiter?delaySeconds=2"
echo -e "\n"

echo "Test 2: Slow operation (should timeout)"
curl -s "http://localhost:8080/api/time-limiter?delaySeconds=5"
echo -e "\n"

echo "Test 3: External API (random)"
curl -s "http://localhost:8080/api/external-api"
echo -e "\n"

echo "Test 4: Database query (should timeout)"
curl -s "http://localhost:8080/api/database-query"
echo -e "\n"

echo "Test 5: File processing with short time (should succeed)"
curl -s "http://localhost:8080/api/process-file?processingTime=2"
echo -e "\n"

echo "Test 6: File processing with long time (should timeout)"
curl -s "http://localhost:8080/api/process-file?processingTime=5"
echo -e "\n"

echo "=== Tests Complete ==="
```

#### Method 4: Monitor Console Output

Watch your application console to see the timeline:
```
Operation started at 2024-10-31T11:15:30 with 5s delay
Operation timed out at 2024-10-31T11:15:33
// Note: Operation was cancelled after 3 seconds
```

#### Method 5: Stress Test with Different Delays

bash

```bash
#!/bin/bash
# Test various delay times

echo "=== Testing Various Timeout Scenarios ==="

for delay in 1 2 3 4 5 6
do
  echo ""
  echo "Testing with ${delay}s delay (timeout is 3s):"
  echo "Expected: $( [ $delay -le 3 ] && echo "SUCCESS" || echo "TIMEOUT" )"
  
  response=$(curl -s "http://localhost:8080/api/time-limiter?delaySeconds=$delay")
  
  if [[ $response == *"successfully"* ]]; then
    echo "✓ PASSED: Operation completed"
  elif [[ $response == *"timed out"* ]]; then
    echo "✓ PASSED: Operation timed out as expected"
  else
    echo "✗ FAILED: Unexpected response"
  fi
done
```

----------

## Complete YAML Configuration File

For better organization, you can use `application.yml` instead of `application.properties`:

yaml

```yaml
# application.yml - Complete Resilience4j Configuration

spring:
  application:
    name: resilience4j-demo

server:
  port: 8080

# =====================================================
# ACTUATOR CONFIGURATION
# =====================================================
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus,circuitbreakers,ratelimiters
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
    bulkheads:
      enabled: true

# =====================================================
# RESILIENCE4J CONFIGURATIONS
# =====================================================
resilience4j:
  
  # ===== CIRCUIT BREAKER =====
  circuitbreaker:
    instances:
      basicCircuitBreaker:
        failure-rate-threshold: 50                    # Open circuit at 50% failure
        sliding-window-type: COUNT_BASED              # Count-based sliding window
        sliding-window-size: 10                       # Last 10 calls
        minimum-number-of-calls: 5                    # Min calls before calculation
        wait-duration-in-open-state: 10s              # Stay open for 10 seconds
        permitted-number-of-calls-in-half-open-state: 3  # Test with 3 calls
        automatic-transition-from-open-to-half-open-enabled: true
        register-health-indicator: true
        record-exceptions:
          - java.lang.RuntimeException
      
      weatherService:
        failure-rate-threshold: 60
        sliding-window-size: 10
        minimum-number-of-calls: 5
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 5
      
      stockService:
        failure-rate-threshold: 40
        sliding-window-size: 20
        minimum-number-of-calls: 10
        wait-duration-in-open-state: 60s
        permitted-number-of-calls-in-half-open-state: 3
        automatic-transition-from-open-to-half-open-enabled: true
  
  # ===== RETRY =====
  retry:
    instances:
      basicRetry:
        max-attempts: 3                               # Total 3 attempts
        wait-duration: 2s                             # Wait 2 seconds between retries
        enable-exponential-backoff: false
        retry-exceptions:
          - java.lang.RuntimeException
        ignore-exceptions:
          - java.lang.NullPointerException
      
      paymentRetry:
        max-attempts: 3
        wait-duration: 1s
        enable-exponential-backoff: true
        exponential-backoff-multiplier: 2             # 1s, 2s, 4s
      
      databaseRetry:
        max-attempts: 5
        wait-duration: 500ms
        enable-exponential-backoff: false
  
  # ===== RATE LIMITER =====
  ratelimiter:
    instances:
      basicRateLimiter:
        limit-for-period: 3                           # 3 requests
        limit-refresh-period: 10s                     # Per 10 seconds
        timeout-duration: 0s                          # No waiting
        allow-health-indicator-to-fail: true
        subscribe-for-events: true
        register-health-indicator: true
      
      userServiceRateLimiter:
        limit-for-period: 2
        limit-refresh-period: 5s
        timeout-duration: 0s
  
  # ===== BULKHEAD =====
  bulkhead:
    instances:
      userServiceBulkhead:
        max-concurrent-calls: 3                       # Max 3 concurrent
        max-wait-duration: 0ms                        # No waiting
      
      orderServiceBulkhead:
        max-concurrent-calls: 5
        max-wait-duration: 0ms
      
      criticalServiceBulkhead:
        max-concurrent-calls: 2
        max-wait-duration: 100ms
  
  # ===== THREAD POOL BULKHEAD =====
  thread-pool-bulkhead:
    instances:
      paymentServiceBulkhead:
        max-thread-pool-size: 3                       # Max 3 threads
        core-thread-pool-size: 2                      # Min 2 threads
        queue-capacity: 5                             # Queue size
        keep-alive-duration: 20ms
  
  # ===== TIME LIMITER =====
  timelimiter:
    instances:
      basicTimeLimiter:
        timeout-duration: 3s                          # 3 seconds timeout
        cancel-running-future: true
      
      externalApiTimeLimiter:
        timeout-duration: 2s
        cancel-running-future: true
      
      databaseTimeLimiter:
        timeout-duration: 5s
        cancel-running-future: true
      
      fileProcessingTimeLimiter:
        timeout-duration: 3s
        cancel-running-future: true

# =====================================================
# LOGGING CONFIGURATION (Optional)
# =====================================================
logging:
  level:
    io.github.resilience4j: DEBUG
    com.example.resilience: DEBUG
```

### Benefits of YAML Format

1.  **Better Readability**: Hierarchical structure is clearer
2.  **Less Repetition**: Common prefixes written once
3.  **Comments**: Easy to add explanatory comments
4.  **Lists**: Natural syntax for lists and arrays
5.  **Validation**: IDEs provide better autocomplete and validation

----------

## How to Implement Multiple Patterns in a Single Method?

Often, you need multiple fault tolerance patterns working together for robust protection.

### Real-World Scenario

**E-commerce Checkout Service:**

-   Must complete within 5 seconds (Time Limiter)
-   Retry if payment gateway fails (Retry)
-   Don't overload payment service (Rate Limiter)
-   Isolate from other services (Bulkhead)
-   Stop if payment service is down (Circuit Breaker)

### Example: Combining Multiple Patterns

java

```java
package com.example.resilience.controller;

import io.github.resilience4j.bulkhead.annotation.Bulkhead;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
import io.github.resilience4j.retry.annotation.Retry;
import io.github.resilience4j.timelimiter.annotation.TimeLimiter;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.Random;
import java.util.concurrent.CompletableFuture;

@RestController
@RequestMapping("/api")
public class CombinedPatternsController {
    
    private Random random = new Random();
    private int orderCounter = 0;
    
    /**
     * Complete E-commerce Checkout with All Patterns
     * 
     * Order of Execution (outermost to innermost):
     * 1. RateLimiter - Control request rate
     * 2. TimeLimiter - Set overall timeout
     * 3. CircuitBreaker - Prevent calls to failing service
     * 4. Bulkhead - Limit concurrent executions
     * 5. Retry - Retry on transient failures
     */
    @GetMapping("/checkout")
    @RateLimiter(name = "checkoutRateLimiter")
    @TimeLimiter(name = "checkoutTimeLimiter")
    @CircuitBreaker(name = "checkoutCircuitBreaker", fallbackMethod = "checkoutFallback")
    @Bulkhead(name = "checkoutBulkhead", type = Bulkhead.Type.SEMAPHORE)
    @Retry(name = "checkoutRetry")
    public CompletableFuture<String> processCheckout(
            @RequestParam(defaultValue = "100") double amount) {
        
        return CompletableFuture.supplyAsync(() -> {
            orderCounter++;
            int currentOrder = orderCounter;
            
            System.out.println(String.format(
                "[Order #%d] Processing checkout for $%.2f at %s",
                currentOrder, amount, LocalDateTime.now()
            ));
            
            try {
                // Simulate payment processing time (1-3 seconds)
                Thread.sleep((random.nextInt(3) + 1) * 1000L);
                
                // Simulate random failures (30% failure rate)
                if (random.nextInt(10) < 3) {
                    System.out.println(String.format(
                        "[Order #%d] Payment gateway error!", currentOrder
                    ));
                    throw new RuntimeException("Payment gateway temporarily unavailable");
                }
                
                System.out.println(String.format(
                    "[Order #%d] Payment successful!", currentOrder
                ));
                
                return String.format(
                    "✓ Order #%d completed successfully! " +
                    "Amount: $%.2f, Time: %s, Transaction ID: TXN-%d",
                    currentOrder, amount, LocalDateTime.now(), 
                    random.nextInt(100000)
                );
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Payment processing interrupted");
            }
        });
    }
    
    /**
     * Fallback method for checkout
     */
    public CompletableFuture<String> checkoutFallback(
            double amount, Exception ex) {
        
        System.out.println("Checkout fallback triggered: " + ex.getMessage());
        
        return CompletableFuture.completedFuture(
            "⚠ Checkout temporarily unavailable. " +
            "Your order for $" + amount + " has been queued. " +
            "You'll receive a confirmation email shortly. " +
            "Error: " + ex.getMessage()
        );
    }
    
    /**
     * Product Search with Multiple Patterns
     */
    @GetMapping("/search")
    @RateLimiter(name = "searchRateLimiter")
    @CircuitBreaker(name = "searchCircuitBreaker", fallbackMethod = "searchFallback")
    @Bulkhead(name = "searchBulkhead")
    public String searchProducts(@RequestParam String query) {
        
        System.out.println("Searching for: " + query + " at " + LocalDateTime.now());
        
        try {
            // Simulate search operation
            Thread.sleep(500);
            
            // Simulate occasional failures
            if (random.nextInt(10) < 2) {
                throw new RuntimeException("Search service error");
            }
            
            return String.format(
                "Search results for '%s': Found 42 products (Relevance sorted)",
                query
            );
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Search interrupted");
        }
    }
    
    public String searchFallback(String query, Exception ex) {
        return String.format(
            "Search temporarily unavailable. Showing cached results for '%s'",
            query
        );
    }
    
    /**
     * Inventory Check with Multiple Patterns
     */
    @GetMapping("/inventory")
    @RateLimiter(name = "inventoryRateLimiter")
    @TimeLimiter(name = "inventoryTimeLimiter")
    @CircuitBreaker(name = "inventoryCircuitBreaker", fallbackMethod = "inventoryFallback")
    @Retry(name = "inventoryRetry")
    public CompletableFuture<String> checkInventory(
            @RequestParam String productId) {
        
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("Checking inventory for: " + productId);
            
            try {
                // Simulate database query
                Thread.sleep(1000);
                
                // Simulate occasional failures
                if (random.nextInt(10) < 3) {
                    throw new RuntimeException("Database connection error");
                }
                
                int stock = random.nextInt(100);
                String status = stock > 10 ? "In Stock" : "Low Stock";
                
                return String.format(
                    "Product %s: %s (%d units available)",
                    productId, status, stock
                );
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Inventory check interrupted");
            }
        });
    }
    
    public CompletableFuture<String> inventoryFallback(
            String productId, Exception ex) {
        
        return CompletableFuture.completedFuture(
            String.format(
                "Inventory check unavailable for %s. " +
                "Last known: In Stock (cached 10 minutes ago)",
                productId
            )
        );
    }
}
```

### Configuration for Combined Patterns

Add to your `application.yml`:

yaml

```yaml
resilience4j:
  # Checkout Service Configurations
  ratelimiter:
    instances:
      checkoutRateLimiter:
        limit-for-period: 10          # 10 checkouts
        limit-refresh-period: 1m      # Per minute
        timeout-duration: 0s
  
  timelimiter:
    instances:
      checkoutTimeLimiter:
        timeout-duration: 5s          # Max 5 seconds for checkout
        cancel-running-future: true
  
  circuitbreaker:
    instances:
      checkoutCircuitBreaker:
        failure-rate-threshold: 50
        sliding-window-size: 10
        minimum-number-of-calls: 5
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 3
  
  bulkhead:
    instances:
      checkoutBulkhead:
        max-concurrent-calls: 5       # Max 5 concurrent checkouts
        max-wait-duration: 0ms
  
  retry:
    instances:
      checkoutRetry:
        max-attempts: 2               # Only 1 retry for checkout
        wait-duration: 1s
  
  # Search Service Configurations
  ratelimiter:
    instances:
      searchRateLimiter:
        limit-for-period: 20          # More lenient
        limit-refresh-period: 10s
  
  circuitbreaker:
    instances:
      searchCircuitBreaker:
        failure-rate-threshold: 60
        sliding-window-size: 15
        wait-duration-in-open-state: 20s
  
  bulkhead:
    instances:
      searchBulkhead:
        max-concurrent-calls: 10      # Allow more concurrent searches
  
  # Inventory Service Configurations
  ratelimiter:
    instances:
      inventoryRateLimiter:
        limit-for-period: 50
        limit-refresh-period: 10s
  
  timelimiter:
    instances:
      inventoryTimeLimiter:
        timeout-duration: 2s
        cancel-running-future: true
  
  circuitbreaker:
    instances:
      inventoryCircuitBreaker:
        failure-rate-threshold: 40
        sliding-window-size: 20
        wait-duration-in-open-state: 45s
  
  retry:
    instances:
      inventoryRetry:
        max-attempts: 3
        wait-duration: 500ms
```

### Execution Flow Visualization
```
Incoming Request to /api/checkout
        │
        ▼
┌───────────────────────┐
│   1. Rate Limiter     │ → Rejects if too many requests
│   (10 req/min)        │
└───────┬───────────────┘
        │ ✓ Allowed
        ▼
┌───────────────────────┐
│   2. Time Limiter     │ → Sets 5-second deadline
│   (5s timeout)        │
└───────┬───────────────┘
        │ ✓ Within time
        ▼
┌───────────────────────┐
│  3. Circuit Breaker   │ → Checks if service is healthy
│  (CLOSED state)       │
└───────┬───────────────┘
        │ ✓ Circuit closed
        ▼
┌───────────────────────┐
│   4. Bulkhead         │ → Checks concurrent limit
│   (5 concurrent max)  │
└───────┬───────────────┘
        │ ✓ Slot available
        ▼
┌───────────────────────┐
│   5. Retry            │ → Executes with retry logic
│   (2 attempts)        │
└───────┬───────────────┘
        │ ✓ Success or Retry
        ▼
┌───────────────────────┐
│   Business Logic      │ → Your actual checkout code
│   (Payment Processing)│
└───────┬───────────────┘
        │
        ▼
    Response
```

### Testing Combined Patterns

bash

```bash
#!/bin/bash
# Save as test-combined.sh

echo "=== Testing Combined Patterns ==="
echo ""

# Test 1: Normal checkout
echo "Test 1: Normal checkout"
curl -s "http://localhost:8080/api/checkout?amount=99.99"
echo -e "\n"

# Test 2: Rapid checkouts (test rate limiter)
echo "Test 2: Testing rate limiter (15 rapid checkouts)"
for i in {1..15}
do
  echo "Checkout $i:"
  curl -s "http://localhost:8080/api/checkout?amount=50.00"
  echo ""
done

# Test 3: Concurrent checkouts (test bulkhead)
echo "Test 3: Testing bulkhead (10 concurrent checkouts)"
for i in {1..10}
do
  curl -s "http://localhost:8080/api/checkout?amount=75.00" &
done
wait
echo "All concurrent requests completed"

# Test 4: Product search
echo "Test 4: Product search"
curl -s "http://localhost:8080/api/search?query=laptop"
echo -e "\n"

# Test 5: Inventory check
echo "Test 5: Inventory check"
curl -s "http://localhost:8080/api/inventory?productId=PROD123"
echo -e "\n"

echo "=== Tests Complete ==="
```

### Order of Annotations Matters!

**✓ Correct Order (Outside to Inside):**

java

```java
@RateLimiter        // 1. First line of defense
@TimeLimiter        // 2. Overall timeout
@CircuitBreaker     // 3. Health check
@Bulkhead           // 4. Resource isolation
@Retry              // 5. Last resort
public CompletableFuture<String> myMethod() { ... }
```

**✗ Incorrect Order:**

java

```java
@Retry              // Wrong! Retry should be innermost
@RateLimiter        // Wrong order
@CircuitBreaker
public CompletableFuture<String> myMethod() { ... }
```

**Why Order Matters:**

-   RateLimiter should reject excess requests before they consume resources
-   CircuitBreaker should prevent calls to unhealthy services early
-   Retry should be the last attempt to recover from failures

----------

## Conclusion

### Summary of Fault Tolerance Patterns
<img width="922" height="263" alt="image" src="https://github.com/user-attachments/assets/64851190-5703-45c8-b411-2f1bf5feabf3" />



### Real-World Best Practices

1.  **Start Simple**: Don't use all patterns everywhere
    -   Critical paths: Use all patterns
    -   Read operations: Circuit Breaker + Timeout
    -   Write operations: Retry + Circuit Breaker
2.  **Monitor Everything**:

bash

```bash
   # Always monitor your resilience patterns
   curl http://localhost:8080/actuator/health
   curl http://localhost:8080/actuator/metrics
```

3.  **Tune Configuration**:
    -   Start with conservative values
    -   Monitor in production
    -   Adjust based on actual behavior
4.  **Test Failure Scenarios**:
    -   Don't just test happy paths
    -   Simulate network failures
    -   Test under load
5.  **Provide Meaningful Fallbacks**:

java

```java
   // ✗ Bad fallback
   public String fallback(Exception ex) {
       return "Error occurred";
   }
   
   // ✓ Good fallback
   public String fallback(Exception ex) {
       return "Service unavailable. Using cached data from 5 minutes ago. " +
              "Your request has been queued for processing.";
   }
```

### Key Takeaways

✅ **Microservices WILL fail** - Design for failure, not success

✅ **Fail fast** - Better to fail quickly than hang indefinitely

✅ **Isolate failures** - Don't let one failure bring down everything

✅ **Provide fallbacks** - Always have a Plan B

✅ **Monitor constantly** - You can't improve what you don't measure

### Project Structure Summary
```
resilience4j-demo/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/resilience/
│   │   │       ├── Resilience4jDemoApplication.java
│   │   │       └── controller/
│   │   │           ├── RateLimiterController.java
│   │   │           ├── RetryController.java
│   │   │           ├── CircuitBreakerController.java
│   │   │           ├── BulkheadController.java
│   │   │           ├── TimeLimiterController.java
│   │   │           └── CombinedPatternsController.java
│   │   └── resources/
│   │       └── application.yml
│   └── test/
├── pom.xml
└── README.md
```

### Next Steps

1.  **Clone and Run**: Set up the project and test all endpoints
2.  **Experiment**: Modify configuration values and observe behavior
3.  **Load Test**: Use tools like JMeter or Gatling
4.  **Production Ready**: Add logging, monitoring (Prometheus/Grafana)
5.  **Advanced Topics**:
    -   Distributed Circuit Breaker (Consul, Eureka)
    -   Custom fallback strategies
    -   Metrics visualization
    -   Integration with service mesh (Istio, Linkerd)

### Additional Resources

-   **Resilience4j Documentation**: [https://resilience4j.readme.io/](https://resilience4j.readme.io/)
-   **Spring Boot Actuator**: [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)
-   **Microservices Patterns Book**: By Chris Richardson
-   **Release It! Book**: By Michael Nygard

----------

**Remember**: Fault tolerance is not about preventing failures—it's about managing them gracefully! 🚀

