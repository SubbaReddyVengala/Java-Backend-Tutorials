# Spring Cloud Config Server - Complete Tutorial Guide

## 📚 Table of Contents

1.  Understanding Spring Cloud Config Server
2.  Spring Cloud Config Client
3.  Why We Need Config Server
4.  Advantages of Config Server
5.  Implementation Approaches
6.  Hands-On Implementation
7.  Testing & Validation
8.  Dynamic Configuration Refresh
9.  Conclusion

----------

## 🎯 Understanding Spring Cloud Config Server

### What is Spring Cloud Config Server?

**Spring Cloud Config Server**  is a centralized configuration management service for distributed systems, particularly microservices architectures.

### 🧠 Memory Visualization (The Library Analogy)

Think of a  **traditional library system**:

```
Traditional Approach (Without Config Server):
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Student A   │  │ Student B   │  │ Student C   │
│ Personal    │  │ Personal    │  │ Personal    │
│ Notebook    │  │ Notebook    │  │ Notebook    │
└─────────────┘  └─────────────┘  └─────────────┘
Each student maintains their own notes
Problem: Updates are inconsistent!

Config Server Approach:
                ┌──────────────────┐
                │ Central Library  │
                │ Reference Books  │
                └────────┬─────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
   ┌────▼────┐     ┌────▼────┐     ┌────▼────┐
   │Student A│     │Student B│     │Student C│
   └─────────┘     └─────────┘     └─────────┘
   All students refer to the same source!
```

### 🔧 Technical Definition

Spring Cloud Config Server provides:

-   **Centralized external configuration**  for all microservices
-   **Environment-specific configurations**  (dev, test, prod)
-   **Version control integration**  (Git, SVN)
-   **Dynamic configuration updates**  without redeployment
-   **Encryption/Decryption**  of sensitive properties

### Architecture Flow

```
┌──────────────────────────────────────────────────┐
│           Git/GitHub Repository                  │
│  ┌────────────────────────────────────────┐     │
│  │ application-dev.properties              │     │
│  │ application-prod.properties             │     │
│  │ microservice-a-dev.properties           │     │
│  └────────────────────────────────────────┘     │
└───────────────────┬──────────────────────────────┘
                    │ Fetch configs
                    ▼
        ┌───────────────────────┐
        │  Config Server        │
        │  (Port: 8888)         │
        │  - Manages configs    │
        │  - Serves properties  │
        └───────────┬───────────┘
                    │ REST API calls
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
    ┌───────┐  ┌───────┐  ┌───────┐
    │ MS-A  │  │ MS-B  │  │ MS-C  │
    │ :8081 │  │ :8082 │  │ :8083 │
    └───────┘  └───────┘  └───────┘
    Config Clients
```

----------

## 🎮 Spring Cloud Config Client

### What is Spring Cloud Config Client?

A  **Config Client**  is any microservice that consumes configuration from the Config Server instead of maintaining its own local configuration files.

### 🧠 Analogy: The Remote Control

```
Old TV (Without Config Client):
┌─────────────────┐
│   TV Set        │
│ ┌─────────────┐ │
│ │Manual Dials │ │  ← Need to walk to TV to change
│ └─────────────┘ │
└─────────────────┘

Modern TV (With Config Client):
┌─────────────────┐         ┌──────────────┐
│   TV Set        │  ◄────  │ Remote       │
│                 │         │ Control      │
│  Receives       │         │ (Config      │
│  commands       │         │  Server)     │
└─────────────────┘         └──────────────┘
                     Wireless updates!
```

### How Config Client Works

java

```java
// Config Client automatically:
1. Discovers Config Server (via bootstrap.properties)
2. Requests its configuration (based on application name)
3. Receives properties from Config Server
4. Uses them at runtime
```

----------

## 💡 Why Do We Need a Spring Cloud Config Server?

### Problem Scenario (Without Config Server)

```
E-Commerce Microservices System:
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Order        │  │ Payment      │  │ Inventory    │
│ Service      │  │ Service      │  │ Service      │
│              │  │              │  │              │
│ DB: prod.db  │  │ DB: prod.db  │  │ DB: prod.db  │
└──────────────┘  └──────────────┘  └──────────────┘

❌ Problems:
1. Database URL changes → Update 100 microservices
2. API key rotation → Rebuild & redeploy all services
3. Environment switch (dev→prod) → Manual config changes
4. Security risk: Hardcoded credentials in each service
5. No audit trail: Who changed what configuration?
```

### Solution with Config Server

```
┌─────────────────────────────────────────┐
│  Config Server (Single Source of Truth)│
│  ┌───────────────────────────────────┐ │
│  │ db.url=jdbc:mysql://prod.db       │ │
│  │ api.key=encrypted_value           │ │
│  │ feature.enabled=true              │ │
│  └───────────────────────────────────┘ │
└──────────────┬──────────────────────────┘
               │ One place to update
       ┌───────┼───────┼───────┐
       ▼       ▼       ▼       ▼
     [MS1]   [MS2]   [MS3]   [MS100]
   
✅ Benefits:
1. Change once, affect all services
2. Version controlled (Git history)
3. Environment-specific configs
4. Dynamic refresh (no restart needed)
```

----------

## 🚀 Advantages of Using Spring Cloud Config Server

### 1.  **Centralized Management**

```
Without Config Server:
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ MS1 │ │ MS2 │ │ MS3 │ │ MS4 │
│ 📄  │ │ 📄  │ │ 📄  │ │ 📄  │
└─────┘ └─────┘ └─────┘ └─────┘
(4 places to update)

With Config Server:
        ┌──────────┐
        │  Config  │
        │  Server  │
        │    📄    │
        └────┬─────┘
     ┌───────┼───────┐
   [MS1]   [MS2]   [MS3]   [MS4]
(1 place to update)
```

### 2.  **Environment-Specific Configurations**

```
Git Repository Structure:
config-repo/
├── application.properties          (Common to all)
├── application-dev.properties      (Development)
├── application-test.properties     (Testing)
├── application-prod.properties     (Production)
├── order-service-dev.properties    (Service-specific)
└── payment-service-prod.properties

Microservice automatically loads:
- application.properties (base)
- application-{profile}.properties (environment)
- {service-name}-{profile}.properties (service+env)
```

### 3.  **Version Control & Audit Trail**

```
Git History:
commit 3a4b5c6 - "Changed DB URL for prod"
commit 2d3e4f5 - "Updated API timeout to 30s"
commit 1c2d3e4 - "Added new feature flag"

Benefits:
✅ Who changed what?
✅ When was it changed?
✅ Rollback to previous config
✅ Review changes before deployment
```

### 4.  **Security & Encryption**

```
Before Encryption:
db.password=mySecretPassword123  ❌ Visible in Git

After Encryption:
db.password={cipher}AQB7H8... ✅ Encrypted
                     ↓
           Config Server Decrypts
                     ↓
        Microservice receives plain text
```

### 5.  **Dynamic Refresh (No Restart)**

```
Traditional Approach:
Change config → Rebuild JAR → Redeploy → Downtime ❌

Config Server + @RefreshScope:
Change config → Git commit → Trigger /refresh → Live update ✅
                                    (No downtime!)
```

### 6.  **Consistency Across Environments**

```
Problem without Config Server:
Dev:  db.timeout=5000
Test: db.timeout=3000  ← Why different?
Prod: db.timeout=10000 ← Configuration drift!

With Config Server:
All environments use same property names
Only values differ per profile
Easier to maintain consistency
```

----------

## 🏗️ Implementation Approaches

### 1. External Config Server (Git-Based)

**Most Common Approach**: Store configurations in a Git repository.

```
Architecture:
┌─────────────────────────┐
│   GitHub/GitLab/BitBucket│
│   config-repository      │
│   ├── app-dev.properties │
│   └── app-prod.properties│
└───────────┬───────────────┘
            │ Git Clone/Pull
            ▼
    ┌───────────────┐
    │ Config Server │
    └───────┬───────┘
            │ HTTP/REST
            ▼
    [Microservices]
```

**Advantages:**

-   ✅ Version control (history, branches, tags)
-   ✅ Collaboration (pull requests, reviews)
-   ✅ Backup & disaster recovery
-   ✅ Multiple environment support
-   ✅ Industry standard

**Configuration:**

properties

```properties
# Config Server application.properties
spring.cloud.config.server.git.uri=https://github.com/user/config-repo
spring.cloud.config.server.git.default-label=main
spring.cloud.config.server.git.clone-on-start=true
```

### 2. Native Config Server (File System)

**Local Development Approach**: Store configurations on the local file system.

```
Architecture:
┌────────────────────────┐
│  Local File System     │
│  C:/config-files/      │
│  ├── app-dev.properties│
│  └── app-prod.properties│
└──────────┬─────────────┘
           │ Direct File Access
           ▼
   ┌───────────────┐
   │ Config Server │
   └───────┬───────┘
           │ HTTP/REST
           ▼
   [Microservices]
```

**Advantages:**

-   ✅ Fast for local development
-   ✅ No Git repository needed
-   ✅ Simple setup
-   ✅ Good for testing

**Disadvantages:**

-   ❌ No version control
-   ❌ No collaboration features
-   ❌ Not suitable for production
-   ❌ Manual backup required

**Configuration:**

properties

```properties
# Config Server application.properties
spring.profiles.active=native
spring.cloud.config.server.native.search-locations=file:///C:/config-files
```

### Comparison Table
<img width="813" height="288" alt="image" src="https://github.com/user-attachments/assets/354651e3-61e4-4935-9b1e-26a983ee2d36" />






----------

## 🛠️ Hands-On Implementation

### Use Case Details

**Scenario**: E-Commerce System with 3 Microservices

```
System Architecture:
┌─────────────┐
│   Eureka    │ ← Service Discovery (8761)
│   Server    │
└──────┬──────┘
       │ Register all services
       │
┌──────┴──────────────────────┐
│                             │
│  ┌──────────────┐           │
│  │ Config Server│ (8888)    │
│  └──────┬───────┘           │
│         │ Provides configs   │
│         │                   │
│  ┌──────▼────────┐          │
│  │ Product Service│ (8081)  │
│  │ (Config Client)│         │
│  └────────────────┘         │
└─────────────────────────────┘

Components:
1. Eureka Server (Service Registry)
2. Config Server (Configuration Management)
3. Product Service (Business Microservice)
```

----------

## 📦 Create a Repository in GitHub

### Step 1: Create Repository

1.  Go to GitHub.com
2.  Click "New Repository"
3.  Repository name:  `microservices-config-repo`
4.  Choose Public or Private
5.  Initialize with README
6.  Click "Create repository"

### Step 2: Create Configuration Files

Create the following files in your repository:

**application.properties**  (Common for all services)

properties

```properties
# Common configurations
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
management.endpoints.web.exposure.include=*
```

**product-service-dev.properties**  (Development profile)

properties

```properties
# Product Service - Development
server.port=8081
spring.application.name=PRODUCT-SERVICE

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/productdb_dev
spring.datasource.username=dev_user
spring.datasource.password=dev_password

# Business Properties
product.discount.percentage=10
product.max.quantity=100
product.api.timeout=5000

# Feature Flags
feature.new.checkout.enabled=false
```

**product-service-prod.properties**  (Production profile)

properties

```properties
# Product Service - Production
server.port=8081
spring.application.name=PRODUCT-SERVICE

# Database Configuration
spring.datasource.url=jdbc:mysql://prod-db-server:3306/productdb
spring.datasource.username=prod_user
spring.datasource.password={cipher}AQB7H8KFj3...

# Business Properties
product.discount.percentage=5
product.max.quantity=1000
product.api.timeout=3000

# Feature Flags
feature.new.checkout.enabled=true
```

### File Structure

```
microservices-config-repo/
├── README.md
├── application.properties
├── product-service-dev.properties
└── product-service-prod.properties
```

----------

## 🎯 Create Microservice 

### Step #1: Create a Spring Boot Project

**Using Spring Initializr ([https://start.spring.io/](https://start.spring.io/))**

```
Project: Maven
Language: Java
Spring Boot: 3.2.0 (or latest stable)
Packaging: Jar
Java: 17

Dependencies:
- Eureka Server
```

**pom.xml**

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.ecommerce</groupId>
    <artifactId>eureka-server</artifactId>
    <version>1.0.0</version>
    <name>eureka-server</name>
    
    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Eureka Server -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### Step #2: Apply Annotation @EnableEurekaClient

**ProductServiceApplication.java**

java

```java
package com.ecommerce.product;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient  // ← Registers this service with Eureka Server
public class ProductServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
        System.out.println("✅ Product Service Started Successfully!");
        System.out.println("📍 Service registered with Eureka");
        System.out.println("⚙️ Configuration loaded from Config Server");
    }
}
```

**🧠 What @EnableEurekaClient Does:**

```
Without @EnableEurekaClient:
┌──────────────────┐
│  Product Service │  (Standalone, not discoverable)
└──────────────────┘

With @EnableEurekaClient:
┌──────────────────┐
│  Product Service │
│  ↓ Registers     │
│  Eureka Server   │
│  ↓ Discovers     │
│  Other Services  │
└──────────────────┘

Benefits:
✅ Automatic service registration
✅ Health check monitoring
✅ Load balancing support
✅ Service discovery
```

### Step #3: Modify application.properties

**IMPORTANT:**  For Config Client, you need TWO property files:

1.  **bootstrap.properties**  (loaded first, to connect to Config Server)
2.  **application.properties**  (loaded second, local configs)

**src/main/resources/bootstrap.properties**

properties

```properties
# Application Name (MUST match config file name in Git)
spring.application.name=product-service

# Config Server Location
spring.cloud.config.uri=http://localhost:8888

# Profile (dev, test, prod)
spring.profiles.active=dev

# Fail Fast (Stop if Config Server is down)
spring.cloud.config.fail-fast=true

# Retry Configuration
spring.cloud.config.retry.max-attempts=6
spring.cloud.config.retry.initial-interval=1000
spring.cloud.config.retry.max-interval=2000
spring.cloud.config.retry.multiplier=1.1
```

**🧠 Why bootstrap.properties?**

```
Application Startup Sequence:

1. bootstrap.properties loaded
   ↓
2. Connect to Config Server
   ↓
3. Fetch configurations from Git
   ↓
4. application.properties loaded
   ↓
5. Merge all properties
   ↓
6. Start application

If we put Config Server URL in application.properties,
it's too late! We need it BEFORE application context starts.
```

**src/main/resources/application.properties**

properties

```properties
# Local configurations (optional, can override)
# These properties will be overridden by Config Server

# Logging
logging.level.com.ecommerce.product=DEBUG

# Actuator endpoints
management.endpoints.web.exposure.include=refresh,health,info
management.endpoint.refresh.enabled=true
```

**Property Precedence (Higher to Lower):**

```
1. Command line arguments
   java -jar app.jar --server.port=9090
   
2. Config Server properties
   (From Git repository)
   
3. application.properties (local)
   (In src/main/resources)
   
4. Default values
```

### Step #4: Create RestController class

**ProductRestController.java**

java

```java
package com.ecommerce.product.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/products")
@RefreshScope  // ← Enables dynamic property refresh
public class ProductRestController {
    
    // Inject properties from Config Server
    @Value("${product.discount.percentage}")
    private int discountPercentage;
    
    @Value("${product.max.quantity}")
    private int maxQuantity;
    
    @Value("${product.api.timeout}")
    private int apiTimeout;
    
    @Value("${feature.new.checkout.enabled}")
    private boolean newCheckoutEnabled;
    
    @Value("${spring.datasource.url}")
    private String databaseUrl;
    
    /**
     * Get all configuration values
     */
    @GetMapping("/config")
    public Map<String, Object> getConfiguration() {
        Map<String, Object> config = new HashMap<>();
        config.put("discountPercentage", discountPercentage);
        config.put("maxQuantity", maxQuantity);
        config.put("apiTimeout", apiTimeout);
        config.put("newCheckoutEnabled", newCheckoutEnabled);
        config.put("databaseUrl", databaseUrl);
        config.put("message", "Configuration loaded from Config Server");
        return config;
    }
    
    /**
     * Business logic using config values
     */
    @GetMapping("/discount-info")
    public Map<String, Object> getDiscountInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("currentDiscount", discountPercentage + "%");
        info.put("maxQuantityAllowed", maxQuantity);
        
        double originalPrice = 1000.0;
        double discountedPrice = originalPrice - (originalPrice * discountPercentage / 100);
        
        info.put("exampleOriginalPrice", originalPrice);
        info.put("exampleDiscountedPrice", discountedPrice);
        info.put("savings", originalPrice - discountedPrice);
        
        return info;
    }
    
    /**
     * Check feature flags
     */
    @GetMapping("/features")
    public Map<String, Object> getFeatures() {
        Map<String, Object> features = new HashMap<>();
        features.put("newCheckoutEnabled", newCheckoutEnabled);
        features.put("status", newCheckoutEnabled ? "New checkout is LIVE!" : "Using old checkout");
        return features;
    }
    
    /**
     * Health check endpoint
     */
    @GetMapping("/health")
    public Map<String, String> health() {
        Map<String, String> health = new HashMap<>();
        health.put("status", "UP");
        health.put("service", "Product Service");
        health.put("configServer", "Connected");
        return health;
    }
}
```

**🧠 Understanding @Value and @RefreshScope:**

java

```java
// @Value injects property from Config Server
@Value("${product.discount.percentage}")
private int discountPercentage;

Flow:
1. Application starts
2. Connects to Config Server
3. Config Server reads from Git
4. Property "product.discount.percentage" fetched
5. Value injected into variable

// @RefreshScope enables dynamic refresh
@RefreshScope
public class ProductRestController {
    // This bean can be refreshed without restart
}

Without @RefreshScope:
Change config → Must restart service ❌

With @RefreshScope:
Change config → Call /refresh endpoint → Live update ✅
```

### Project Structure

```
product-service/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/ecommerce/product/
│   │   │       ├── ProductServiceApplication.java
│   │   │       └── controller/
│   │   │           └── ProductRestController.java
│   │   └── resources/
│   │       ├── bootstrap.properties
│   │       └── application.properties
│   └── test/
├── pom.xml
└── README.md
```

----------

## 🧪 How to Test Config Server Enabled Application?

### Test Scenario Flow

```
┌──────────────────────────────────────────────┐
│         Testing Workflow                     │
├──────────────────────────────────────────────┤
│ 1. Start Eureka Server (8761)               │
│ 2. Start Config Server (8888)               │
│ 3. Start Product Service (8081)             │
│ 4. Test Config Server directly              │
│ 5. Test Product Service endpoints           │
│ 6. Verify Eureka Dashboard                  │
└──────────────────────────────────────────────┘
```

### Step 1: Start All Services

**Terminal 1: Eureka Server**

bash

```bash
cd eureka-server
mvn spring-boot:run

# Expected output:
# Eureka Server started on port 8761
```

**Terminal 2: Config Server**

bash

```bash
cd config-server
mvn spring-boot:run

# Expected output:
# Config Server started on port 8888
# Located property source: [Git repository configuration]
```

**Terminal 3: Product Service**

bash

```bash
cd product-service
mvn spring-boot:run

# Expected output:
# Located property source: [bootstrap]
# Located property source: [Git/product-service-dev.properties]
# Product Service started on port 8081
```

### Step 2: Test Config Server Directly

**Test 1: Check if Config Server is running**

bash

```bash
# URL: http://localhost:8888/actuator/health

curl http://localhost:8888/actuator/health

# Expected Response:
{
  "status": "UP"
}
```

**Test 2: Fetch configuration for Product Service (dev profile)**

bash

```bash
# URL Pattern: /{application}/{profile}
curl http://localhost:8888/product-service/dev

# Expected Response (JSON format):
{
  "name": "product-service",
  "profiles": ["dev"],
  "label": null,
  "version": "abc123...",
  "state": null,
  "propertySources": [
    {
      "name": "https://github.com/.../product-service-dev.properties",
      "source": {
        "server.port": "8081",
        "spring.application.name": "PRODUCT-SERVICE",
        "product.discount.percentage": "10",
        "product.max.quantity": "100",
        "product.api.timeout": "5000",
        "feature.new.checkout.enabled": "false",
        "spring.datasource.url": "jdbc:mysql://localhost:3306/productdb_dev"
      }
    }
  ]
}
```

**Test 3: Fetch as properties format**

bash

```bash
# URL Pattern: /{application}-{profile}.properties
curl http://localhost:8888/product-service-dev.properties

# Expected Response (Properties format):
product.api.timeout: 5000
product.discount.percentage: 10
product.max.quantity: 100
server.port: 8081
spring.application.name: PRODUCT-SERVICE
spring.datasource.url: jdbc:mysql://localhost:3306/productdb_dev
feature.new.checkout.enabled: false
```

**Test 4: Fetch as YAML format**

bash

```bash
curl http://localhost:8888/product-service-dev.yml

# Expected Response (YAML format):
product:
  api:
    timeout: 5000
  discount:
    percentage: 10
  max:
    quantity: 100
```

### Step 3: Test Product Service Endpoints

**Test 1: Health Check**

bash

```bash
curl http://localhost:8081/api/products/health

# Expected Response:
{
  "status": "UP",
  "service": "Product Service",
  "configServer": "Connected"
}
```

**Test 2: Get All Configuration**

bash

```bash
curl http://localhost:8081/api/products/config

# Expected Response:
{
  "discountPercentage": 10,
  "maxQuantity": 100,
  "apiTimeout": 5000,
  "newCheckoutEnabled": false,
  "databaseUrl": "jdbc:mysql://localhost:3306/productdb_dev",
  "message": "Configuration loaded from Config Server"
}
```

**Test 3: Get Discount Information**

bash

```bash
curl http://localhost:8081/api/products/discount-info

# Expected Response:
{
  "currentDiscount": "10%",
  "maxQuantityAllowed": 100,
  "exampleOriginalPrice": 1000.0,
  "exampleDiscountedPrice": 900.0,
  "savings": 100.0
}
```

**Test 4: Check Feature Flags**

bash

```bash
curl http://localhost:8081/api/products/features

# Expected Response:
{
  "newCheckoutEnabled": false,
  "status": "Using old checkout"
}
```

### Step 4: Verify Eureka Dashboard

1.  Open browser:  `http://localhost:8761`
2.  Check "Instances currently registered with Eureka"

```
Expected Services:
┌─────────────────────────────────────────┐
│ Application         | Status            │
├─────────────────────────────────────────┤
│ CONFIG-SERVER       | UP (1) - localhost│
│ PRODUCT-SERVICE     | UP (1) - localhost│
└─────────────────────────────────────────┘
```

### Step 5: Testing with Different Profiles

**Change to Production Profile:**

1.  Stop Product Service
2.  Modify  `bootstrap.properties`:

properties

```properties
spring.profiles.active=prod  # Changed from 'dev'
```

3.  Restart Product Service
4.  Test again:

bash

```bash
curl http://localhost:8081/api/products/config

# Expected Response (prod values):
{
  "discountPercentage": 5,     # Changed from 10
  "maxQuantity": 1000,          # Changed from 100
  "apiTimeout": 3000,           # Changed from 5000
  "newCheckoutEnabled": true,   # Changed from false
  "databaseUrl": "jdbc:mysql://prod-db-server:3306/productdb"
}
```

### Verification Checklist

```
✅ Eureka Server Dashboard accessible (8761)
✅ Config Server health check passes (8888)
✅ Config Server returns correct properties for dev profile
✅ Config Server returns correct properties for prod profile
✅ Product Service registers with Eureka
✅ Product Service loads config from Config Server
✅ All endpoints return expected data
✅ Profile switching works correctly
```

----------

## ⚖️ What if Same Key is Present at Microservice and Config Server?

### Property Precedence Example

**Scenario:**

```
Git Repository (product-service-dev.properties):
product.discount.percentage=10

Product Service (application.properties):
product.discount.percentage=15

Question: Which value will be used? 🤔
```

### Spring Boot Property Resolution Order

```
Priority (Highest → Lowest):

1️⃣ Command Line Arguments
   java -jar app.jar --product.discount.percentage=20
   
2️⃣ SPRING_APPLICATION_JSON
   export SPRING_APPLICATION_JSON='{"product":{"discount":{"percentage":20}}}'
   
3️⃣ JNDI attributes
   java:comp/env
   
4️⃣ System.properties
   System.setProperty("product.discount.percentage", "20")
   
5️⃣ OS Environment Variables
   export PRODUCT_DISCOUNT_PERCENTAGE=20
   
6️⃣ Config Server Properties ← Most common for microservices
   From Git repository
   
7️⃣ application-{profile}.properties (external)
   Outside JAR file
   
8️⃣ application.properties (external)
   Outside JAR file
   
9️⃣ application-{profile}.properties (packaged)
   Inside JAR file
   
🔟 application.properties (packaged)
   Inside JAR file
   
1️⃣1️⃣ @PropertySource
   In Java code
   
1️⃣2️⃣ Default properties
   SpringApplication.setDefaultProperties()
```

### Practical Example

**Git Repository: product-service-dev.properties**

properties

```properties
product.discount.percentage=10
product.max.quantity=100
product.api.timeout=5000
```

**Local: application.properties**

properties

```properties
product.discount.percentage=15
product.tax.rate=18
```

**Result:**

java

```java
@Value("${product.discount.percentage}")
private int discount;  // Value = 10 (from Config Server, higher priority)

@Value("${product.max.quantity}")
private int maxQty;  // Value = 100 (from Config Server, only source)

@Value("${product.tax.rate}")
private int taxRate;  // Value = 18 (from local, only source)
```

### Visual Representation

```
┌─────────────────────────────────────────────┐
│  Property: product.discount.percentage      │
├─────────────────────────────────────────────┤
│  Source                    | Value | Used?  │
├─────────────────────────────────────────────┤
│  Command Line              |  20   |   ✅   │  Highest
│  Config Server (Git)       |  10   |   ❌   │
│  application.properties    |  15   |   ❌   │  Lowest
└─────────────────────────────────────────────┘
Winner: 20 (Command Line)

If no Command Line:
┌─────────────────────────────────────────────┐
│  Config Server (Git)       |  10   |   ✅   │  Higher
│  application.properties    |  15   |   ❌   │  Lower
└─────────────────────────────────────────────┘
Winner: 10 (Config Server)
```

### Best Practices

```
✅ DO:
- Use Config Server for environment-specific configs
- Use local properties for development defaults
- Use command line for quick testing/overrides
- Document which properties come from where

❌ DON'T:
- Duplicate properties unnecessarily
- Mix critical configs between sources
- Rely on precedence for important values
- Leave conflicting values without comments
```

### Testing Property Precedence

**Test Code:**

java

```java
@RestController
public class PropertyTestController {
    
    @Value("${product.discount.percentage}")
    private int discount;
    
    @Autowired
    private Environment env;
    
    @GetMapping("/property-source")
    public Map<String, Object> getPropertySource() {
        Map<String, Object> result = new HashMap<>();
        result.put("value", discount);
        
        // Check all property sources
        for (PropertySource<?> ps : 
             ((ConfigurableEnvironment) env).getPropertySources()) {
            if (ps.containsProperty("product.discount.percentage")) {
                result.put("source", ps.getName());
                result.put("sourceValue", ps.getProperty("product.discount.percentage"));
            }
        }
        
        return result;
    }
}
```

**Test with different scenarios:**

bash

```bash
# Scenario 1: Only Config Server
curl http://localhost:8081/property-source
# Output: {"value":10, "source":"configServerProperties"}

# Scenario 2: With Command Line Override
java -jar app.jar --product.discount.percentage=20
curl http://localhost:8081/property-source
# Output: {"value":20, "source":"commandLineArgs"}
```

----------

## 🩺 What is Spring Boot Actuator?

### Definition

**Spring Boot Actuator**  provides production-ready features to help you monitor and manage your application. It exposes operational endpoints to interact with your application.

### 🧠 Analogy: The Car Dashboard

```
Car Without Dashboard:           Car With Dashboard (Actuator):
┌──────────────┐                ┌──────────────────────────┐
│              │                │  ⛽ Fuel: 60%            │
│   Engine     │                │  🌡️ Temp: Normal         │
│   Running?   │                │  ⚠️ Warnings: None       │
│   🤷 Don't   │                │  🔧 Diagnostics: Ready   │
│   Know!      │                │  📊 Performance: Good    │
└──────────────┘                └──────────────────────────┘
```

### Key Actuator Endpoints

```
Production Monitoring Endpoints:
┌────────────────────────────────────────────────┐
│ Endpoint         | Purpose                     │
├────────────────────────────────────────────────┤
│ /health          | Application health status   │
│ /info            | Application information     │
│ /metrics         | Application metrics         │
│ /env             | Environment properties      │
│ /loggers         | Logging configuration       │
│ /httptrace       | HTTP request traces         │
│ /threaddump      | Thread dump                 │
│ /heapdump        | Heap dump                   │
│ /refresh         | Refresh configuration       │
│ /shutdown        | Gracefully shutdown app     │
└────────────────────────────────────────────────┘
```

### Adding Actuator

**pom.xml**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**application.properties**

properties

```properties
# Expose all endpoints
management.endpoints.web.exposure.include=*

# Or expose specific endpoints
# management.endpoints.web.exposure.include=health,info,metrics,refresh

# Show detailed health information
management.endpoint.health.show-details=always

# Custom info
info.app.name=Product Service
info.app.version=1.0.0
info.app.description=E-Commerce Product Microservice
```

### Testing Actuator Endpoints

**1. Health Check**

bash

```bash
curl http://localhost:8081/actuator/health

# Response:
{
  "status": "UP",
  "components": {
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 250685575168,
        "free": 100000000000,
        "threshold": 10485760,
        "exists": true
      }
    },
    "ping": {
      "status": "UP"
    },
    "refreshScope": {
      "status": "UP"
    }
  }
}
```

**2. Application Info**

bash

```bash
curl http://localhost:8081/actuator/info

# Response:
{
  "app": {
    "name": "Product Service",
    "version": "1.0.0",
    "description": "E-Commerce Product Microservice"
  }
}
```

**3. Metrics**

bash

```bash
# List all metrics
curl http://localhost:8081/actuator/metrics

# Specific metric (e.g., JVM memory)
curl http://localhost:8081/actuator/metrics/jvm.memory.used

# Response:
{
  "name": "jvm.memory.used",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 156790784.0
    }
  ]
}
```

**4. Environment Properties**

bash

```bash
curl http://localhost:8081/actuator/env

# Shows all environment properties including Config Server properties
```

----------

## 🔄 What is @RefreshScope?

### Definition

**@RefreshScope**  is a Spring Cloud annotation that enables beans to be refreshed dynamically when configuration changes, without restarting the application.

### 🧠 Analogy: The TV Channel Switch

```
Without @RefreshScope:
┌──────────────────────────┐
│  TV showing Channel 5    │
│  Want Channel 10?        │
│  → Turn OFF TV           │  ❌ Downtime!
│  → Change settings       │
│  → Turn ON TV            │
└──────────────────────────┘

With @RefreshScope:
┌──────────────────────────┐
│  TV showing Channel 5    │
│  Want Channel 10?        │
│  → Press remote button   │  ✅ Instant switch!
│  → Channel changes       │
│  → No interruption       │
└──────────────────────────┘
```

### How @RefreshScope Works

```
┌─────────────────────────────────────────────┐
│  Normal Bean Lifecycle                      │
├─────────────────────────────────────────────┤
│  1. Application starts                      │
│  2. Bean created                            │
│  3. Properties injected                     │
│  4. Bean lives until app shutdown           │
│  5. No way to update properties             │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│  @RefreshScope Bean Lifecycle               │
├─────────────────────────────────────────────┤
│  1. Application starts                      │
│  2. Bean created (wrapped in proxy)         │
│  3. Properties injected                     │
│  4. On /refresh call:                       │
│     a. Old bean destroyed                   │
│     b. New bean created                     │
│     c. New properties injected              │
│  5. Application continues without restart   │
└─────────────────────────────────────────────┘
```

### Code Example

**Without @RefreshScope:**

java

```java
@RestController
public class ProductController {
    
    @Value("${product.discount.percentage}")
    private int discount;  // Loaded once at startup
    
    @GetMapping("/discount")
    public int getDiscount() {
        return discount;  // Always returns old value!
    }
}

// Change in Git: discount=20
// Result: Still returns old value (10) ❌
// Solution: Restart application
```

**With @RefreshScope:**

java

```java
@RestController
@RefreshScope  // ← Magic annotation!
public class ProductController {
    
    @Value("${product.discount.percentage}")
    private int discount;  // Can be refreshed dynamically
    
    @GetMapping("/discount")
    public int getDiscount() {
        return discount;  // Returns updated value after /refresh!
    }
}

// Change in Git: discount=20
// Call: POST /actuator/refresh
// Result: Returns new value (20) ✅
// No restart needed!
```

### @RefreshScope Internals

java

```java
// What happens behind the scenes:

// 1. Spring creates a proxy wrapper
┌─────────────────────────────┐
│  Proxy (RefreshScope)       │
│  ┌───────────────────────┐  │
│  │ Actual Bean           │  │
│  │ discount = 10         │  │
│  └───────────────────────┘  │
└─────────────────────────────┘

// 2. On /refresh call
┌─────────────────────────────┐
│  Proxy (RefreshScope)       │
│  ┌───────────────────────┐  │
│  │ Old Bean (destroyed)  │  │ ❌
│  └───────────────────────┘  │
│  ┌───────────────────────┐  │
│  │ New Bean (created)    │  │ ✅
│  │ discount = 20         │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```

### When to Use @RefreshScope

```
✅ USE for:
- Configuration properties that change frequently
- Feature flags
- Business rules
- API endpoints/URLs
- Timeouts and thresholds
- A/B testing parameters

❌ DON'T USE for:
- Database connections (use connection pooling instead)
- Singleton beans with complex state
- Beans with non-idempotent initialization
- Security configurations (restart is safer)
```

----------

## 🔄 How to Get Updated Values Without Restarting?

### The Complete Dynamic Refresh Process

```
┌──────────────────────────────────────────────┐
│  Dynamic Configuration Update Workflow       │
├──────────────────────────────────────────────┤
│  1. Change config in Git repository          │
│  2. Commit and push changes                  │
│  3. Call /actuator/refresh endpoint          │
│  4. Service fetches latest from Config Server│
│  5. @RefreshScope beans recreated            │
│  6. New values available immediately         │
│  7. Zero downtime!                           │
└──────────────────────────────────────────────┘
```

### Step #1: Add Spring Boot Actuator Dependency

**pom.xml**  (Already added in our example)

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

### Step #2: Update application.properties

**src/main/resources/application.properties**

properties

```properties
# Enable refresh endpoint
management.endpoints.web.exposure.include=refresh,health,info

# Or expose all endpoints
# management.endpoints.web.exposure.include=*

# Enable refresh endpoint specifically
management.endpoint.refresh.enabled=true

# Show details in health check
management.endpoint.health.show-details=always
```

### Step #3: Add @RefreshScope at RestController

**ProductRestController.java**  (Updated)

java

```java
package com.ecommerce.product.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/products")
@RefreshScope  // ← THIS IS CRITICAL!
public class ProductRestController {
    
    @Value("${product.discount.percentage}")
    private int discountPercentage;
    
    @Value("${product.max.quantity}")
    private int maxQuantity;
    
    @Value("${feature.new.checkout.enabled}")
    private boolean newCheckoutEnabled;
    
    // Track last refresh time
    private LocalDateTime lastRefreshed = LocalDateTime.now();
    
    @GetMapping("/config")
    public Map<String, Object> getConfiguration() {
        Map<String, Object> config = new HashMap<>();
        config.put("discountPercentage", discountPercentage);
        config.put("maxQuantity", maxQuantity);
        config.put("newCheckoutEnabled", newCheckoutEnabled);
        config.put("lastRefreshed", lastRefreshed);
        config.put("currentTime", LocalDateTime.now());
        return config;
    }
    
    @GetMapping("/discount-calculation")
    public Map<String, Object> calculateDiscount(@RequestParam double price) {
        Map<String, Object> result = new HashMap<>();
        double discountAmount = price * discountPercentage / 100;
        double finalPrice = price - discountAmount;
        
        result.put("originalPrice", price);
        result.put("discountPercentage", discountPercentage);
        result.put("discountAmount", discountAmount);
        result.put("finalPrice", finalPrice);
        result.put("configLastUpdated", lastRefreshed);
        
        return result;
    }
}
```

----------

## 🧪 How to Test Config Server with Refresh Scope?

### Complete Testing Workflow

```
Test Scenario: Change discount from 10% to 25%
┌──────────────────────────────────────────────┐
│  Step 1: Check initial value (10%)           │
│  Step 2: Update Git repository (25%)         │
│  Step 3: Verify Config Server has new value  │
│  Step 4: Check service (still shows 10%)     │
│  Step 5: Call /actuator/refresh endpoint     │
│  Step 6: Check service (now shows 25%) ✅    │
└──────────────────────────────────────────────┘
```

### Detailed Step-by-Step Testing

#### **Step 1: Check Initial Configuration**

bash

```bash
# Test endpoint
curl http://localhost:8081/api/products/config

# Response:
{
  "discountPercentage": 10,
  "maxQuantity": 100,
  "newCheckoutEnabled": false,
  "lastRefreshed": "2025-10-31T10:00:00",
  "currentTime": "2025-10-31T10:00:00"
}
```

#### **Step 2: Update Configuration in Git**

1.  Open your Git repository
2.  Edit  `product-service-dev.properties`

**Before:**

properties

```properties
product.discount.percentage=10
product.max.quantity=100
feature.new.checkout.enabled=false
```

**After:**

properties

```properties
product.discount.percentage=25
product.max.quantity=500
feature.new.checkout.enabled=true
```

3.  Commit and push:

bash

```bash
git add product-service-dev.properties
git commit -m "Updated discount to 25% and enabled new checkout"
git push origin main
```

#### **Step 3: Verify Config Server Has New Values**

bash

```bash
# Check Config Server directly
curl http://localhost:8888/product-service/dev

# Response shows updated values:
{
  "name": "product-service",
  "profiles": ["dev"],
  "propertySources": [
    {
      "source": {
        "product.discount.percentage": "25",  ← Updated!
        "product.max.quantity": "500",        ← Updated!
        "feature.new.checkout.enabled": "true" ← Updated!
      }
    }
  ]
}
```

#### **Step 4: Check Product Service (Still Old Values)**

bash

```bash
# Service still has old values (cached)
curl http://localhost:8081/api/products/config

# Response (still old):
{
  "discountPercentage": 10,  ← Still old!
  "maxQuantity": 100,        ← Still old!
  "newCheckoutEnabled": false ← Still old!
}
```

**🧠 Why?**

```
Without calling /refresh:
┌─────────────────────────────┐
│  Git Repo                   │
│  discount = 25 ✅           │
└────────┬────────────────────┘
         │
┌────────▼────────────────────┐
│  Config Server              │
│  discount = 25 ✅           │
└────────┬────────────────────┘
         │
         │ NOT FETCHED YET
         │
┌────────▼────────────────────┐
│  Product Service            │
│  discount = 10 ❌ (cached)  │
└─────────────────────────────┘
```

#### **Step 5: Call /actuator/refresh Endpoint**

bash

```bash
# Method 1: Using curl
curl -X POST http://localhost:8081/actuator/refresh

# Response (shows which properties changed):
[
  "product.discount.percentage",
  "product.max.quantity",
  "feature.new.checkout.enabled"
]
```

**Alternative Methods:**

bash

```bash
# Method 2: Using Postman
POST http://localhost:8081/actuator/refresh
Headers: Content-Type: application/json

# Method 3: Using HTTPie
http POST http://localhost:8081/actuator/refresh

# Method 4: Using wget
wget --method=POST http://localhost:8081/actuator/refresh
```

**🧠 What Happens During /refresh?**

```
1. POST /actuator/refresh called
   ↓
2. Spring Cloud Config Client connects to Config Server
   ↓
3. Fetches latest properties from Git
   ↓
4. Compares with current properties
   ↓
5. Identifies changed properties
   ↓
6. Destroys @RefreshScope beans
   ↓
7. Recreates beans with new values
   ↓
8. Returns list of changed properties
```

#### **Step 6: Verify Updated Values**

bash

```bash
# Test endpoint again
curl http://localhost:8081/api/products/config

# Response (now updated!):
{
  "discountPercentage": 25,     ← Updated! ✅
  "maxQuantity": 500,            ← Updated! ✅
  "newCheckoutEnabled": true,    ← Updated! ✅
  "lastRefreshed": "2025-10-31T10:05:00",
  "currentTime": "2025-10-31T10:05:00"
}
```

#### **Step 7: Test Business Logic with New Values**

bash

```bash
# Calculate discount with new percentage
curl "http://localhost:8081/api/products/discount-calculation?price=1000"

# Response:
{
  "originalPrice": 1000.0,
  "discountPercentage": 25,        ← New value used!
  "discountAmount": 250.0,         ← Calculated with 25%
  "finalPrice": 750.0,
  "configLastUpdated": "2025-10-31T10:05:00"
}
```

### Complete Testing Comparison

```
┌──────────────────────────────────────────────────────────┐
│  Before /refresh    vs    After /refresh                 │
├──────────────────────────────────────────────────────────┤
│  Discount: 10%            Discount: 25%                  │
│  Max Qty: 100             Max Qty: 500                   │
│  New Checkout: false      New Checkout: true             │
│  $1000 → $900            $1000 → $750                   │
└──────────────────────────────────────────────────────────┘
```

### Testing Multiple Microservices

**Scenario: You have 3 services using the same config**

```
Services:
├── Product Service (8081)
├── Order Service (8082)
└── Payment Service (8083)

Update Config:
1. Change in Git once
2. Refresh each service:
   POST /actuator/refresh on each service
```

**Batch Refresh Script:**

bash

```bash
#!/bin/bash
# refresh-all-services.sh

echo "🔄 Refreshing all microservices..."

curl -X POST http://localhost:8081/actuator/refresh
echo "✅ Product Service refreshed"

curl -X POST http://localhost:8082/actuator/refresh
echo "✅ Order Service refreshed"

curl -X POST http://localhost:8083/actuator/refresh
echo "✅ Payment Service refreshed"

echo "🎉 All services refreshed successfully!"
```

### Advanced: Spring Cloud Bus (Auto-Refresh All Services)

**Problem:**  Manually refreshing each service is tedious

**Solution:**  Use Spring Cloud Bus with RabbitMQ/Kafka

```
Architecture with Spring Cloud Bus:

┌──────────────┐
│   Git Repo   │
│   (Updated)  │
└──────┬───────┘
       │
┌──────▼───────────────┐
│   Config Server      │
└──────┬───────────────┘
       │
┌──────▼───────────────┐
│   Message Broker     │
│   (RabbitMQ/Kafka)   │
└──────┬───────────────┘
       │
       │ Broadcast /bus-refresh
       │
   ┌───┴───┬───────┬───────┐
   │       │       │       │
   ▼       ▼       ▼       ▼
[MS-1]  [MS-2]  [MS-3]  [MS-4]
All services refresh automatically!

Call once: POST /bus-refresh
Result: All services updated ✅
```

### Troubleshooting Refresh Issues

#### Issue 1: /refresh Not Working

bash

```bash
# Check if endpoint is enabled
curl http://localhost:8081/actuator

# If 'refresh' is not in the list:
# Add to application.properties:
management.endpoints.web.exposure.include=refresh
```

#### Issue 2: Properties Not Updating

**Checklist:**

```
❌ Common Mistakes:
1. Forgot @RefreshScope on controller
2. Properties cached in non-refreshable bean
3. Config Server not pulling latest from Git
4. Wrong property names in @Value

✅ Solutions:
1. Add @RefreshScope to controller class
2. Move @Value to @RefreshScope bean
3. Check Config Server logs
4. Verify property names match exactly
```

#### Issue 3: Partial Update

java

```java
// ❌ Problem: Only some properties update
@Component
public class ConfigHolder {
    @Value("${product.discount}")
    private int discount;  // Updates ✅
}

@Service
public class ProductService {
    @Value("${product.discount}")
    private int discount;  // Doesn't update ❌
}

// ✅ Solution: Add @RefreshScope to both
@Component
@RefreshScope  // ← Add this
public class ConfigHolder { ... }

@Service
@RefreshScope  // ← And this
public class ProductService { ... }
```

### Testing Checklist

```
✅ Pre-Refresh Checklist:
□ Actuator dependency added
□ /refresh endpoint exposed
□ @RefreshScope added to controller
□ Config Server is running
□ Git repository updated and pushed

✅ During Testing:
□ Initial values confirmed
□ Config Server shows new values
□ Service shows old values (before refresh)
□ POST /actuator/refresh called
□ Response shows changed properties

✅ Post-Refresh Validation:
□ Service shows new values
□ Business logic uses new values
□ No errors in logs
□ Health check passes
```

----------

## 📊 Visual Workflow Summary

### Complete Architecture Flow

```
┌────────────────────────────────────────────────────────┐
│               MICROSERVICES WITH CONFIG SERVER         │
├────────────────────────────────────────────────────────┤
│                                                        │
│  1. STARTUP PHASE                                      │
│  ┌──────────┐                                          │
│  │ Eureka   │ :8761 (Service Registry)                │
│  │ Server   │                                          │
│  └────┬─────┘                                          │
│       │                                                │
│  ┌────▼─────┐                                          │
│  │ Config   │ :8888 (Configuration Server)            │
│  │ Server   │ ← Reads from Git                        │
│  └────┬─────┘                                          │
│       │                                                │
│  ┌────▼────────┐                                       │
│  │ Product     │ :8081 (Business Service)             │
│  │ Service     │ ← Fetches config on startup          │
│  └─────────────┘                                       │
│                                                        │
│  2. RUNTIME PHASE                                      │
│  ┌─────────────┐                                       │
│  │   Client    │                                       │
│  └──────┬──────┘                                       │
│         │ HTTP Request                                 │
│  ┌──────▼──────────┐                                   │
│  │ Product Service │ Uses cached config               │
│  └─────────────────┘                                   │
│                                                        │
│  3. UPDATE PHASE                                       │
│  ┌──────────────┐                                      │
│  │  Git Repo    │ Config updated                      │
│  │  (Updated)   │                                      │
│  └──────┬───────┘                                      │
│         │ Commit & Push                                │
│  ┌──────▼───────┐                                      │
│  │ Config Server│ Pulls latest                         │
│  └──────┬───────┘                                      │
│         │                                              │
│         │ POST /actuator/refresh                       │
│  ┌──────▼───────────┐                                  │
│  │ Product Service  │ Fetches & applies new config    │
│  │ @RefreshScope    │ No restart needed! ✅           │
│  └──────────────────┘                                  │
└────────────────────────────────────────────────────────┘
```

### Configuration Priority Pyramid

```
        ┌─────────────────────────┐
        │   Command Line Args     │  Highest Priority
        ├─────────────────────────┤
        │   Environment Variables │
        ├─────────────────────────┤
        │   Config Server         │  ← Recommended for microservices
        ├─────────────────────────┤
        │   application.properties│
        │   (external)            │
        ├─────────────────────────┤
        │   application.properties│
        │   (packaged)            │
        └─────────────────────────┘  Lowest Priority
```

### Refresh Scope Lifecycle

```
┌──────────────────────────────────────────────────────┐
│  Bean Lifecycle with @RefreshScope                   │
├──────────────────────────────────────────────────────┤
│                                                      │
│  Application Start                                   │
│         │                                            │
│         ▼                                            │
│  ┌──────────────┐                                    │
│  │ Create Bean  │ discount = 10                     │
│  └──────┬───────┘                                    │
│         │                                            │
│         ▼                                            │
│  ┌──────────────┐                                    │
│  │ Bean Active  │ Serving requests                  │
│  └──────┬───────┘                                    │
│         │                                            │
│    Config Changed in Git                            │
│         │                                            │
│         ▼                                            │
│  POST /actuator/refresh                             │
│         │                                            │
│         ▼                                            │
│  ┌──────────────┐                                    │
│  │ Destroy Bean │ ❌ Old bean removed                │
│  └──────┬───────┘                                    │
│         │                                            │
│         ▼                                            │
│  ┌──────────────┐                                    │
│  │ Create Bean  │ discount = 25 (new value)         │
│  └──────┬───────┘                                    │
│         │                                            │
│         ▼                                            │
│  ┌──────────────┐                                    │
│  │ Bean Active  │ Serving with new config           │
│  └──────────────┘                                    │
│         │                                            │
│         ▼                                            │
│  Continue serving (zero downtime) ✅                 │
└──────────────────────────────────────────────────────┘
```

----------

## 🎓 Conclusion

### Key Takeaways

#### 1.  **Centralized Configuration Management**

```
Benefits:
✅ Single source of truth
✅ Environment-specific configs
✅ Version control with Git
✅ Team collaboration
✅ Audit trail
✅ Easy rollback
```

#### 2.  **Dynamic Updates**

```
Traditional Approach:
Config Change → Rebuild → Redeploy → Downtime ❌

Config Server Approach:
Config Change → Git Push → /refresh → Live Update ✅
(Zero downtime!)
```

#### 3.  **Scalability**

```
5 Microservices:
Config Server → Update once, affect all ✅

50 Microservices:
Config Server → Still update once! ✅

500 Microservices:
Config Server + Bus → Broadcast refresh! ✅
```

### Architecture Best Practices

#### 1.  **Repository Structure**

```
config-repo/
├── application.properties              (Common)
├── application-dev.properties          (Dev environment)
├── application-test.properties         (Test environment)
├── application-prod.properties         (Production)
├── service-a-dev.properties            (Service-specific)
├── service-a-prod.properties
├── service-b-dev.properties
└── service-b-prod.properties

Naming Convention:
{service-name}-{profile}.properties
```

#### 2.  **Security Best Practices**

```
✅ DO:
- Encrypt sensitive properties
- Use private Git repositories
- Implement authentication for Config Server
- Use HTTPS for communication
- Rotate credentials regularly
- Use Spring Cloud Vault for secrets

❌ DON'T:
- Store passwords in plain text
- Commit sensitive data to Git
- Use public repositories for configs
- Expose Config Server publicly
```

#### 3.  **Production Recommendations**

```
High Availability:
┌──────────────────┐  ┌──────────────────┐
│ Config Server 1  │  │ Config Server 2  │
│ (Active)         │  │ (Standby)        │
└────────┬─────────┘  └────────┬─────────┘
         │                     │
         └──────────┬──────────┘
                    │
         ┌──────────▼──────────┐
         │   Load Balancer     │
         └─────────────────────┘

Monitoring:
- Health checks every 30 seconds
- Metrics collection (Prometheus)
- Alerting on failures
- Distributed tracing (Zipkin)

Backup Strategy:
- Multiple Git repository mirrors
- Regular backups of Config Server
- Disaster recovery plan
```

#### 4.  **Performance Optimization**

```
1. Enable Config Server caching
spring.cloud.config.server.git.clone-on-start=true

2. Use local Git clone
spring.cloud.config.server.git.basedir=/var/config-repo

3. Implement client-side caching
spring.cloud.config.client.cache-enabled=true

4. Use Spring Cloud Bus for batch refresh
(Avoid refreshing services individually)
```

### Common Patterns

#### Pattern 1: Feature Flags

properties

```properties
# Git repository
feature.new-ui.enabled=false
feature.payment-gateway-v2.enabled=false
feature.recommendation-engine.enabled=true

# In code
@Value("${feature.new-ui.enabled}")
private boolean newUIEnabled;

if (newUIEnabled) {
    return renderNewUI();
} else {
    return renderOldUI();
}

# Update in Git → Refresh → Feature toggled!
```

#### Pattern 2: A/B Testing

properties

```properties
# Percentage-based rollout
feature.experiment.rollout-percentage=10

# In code
int userId = getCurrentUserId();
int bucket = userId % 100;

if (bucket < rolloutPercentage) {
    return experimentalFeature();
} else {
    return standardFeature();
}

# Gradually increase: 10% → 25% → 50% → 100%
```

#### Pattern 3: Environment-Specific URLs

properties

```properties
# Dev
payment.gateway.url=https://sandbox.payment.com
notification.service.url=http://localhost:9000

# Prod
payment.gateway.url=https://api.payment.com
notification.service.url=https://notifications.prod.com

# Services automatically use correct URL per environment
```

### Troubleshooting Guide

#### Issue 1: Config Server Not Starting

```
Error: Failed to clone Git repository

Solutions:
1. Check Git URL is correct
2. Verify network connectivity
3. Check Git credentials (if private repo)
4. Ensure Git is installed on server
5. Try HTTPS instead of SSH (or vice versa)
```

#### Issue 2: Properties Not Loading

```
Error: Could not resolve placeholder 'property.name'

Solutions:
1. Verify property exists in Git
2. Check application name matches
   bootstrap.properties: spring.application.name=product-service
   Git file: product-service-dev.properties
3. Confirm profile is correct
4. Check Config Server logs
5. Test Config Server endpoint directly
```

#### Issue 3: Refresh Not Working

```
Error: Properties not updating after /refresh

Solutions:
1. Add @RefreshScope to controller
2. Verify actuator dependency is present
3. Check management.endpoints.web.exposure.include
4. Ensure POST method is used (not GET)
5. Check logs for errors during refresh
```
