# Complete Microservices Development Guide with Spring Boot

## Table of Contents

1.  Introduction to Microservices
2.  Microservices Architecture Overview
3.  Case Study: Online Food Delivery System
4.  Step-by-Step Development
5.  Service Communication
6.  Infrastructure Components
7.  Database Strategy
8.  Testing
9.  Resilience and Observability
10.  Deployment
11.  Best Practice

----------

## 1. Introduction to Microservices 

### What are Microservices?

**Definition**: Microservices are an architectural style where an application is composed of small, independent services that communicate over well-defined APIs. Each service is self-contained, focuses on a specific business capability, and can be developed, deployed, and scaled independently.

**Memory Analogy - Human Body**: Think of microservices like organs in the human body:

-   **Heart (Payment Service)**: Handles critical transactions
-   **Brain (API Gateway)**: Routes requests and makes decisions
-   **Lungs (Notification Service)**: Communicates with the outside world
-   **Digestive System (Order Service)**: Processes orders step by step
-   **Nervous System (Message Bus/Kafka)**: Enables communication between organs

If one organ has an issue, the others continue functioning. The body doesn't shut down completely!

### Why Microservices?

#### Traditional Problems with Monoliths:

1.  **Tight Coupling**: All code in one application
2.  **Single Point of Failure**: If one module crashes, everything crashes
3.  **Difficult Scaling**: Must scale entire application, not just the needed part
4.  **Long Deployment Cycles**: Small change requires full redeployment
5.  **Technology Lock-in**: Stuck with one tech stack

#### Microservices Solutions:

1.  **Loose Coupling**: Services are independent
2.  **Fault Isolation**: One service failure doesn't crash everything
3.  **Selective Scaling**: Scale only what needs scaling
4.  **Faster Deployments**: Deploy individual services
5.  **Technology Diversity**: Each service can use different tech

### Monolith vs Microservices

#### Visual Comparison:

**Monolith Architecture:**

```
┌─────────────────────────────────────┐
│                                     │
│  Single Application (WAR/JAR)       │
│                                     │
│  ┌──────────┐  ┌──────────┐       │
│  │   UI     │  │ Business │       │
│  │  Layer   │──│  Logic   │       │
│  └──────────┘  └──────────┘       │
│                     │               │
│              ┌──────────┐          │
│              │ Database │          │
│              │  Layer   │          │
│              └──────────┘          │
│                                     │
└─────────────────────────────────────┘
        One Database
```

**Microservices Architecture:**

```
┌────────────┐  ┌────────────┐  ┌────────────┐
│  Service A │  │  Service B │  │  Service C │
│   (Java)   │  │  (Node.js) │  │  (Python)  │
└─────┬──────┘  └─────┬──────┘  └─────┬──────┘
      │               │               │
   ┌──┴──┐         ┌──┴──┐         ┌──┴──┐
   │ DB1 │         │ DB2 │         │ DB3 │
   └─────┘         └─────┘         └─────┘
```

### Real-World Analogy: City vs Megastore

**Monolith = Megastore (Walmart)**

-   Everything under one roof
-   If power goes out, entire store closes
-   Must expand entire building to add capacity
-   One management system controls everything
-   All employees must follow same rules

**Microservices = City with Specialized Shops**

-   Bakery, butcher, pharmacy, bookstore (separate services)
-   If bakery closes, others remain open
-   Each shop can expand independently
-   Each shop has its own management
-   Each shop can operate differently
-   Connected by roads (APIs) and phone lines (message queues)

### Advantages of Microservices

1.  **Independent Deployability**: Deploy services without affecting others
2.  **Technology Heterogeneity**: Use the best tool for each job
3.  **Resilience**: Failure in one service doesn't cascade
4.  **Scalability**: Scale services independently based on demand
5.  **Team Autonomy**: Teams own entire services end-to-end
6.  **Easier Maintenance**: Smaller codebases are easier to understand
7.  **Faster Time to Market**: Parallel development and deployment

### Challenges of Microservices

1.  **Distributed System Complexity**: Network latency, failures
2.  **Data Consistency**: Managing distributed transactions
3.  **Testing Complexity**: Testing integrated systems
4.  **Operational Overhead**: More services to monitor and deploy
5.  **Network Communication**: More API calls = potential bottlenecks
6.  **Debugging Difficulty**: Tracing requests across services
7.  **Initial Setup Cost**: Infrastructure requirements

----------

## 2. Microservices Architecture Overview {#architecture}

### Core Components

```
                    ┌─────────────────┐
                    │   API Gateway   │ ← Single Entry Point
                    └────────┬────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
    ┌────▼─────┐      ┌─────▼──────┐     ┌─────▼──────┐
    │ Service  │      │  Service   │     │  Service   │
    │    A     │      │     B      │     │     C      │
    └────┬─────┘      └─────┬──────┘     └─────┬──────┘
         │                  │                   │
    ┌────▼─────┐      ┌─────▼──────┐     ┌─────▼──────┐
    │   DB A   │      │    DB B    │     │    DB C    │
    └──────────┘      └────────────┘     └────────────┘

    ┌─────────────────────────────────────────────────┐
    │         Service Discovery (Eureka)              │
    └─────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────┐
    │       Config Server (Centralized Config)        │
    └─────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────┐
    │      Message Broker (Kafka/RabbitMQ)            │
    └─────────────────────────────────────────────────┘
```

### 1. API Gateway

**What**: Single entry point for all client requests

**Why**:

-   Routing to appropriate services
-   Authentication & Authorization
-   Rate limiting
-   Load balancing
-   Request/Response transformation

**Analogy**: Reception desk at a hospital. You don't directly go to a doctor; the receptionist directs you to the right department.

### 2. Service Discovery

**What**: Registry of all available service instances

**Why**:

-   Dynamic service location
-   Load balancing across instances
-   Health checks

**Analogy**: Phone directory. Instead of memorizing addresses, you look up the service name to find where it lives.

### 3. Config Server

**What**: Centralized configuration management

**Why**:

-   Single source of truth for configurations
-   Environment-specific configs
-   Change configs without redeployment

**Analogy**: Company policy handbook. Instead of each department maintaining rules, everyone refers to one central document.

### 4. Circuit Breaker

**What**: Prevents cascading failures

**Why**:

-   Stops calling failing services
-   Provides fallback responses
-   Allows service to recover

**Analogy**: Electrical circuit breaker in your home. When overloaded, it trips to prevent fire, and you can reset once the issue is fixed.

### 5. Database per Service

**What**: Each microservice has its own database

**Why**:

-   Service independence
-   Technology flexibility
-   Isolated failures

**Analogy**: Each shop in a mall has its own inventory system. They don't share the same storage room.

### Service Communication Types

#### Synchronous Communication (REST)

```
Client → [Request] → Service A → [Request] → Service B
       ← [Response] ←          ← [Response] ←
```

**When to Use**:

-   Real-time responses needed
-   Simple request-response patterns
-   User-facing operations

**Example**: Fetching user profile data

#### Asynchronous Communication (Kafka/RabbitMQ)

```
Service A → [Event/Message] → Message Broker → Service B
                                              → Service C
                                              → Service D
```

**When to Use**:

-   Fire-and-forget operations
-   Event-driven architecture
-   Multiple services need same data
-   Long-running operations

**Example**: Sending email notifications, processing payments

----------

## 3. Case Study: Online Food Delivery System 

### Problem Statement

Build a food delivery platform like  **Swiggy/Zomato**  that allows:

-   Users to browse restaurants and place orders
-   Restaurants to manage menu and receive orders
-   Real-time order tracking
-   Payment processing
-   Notifications (SMS, Email, Push)

### System Requirements

**Functional Requirements:**

1.  User registration and authentication
2.  Browse restaurants by location
3.  View restaurant menus
4.  Place orders
5.  Make payments
6.  Track order status
7.  Send notifications
8.  Restaurant dashboard

**Non-Functional Requirements:**

1.  High availability (99.9% uptime)
2.  Scalability (handle millions of users)
3.  Low latency (< 200ms response time)
4.  Fault tolerance
5.  Data consistency

### Identified Microservices

Let's break down the monolith into services:

```
┌──────────────────────────────────────────────────────┐
│              API GATEWAY                             │
│         (Spring Cloud Gateway)                       │
└───────────────────┬──────────────────────────────────┘
                    │
    ┌───────────────┼───────────────────┐
    │               │                   │
┌───▼─────┐   ┌────▼──────┐    ┌──────▼──────┐
│  USER   │   │RESTAURANT │    │    ORDER    │
│ SERVICE │   │  SERVICE  │    │   SERVICE   │
└────┬────┘   └─────┬─────┘    └──────┬──────┘
     │              │                  │
┌────▼────┐   ┌─────▼─────┐    ┌──────▼──────┐
│ User DB │   │   Rest    │    │  Order DB   │
└─────────┘   │    DB     │    └──────┬──────┘
              └───────────┘           │
                                      │
    ┌─────────────────────────────────┼──────────┐
    │                                 │          │
┌───▼──────┐              ┌──────────▼─────┐ ┌──▼────────┐
│ PAYMENT  │              │  NOTIFICATION  │ │ DELIVERY  │
│ SERVICE  │              │    SERVICE     │ │  SERVICE  │
└────┬─────┘              └────────┬───────┘ └─────┬─────┘
     │                             │               │
┌────▼────┐                   ┌────▼──────┐  ┌─────▼────┐
│Payment  │                   │Notification│  │ Delivery │
│   DB    │                   │    DB     │  │    DB    │
└─────────┘                   └───────────┘  └──────────┘

        ┌─────────────────────────────────┐
        │  KAFKA MESSAGE BROKER           │
        │  (Event-Driven Communication)   │
        └─────────────────────────────────┘

        ┌─────────────────────────────────┐
        │  EUREKA SERVICE DISCOVERY       │
        └─────────────────────────────────┘

        ┌─────────────────────────────────┐
        │  CONFIG SERVER                  │
        └─────────────────────────────────┘
```

### Service Responsibilities


### Service Interactions

**Scenario: User Places an Order**

```
1. User → API Gateway → Order Service
   "Create order for Restaurant X"

2. Order Service → Restaurant Service (REST)
   "Validate restaurant and items"

3. Order Service → User Service (REST)
   "Validate user and address"

4. Order Service → Payment Service (REST)
   "Process payment for ₹500"

5. Payment Service → Kafka → [OrderPaid Event]

6. Order Service (listens to OrderPaid) → Updates order status

7. Order Service → Kafka → [OrderConfirmed Event]

8. Notification Service (listens) → Sends email/SMS

9. Delivery Service (listens) → Assigns delivery partner

10. Delivery Service → Kafka → [DeliveryAssigned Event]

11. Notification Service (listens) → Notifies user
```

### Technology Stack Decisions
