# Netflix Eureka: Complete Tutorial with Service Registry & Discovery

## Table of Contents

1.  Why Netflix Eureka is Required?
2.  What is Netflix Eureka & Eureka Server?
3.  Service Registry in Microservices
4.  Service Discovery in Microservices
5.  Software/Technology Stack
6.  Creating Eureka Server
7.  Registering Microservices
8.  Discovering Microservices
9.  Complete Use Case Example
10.  Execution & Testing
11.  Conclusion

----------

## 1. Why Netflix Eureka is Required?

### The Problem in Microservices Architecture

**Analogy: The Phone Directory Problem** Imagine you're in a large office building with 100+ employees. Without a phone directory:

-   You need to memorize everyone's extension number
-   When someone moves to a new desk (new extension), you lose contact
-   New employees join, but you don't know their numbers
-   Multiple people do the same job, but you only know one person's number

**Real-World Microservices Challenge:**

```
Traditional Approach (Hardcoded URLs):
┌─────────────┐
│ Order       │ http://payment-service:8081/process
│ Service     ├────────────────────────────────────►
│             │ (What if Payment Service moves to 8082?)
└─────────────┘ (What if Payment Service has 5 instances?)
```

**Problems with Hardcoded Configuration:**

1.  **No Dynamic Scaling**: Can't add/remove service instances dynamically
2.  **No Fault Tolerance**: If one instance fails, requests still go to dead instance
3.  **Manual Configuration**: Need to update all services when URLs change
4.  **No Load Balancing**: Can't distribute load across multiple instances
5.  **Deployment Nightmares**: Configuration files become unmanageable

### The Solution: Service Registry & Discovery

```
With Eureka:
┌─────────────┐      1. Where is     ┌──────────────┐
│ Order       │      Payment Service? │   EUREKA     │
│ Service     ├─────────────────────►│   SERVER     │
└─────────────┘                      │ (Directory)   │
                                     └──────┬───────┘
                     2. Here are all        │
                     healthy instances      │ 3. Auto-registers
                            ◄───────────────┘    location & health
                                                  
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Payment     │  │ Payment     │  │ Payment     │
│ Instance-1  │  │ Instance-2  │  │ Instance-3  │
└─────────────┘  └─────────────┘  └─────────────┘
```

----------

## 2. What is Netflix Eureka & Eureka Server?
### Netflix Eureka

**Definition**: Netflix Eureka is a REST-based service registry and discovery tool developed by Netflix for resilient mid-tier load balancing and failover in cloud environments.

**Analogy: GPS Navigation System**

-   **Eureka Server** = GPS Satellite Network (knows where everything is)
-   **Service Registration** = Broadcasting your location to satellites
-   **Service Discovery** = Finding the nearest restaurant using GPS

### Components of Eureka

#### A) Eureka Server

-   **Role**: Central registry/database of all microservices
-   **Responsibilities**:
    -   Maintains registry of all service instances
    -   Receives heartbeats from registered services (health checks)
    -   Provides service instance information to clients
    -   Evicts dead instances from registry

#### B) Eureka Client

-   **Role**: Microservice that registers with Eureka Server
-   **Responsibilities**:
    -   Registers itself with Eureka Server on startup
    -   Sends heartbeat every 30 seconds (default)
    -   Fetches registry from server
    -   De-registers on shutdown

### Eureka Architecture

```
┌────────────────────────────────────────────────────────────┐
│                    EUREKA SERVER (Port 8761)               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │            SERVICE REGISTRY (In-Memory)              │  │
│  │                                                      │  │
│  │  Service Name    │  Instance ID    │  Status  │ URL │  │
│  │  ─────────────────────────────────────────────────  │  │
│  │  ORDER-SERVICE   │  order-001      │  UP      │ ... │  │
│  │  ORDER-SERVICE   │  order-002      │  UP      │ ... │  │
│  │  PAYMENT-SERVICE │  payment-001    │  UP      │ ... │  │
│  │  PAYMENT-SERVICE │  payment-002    │  DOWN    │ ... │  │
│  │  PRODUCT-SERVICE │  product-001    │  UP      │ ... │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
           ▲                    ▲                    ▲
           │ Heartbeat          │ Register           │ Fetch Registry
           │ (30s)              │ (On Startup)       │ (30s)
           │                    │                    │
    ┌──────┴───────┐    ┌──────┴───────┐    ┌──────┴───────┐
    │   ORDER      │    │  PAYMENT     │    │  PRODUCT     │
    │   SERVICE    │    │  SERVICE     │    │  SERVICE     │
    │ (Eureka      │    │ (Eureka      │    │ (Eureka      │
    │  Client)     │    │  Client)     │    │  Client)     │
    └──────────────┘    └──────────────┘    └──────────────┘
```

----------

## 3. Service Registry in Microservices 

### What is Service Registry?

**Definition**: A service registry is a database containing the network locations of service instances. It acts as a central directory where microservices register themselves and discover other services.

**Analogy: Hotel Reception Desk**

```
┌─────────────────────────────────────────┐
│        HOTEL RECEPTION DESK             │
│      (SERVICE REGISTRY)                 │
│                                         │
│  Guest Name     │  Room Number │ Status│
│  ──────────────────────────────────────│
│  John (Order)   │  Room 101    │ IN   │
│  Mary (Payment) │  Room 205    │ IN   │
│  Bob (Product)  │  Room 310    │ OUT  │
└─────────────────────────────────────────┘

When John needs to meet Mary, he asks reception
for her room number instead of searching all 300 rooms!
```

### Types of Service Registry Patterns

#### A) Self-Registration Pattern (Used by Eureka)

```
┌──────────────┐
│  SERVICE A   │
│              │  1. I'm starting up!
│  (Eureka     │     My URL is http://192.168.1.10:8080
│   Client)    ├────────────────────────────────────►
│              │                                    ┌────────────┐
│              │  2. Registered! Send heartbeat    │  EUREKA    │
│              │     every 30 seconds              │  SERVER    │
│              │◄──────────────────────────────────┤            │
└──────────────┘                                   └────────────┘
```

**Advantages:**

-   Service controls its registration logic
-   Simple and straightforward
-   Service knows when it's ready to receive traffic

**Disadvantages:**

-   Couples service to registry implementation
-   Every service needs registry client code

#### B) Third-Party Registration Pattern

```
┌──────────────┐                           ┌────────────┐
│  SERVICE A   │                           │  EUREKA    │
│              │                           │  SERVER    │
│ (No Eureka   │                           └────────────┘
│  knowledge)  │                                  ▲
└──────────────┘                                  │
       │                                          │ Registers
       │ Health Check                             │ on behalf
       ▼                                          │
┌──────────────┐                                  │
│  REGISTRAR   │──────────────────────────────────┘
│  (Sidecar)   │
└──────────────┘
```

### Service Registry Data Model

json

```json
{
  "application": "ORDER-SERVICE",
  "instance": {
    "instanceId": "order-service-001",
    "hostName": "192.168.1.10",
    "app": "ORDER-SERVICE",
    "ipAddr": "192.168.1.10",
    "status": "UP",
    "port": {
      "enabled": true,
      "port": 8080
    },
    "healthCheckUrl": "http://192.168.1.10:8080/actuator/health",
    "statusPageUrl": "http://192.168.1.10:8080/actuator/info",
    "homePageUrl": "http://192.168.1.10:8080/",
    "metadata": {
      "version": "1.0.0",
      "zone": "us-east-1a"
    },
    "lastUpdatedTimestamp": 1635789012345,
    "lastDirtyTimestamp": 1635789012345,
    "leaseInfo": {
      "renewalIntervalInSecs": 30,
      "durationInSecs": 90
    }
  }
}
```

----------

## 4. Service Discovery in Microservices 

### What is Service Discovery?

**Definition**: Service discovery is the mechanism by which microservices locate and communicate with each other dynamically without hardcoded addresses.

**Analogy: Restaurant Delivery Service**

```
YOU (Order Service) → Want pizza from Restaurant (Payment Service)

Without Discovery:
❌ Call hardcoded phone number → Number changed → Can't order!

With Discovery (Eureka):
✅ Call directory service (411) → "Here's current number" → Order placed!
```

### Discovery Mechanisms

#### A) Client-Side Discovery (Used by Eureka)

```
┌─────────────────────────────────────────────────────────┐
│  CLIENT-SIDE DISCOVERY FLOW                             │
└─────────────────────────────────────────────────────────┘

Step 1: Fetch Registry
┌──────────────┐  1. Give me all     ┌────────────┐
│ Order        │     PAYMENT-SERVICE │  EUREKA    │
│ Service      ├────────────────────►│  SERVER    │
└──────────────┘     instances       └────────────┘
                          │
                          │ 2. Here's the list:
                          │    - http://payment-1:8081 (UP)
                          │    - http://payment-2:8081 (UP)
                          ▼    - http://payment-3:8081 (DOWN)
┌──────────────┐
│ Order        │
│ Service      │
└──────────────┘

Step 2: Choose Instance (Load Balance)
┌──────────────┐
│ Order        │  3. I'll use Round Robin:
│ Service      │     Request 1 → payment-1
│ (Has         │     Request 2 → payment-2
│  Registry)   │     Request 3 → payment-1
└──────────────┘

Step 3: Direct Communication
┌──────────────┐                    ┌──────────────┐
│ Order        │  4. API Call       │  Payment-1   │
│ Service      ├───────────────────►│  Service     │
└──────────────┘                    └──────────────┘
```

**Advantages:**

-   No single point of failure (no proxy)
-   Client controls load balancing
-   Fewer network hops (direct communication)

**Disadvantages:**

-   Client needs discovery logic
-   Couples client to discovery mechanism

#### B) Server-Side Discovery

```
┌──────────────┐                    ┌────────────┐
│ Order        │  1. Call           │  LOAD      │
│ Service      ├───────────────────►│  BALANCER  │
└──────────────┘  PAYMENT-SERVICE   │  (Proxy)   │
                                    └──────┬─────┘
                                           │
                                           │ 2. Query
                                           │
                                    ┌──────▼─────┐
                                    │  EUREKA    │
                                    │  SERVER    │
                                    └────────────┘
                                           │
                     3. Route to healthy   │
                        instance           │
                  ┌───────────┬────────────┘
                  ▼           ▼
          ┌──────────┐  ┌──────────┐
          │Payment-1 │  │Payment-2 │
          └──────────┘  └──────────┘
```

----------

## 5. Software/Technology Stack

### Required Technologies

```
┌────────────────────────────────────────────────────────┐
│  TECHNOLOGY STACK FOR EUREKA MICROSERVICES             │
└────────────────────────────────────────────────────────┘

Core Framework:
├─ Java 11 or higher
├─ Spring Boot 2.7.x or 3.x
└─ Maven 3.6+ or Gradle 7+

Spring Cloud Dependencies:
├─ Spring Cloud Netflix Eureka Server
├─ Spring Cloud Netflix Eureka Client
├─ Spring Cloud Starter LoadBalancer (Ribbon deprecated)
└─ Spring Cloud Version: 2021.0.x (Jubilee) or later

Additional Dependencies:
├─ Spring Boot Starter Web (REST APIs)
├─ Spring Boot Starter Actuator (Health checks)
├─ Lombok (Optional - reduces boilerplate)
└─ Spring Boot DevTools (Optional - development)

Build Tools:
├─ Maven (pom.xml)
└─ Gradle (build.gradle)

IDE:
├─ IntelliJ IDEA (Recommended)
├─ Eclipse with Spring Tools Suite
└─ Visual Studio Code with Spring extensions
```




----------

## 6. Creating Eureka Server {#creating-eureka-server}

### Step-by-Step Implementation

#### Step 1: Create Spring Boot Project

**Using Spring Initializr (start.spring.io):**

```
Project: Maven
Language: Java
Spring Boot: 2.7.14
Project Metadata:
  Group: com.example
  Artifact: eureka-server
  Name: eureka-server
  Package name: com.example.eurekaserver
  Packaging: Jar
  Java: 11

Dependencies:
  - Eureka Server
```

#### Step 2: Maven Dependencies (pom.xml)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.14</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>eureka-server</artifactId>
    <version>1.0.0</version>
    <name>eureka-server</name>
    <description>Eureka Server for Service Registry</description>
    
    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.8</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Eureka Server Dependency -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        
        <!-- Actuator for Health Checks -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Step 3: Main Application Class

java

```java
package com.example.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka Server Application
 * 
 * @EnableEurekaServer - This annotation makes this Spring Boot app 
 * act as a Eureka Server (Service Registry)
 * 
 * Think of this as setting up a "Phone Directory Building"
 * where all microservices will come to register themselves
 */
@SpringBootApplication
@EnableEurekaServer  // ⭐ KEY ANNOTATION - Enables Eureka Server
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
        System.out.println("🚀 Eureka Server Started Successfully!");
        System.out.println("📍 Dashboard: http://localhost:8761");
    }
}
```

#### Step 4: Application Configuration (application.yml)

yaml

```yaml
# Eureka Server Configuration
server:
  port: 8761  # Standard port for Eureka Server

spring:
  application:
    name: eureka-server  # Application name

eureka:
  instance:
    hostname: localhost  # Server hostname
    
  client:
    # Should this server register itself as a client? NO!
    # (It's the registry itself, not a client)
    register-with-eureka: false  # ⭐ Don't register with itself
    fetch-registry: false        # ⭐ Don't fetch registry from itself
    
    service-url:
      # URL where clients can reach this server
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    # How long to wait before removing inactive services (milliseconds)
    eviction-interval-timer-in-ms: 5000  # Check every 5 seconds
    
    # Disable self-preservation mode for development
    # (In production, keep it enabled)
    enable-self-preservation: false  # ⚠️ Development only
    
    # Expected heartbeat threshold percentage
    renewal-percent-threshold: 0.85
    
# Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

# Logging Configuration
logging:
  level:
    com.netflix.eureka: DEBUG
    com.netflix.discovery: DEBUG
```

**Configuration Explanation:**

```
┌─────────────────────────────────────────────────────────┐
│  CONFIGURATION BREAKDOWN                                │
└─────────────────────────────────────────────────────────┘

register-with-eureka: false
├─ Why? Eureka Server doesn't need to register with itself
└─ Analogy: The phone directory doesn't list itself

fetch-registry: false
├─ Why? Server IS the registry, no need to fetch
└─ Analogy: The library doesn't check itself for books

enable-self-preservation: false (Development)
├─ What? Prevents Eureka from keeping dead services
├─ Production: Set to TRUE (prevents cascading failures)
└─ Analogy: In dev, immediately remove closed shops from map
            In prod, keep them listed briefly in case of network issue

eviction-interval-timer-in-ms: 5000
├─ How often to check for dead services
└─ Default: 60 seconds, We use 5s for faster dev testing
```

#### Step 5: Alternative Properties Format (application.properties)

properties

```properties
# Server Configuration
server.port=8761

# Application Name
spring.application.name=eureka-server

# Eureka Instance Configuration
eureka.instance.hostname=localhost

# Eureka Client Configuration
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/

# Eureka Server Configuration
eureka.server.eviction-interval-timer-in-ms=5000
eureka.server.enable-self-preservation=false
eureka.server.renewal-percent-threshold=0.85

# Actuator
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always

# Logging
logging.level.com.netflix.eureka=DEBUG
logging.level.com.netflix.discovery=DEBUG
```

### Understanding Eureka Server Internals

```
┌─────────────────────────────────────────────────────────┐
│  EUREKA SERVER INTERNAL ARCHITECTURE                    │
└─────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│                    EUREKA SERVER                         │
│  ┌────────────────────────────────────────────────────┐  │
│  │  REST Endpoints                                    │  │
│  │  /eureka/apps (Get all apps)                       │  │
│  │  /eureka/apps/{appName} (Get specific app)        │  │
│  │  POST /eureka/apps/{appName} (Register)           │  │
│  │  DELETE /eureka/apps/{appName}/{instanceId}       │  │
│  │  PUT /eureka/apps/{appName}/{instanceId} (Renew)  │  │
│  └────────────────────────────────────────────────────┘  │
│                           │                              │
│  ┌────────────────────────▼────────────────────────────┐  │
│  │  Registry (ConcurrentHashMap)                      │  │
│  │  Key: Application Name                             │  │
│  │  Value: List<InstanceInfo>                         │  │
│  │                                                     │  │
│  │  ORDER-SERVICE → [order-1, order-2]                │  │
│  │  PAYMENT-SERVICE → [payment-1]                     │  │
│  └─────────────────────────────────────────────────────┘  │
│                           │                              │
│  ┌────────────────────────▼────────────────────────────┐  │
│  │  Eviction Timer (Background Thread)                │  │
│  │  - Runs every 60s (default)                        │  │
│  │  - Checks lease expiration                         │  │
│  │  - Removes expired instances                       │  │
│  └─────────────────────────────────────────────────────┘  │
│                           │                              │
│  ┌────────────────────────▼────────────────────────────┐  │
│  │  Self-Preservation Mode                            │  │
│  │  - Monitors heartbeat percentages                  │  │
│  │  - Protects against network partitions             │  │
│  └─────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘
```

----------

## 7. Registering Microservices (Eureka Client) {#registering-microservices}

### Creating Order Service (Eureka Client Example)

#### Step 1: Create Spring Boot Project

```
Project: Maven
Language: Java
Spring Boot: 2.7.14
Project Metadata:
  Group: com.example
  Artifact: order-service
  Name: order-service
  Package name: com.example.orderservice
  Packaging: Jar
  Java: 11

Dependencies:
  - Eureka Discovery Client
  - Spring Web
  - Spring Boot Actuator
  - Lombok (Optional)
```

#### Step 2: Maven Dependencies (pom.xml)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.14</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>order-service</artifactId>
    <version>1.0.0</version>
    <name>order-service</name>
    <description>Order Service - Eureka Client</description>
    
    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.8</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Eureka Client Dependency -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        
        <!-- Web for REST APIs -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Actuator for Health Checks -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Lombok (Optional) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Step 3: Main Application Class

java

```java
package com.example.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * Order Service Application
 * 
 * @EnableEurekaClient - Registers this service with Eureka Server
 * 
 * Note: In newer Spring Cloud versions, @EnableEurekaClient is optional
 * if spring-cloud-starter-netflix-eureka-client is on classpath.
 * But it's good practice to include it for clarity.
 */
@SpringBootApplication
@EnableEurekaClient  // ⭐ Makes this service a Eureka Client
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
        System.out.println("🛒 Order Service Started!");
    }
}
```

#### Step 4: Application Configuration (application.yml)
yaml

```yaml
# Eureka Server Configuration
server:
  port: 8761  # Standard port for Eureka Server

spring:
  application:
    name: eureka-server  # Application name

eureka:
  instance:
    hostname: localhost  # Server hostname
    
  client:
    # Should this server register itself as a client? NO!
    # (It's the registry itself, not a client)
    register-with-eureka: false  # ⭐ Don't register with itself
    fetch-registry: false        # ⭐ Don't fetch registry from itself
    
    service-url:
      # URL where clients can reach this server
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    # How long to wait before removing inactive services (milliseconds)
    eviction-interval-timer-in-ms: 5000  # Check every 5 seconds
    
    # Disable self-preservation mode for development
    # (In production, keep it enabled)
    enable-self-preservation: false  # ⚠️ Development only
    
    # Expected heartbeat threshold percentage
    renewal-percent-threshold: 0.85
    
# Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

# Logging
logging:
  level:
    com.netflix.discovery: DEBUG
```

**Configuration Breakdown:**

```
┌─────────────────────────────────────────────────────────┐
│  EUREKA CLIENT CONFIGURATION EXPLAINED                  │
└─────────────────────────────────────────────────────────┘

spring.application.name: order-service
├─ This is how Eureka identifies your service
├─ All instances of Order Service share this name
└─ Other services use THIS NAME to discover you

register-with-eureka: true
├─ "Yes, please add me to the registry"
└─ Analogy: Sign the guest book when entering hotel

fetch-registry: true
├─ "Yes, give me the list of all other services"
└─ Analogy: Get the hotel directory of all guests

lease-renewal-interval-in-seconds: 30
├─ How often to send "I'm alive" heartbeat
├─ Default: 30 seconds
└─ Analogy: Check in with reception every 30 seconds

lease-expiration-duration-in-seconds: 90
├─ If no heartbeat for 90s, mark as DOWN
├─ Should be 3x renewal interval
└─ Analogy: If no check-in for 90s, assume guest left

prefer-ip-address: true
├─ Register with IP (192.168.1.10) not hostname (server01)
├─ Better for containerized environments
└─ Analogy: Use phone number instead of name
```

#### Step 5: REST Controller

java

```java
package com.example.orderservice.controller;

import com.example.orderservice.model.Order;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.UUID;

/**
 * Order Service REST Controller
 * Demonstrates how to create orders and discover other services
 */
@RestController
@RequestMapping("/orders")
public class OrderController {

    @Value("${spring.application.name}")
    private String applicationName;

    @Value("${server.port}")
    private String port;

    @Autowired
    private DiscoveryClient discoveryClient;  // ⭐ For service discovery

    /**
     * Get service info - shows this service is registered
     */
    @GetMapping("/info")
    public String getServiceInfo() {
        return String.format(
            "🛒 Service: %s | Port: %s | Status: Running",
            applicationName, port
        );
    }

    /**
     * Create a new order
     */
    @PostMapping("/create")
    public Order createOrder(@RequestBody Order order) {
        order.setOrderId(UUID.randomUUID().toString());
        order.setStatus("CREATED");
        
        System.out.println("📦 Order created: " + order.getOrderId());
        
        return order;
    }

    /**
     * Get all orders (mock data)
     */
    @GetMapping
    public List<Order> getAllOrders() {
        return List.of(
            new Order("001", "Customer-1", 100.0, "COMPLETED"),
            new Order("002", "Customer-2", 250.0, "PENDING")
        );
    }

    /**
     * Discover all registered services in Eureka
     */
    @GetMapping("/discover")
    public List<String> discoverServices() {
        return discoveryClient.getServices();
    }

    /**
     * Get instances of a specific service
     */
    @GetMapping("/discover/{serviceName}")
    public List<ServiceInstance> getServiceInstances(
        @PathVariable String serviceName
    ) {
        return discoveryClient.getInstances(serviceName);
    }
}
```

#### Step 6: Model Classes

java

```java
package com.example.orderservice.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Order Domain Model
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderId;
    private String customerId;
    private Double amount;
    private String status;
}
```

### Registration Flow Visualization

```
┌─────────────────────────────────────────────────────────┐
│  SERVICE REGISTRATION FLOW (Step-by-Step)               │
└─────────────────────────────────────────────────────────┘

STEP 1: Service Startup
┌──────────────┐
│ Order Service│  Application starts
│ Starting...  │  Spring Boot initializes
└──────┬───────┘
       │
       │ STEP 2: Read Configuration
       │ - Application name: order-service
       │ - Eureka URL: http://localhost:8761/eureka/
       │ - Port: 8081
       ▼
┌──────────────┐
│ Eureka Client│  Initialized
│ Initialized  │
└──────┬───────┘
       │
       │ STEP 3: Register with Eureka
       │ POST /eureka/apps/ORDER-SERVICE
       │ Body: {instanceId, hostName, ipAddr, port, status...}
       ▼
┌──────────────┐
│ EUREKA SERVER│  Receives registration
│              │  Adds to registry
│ ✅ Registered│
└──────┬───────┘
       │
       │ STEP 4: Start Heartbeat Timer
       │ Every 30 seconds: PUT /eureka/apps/ORDER-SERVICE/instance-001
       ▼
┌──────────────┐
│ Order Service│  
│ ❤️ Heartbeat  │  Continuously sending heartbeats
│ Running...   │
└──────────────┘

LIFECYCLE EVENTS:
T=0s    → Service starts, registration initiated
T=1s    → Registration complete, service UP
T=30s   → First heartbeat sent
T=60s   → Second heartbeat sent
T=90s   → Third heartbeat sent (continues forever...)

If service crashes:
T=100s  → Service DOWN, no heartbeat
T=190s  → 90s elapsed, Eureka marks as DOWN
T=195s  → Eviction job runs, removes from registry
```

----------

## 8. Discovering Microservices (Service-to-Service Communication)

### Creating Payment Service (Second Eureka Client)

#### Step 1: Payment Service Configuration (application.yml)

yaml

```yaml
# Server Configuration
server:
  port: 8082  # Different port from Order Service

# Application Configuration
spring:
  application:
    name: payment-service  # Different service name

# Eureka Client Configuration
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
      
  instance:
    instance-id: ${spring.application.name}:${random.value}
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 30
    lease-expiration-duration-in-seconds: 90

# Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
```

#### Step 2: Payment Service Main Class

java

```java
package com.example.paymentservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
public class PaymentServiceApplication {

    /**
     * RestTemplate bean for making HTTP calls to other services
     * Could also use WebClient (reactive) or Feign Client
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(PaymentServiceApplication.class, args);
        System.out.println("💳 Payment Service Started!");
    }
}
```

#### Step 3: Payment Controller

java

```java
package com.example.paymentservice.controller;

import com.example.paymentservice.model.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/payments")
public class PaymentController {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private RestTemplate restTemplate;

    /**
     * Process payment
     */
    @PostMapping("/process")
    public Payment processPayment(@RequestBody Payment payment) {
        payment.setPaymentId(UUID.randomUUID().toString());
        payment.setStatus("SUCCESS");
        
        System.out.println("💰 Payment processed: " + payment.getPaymentId());
        
        return payment;
    }

    /**
     * Get payment info
     */
    @GetMapping("/info")
    public String getInfo() {
        return "💳 Payment Service | Port: 8082 | Status: Running";
    }
}
```

#### Step 4: Payment Model

java

```java
package com.example.paymentservice.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Payment {
    private String paymentId;
    private String orderId;
    private Double amount;
    private String method;  // CARD, UPI, NETBANKING
    private String status;
}
```

### Service Discovery Methods

#### Method 1: Using DiscoveryClient (Manual Discovery)

java

```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;

/**
 * Service layer demonstrating manual service discovery
 */
@Service
public class OrderService {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private RestTemplate restTemplate;

    /**
     * Call Payment Service using DiscoveryClient
     * 
     * Flow:
     * 1. Get all instances of payment-service from Eureka
     * 2. Choose one instance (simple: take first)
     * 3. Build URL manually
     * 4. Make REST call
     */
    public String callPaymentService(String orderId, Double amount) {
        // Step 1: Get all payment service instances
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("payment-service");
        
        if (instances == null || instances.isEmpty()) {
            return "❌ Payment Service not available";
        }
        
        // Step 2: Get first available instance
        ServiceInstance instance = instances.get(0);
        
        // Step 3: Build URL
        String baseUrl = instance.getUri().toString();
        String endpoint = baseUrl + "/payments/process";
        
        System.out.println("📞 Calling: " + endpoint);
        
        // Step 4: Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Step 5: Make REST call
        Payment response = restTemplate.postForObject(
            endpoint, 
            payment, 
            Payment.class
        );
        
        return "✅ Payment Processed: " + response.getPaymentId();
    }
    
    /**
     * Get service instances info
     */
    public List<ServiceInstance> getPaymentServiceInstances() {
        return discoveryClient.getInstances("payment-service");
    }
}
```

**DiscoveryClient Flow:**

```
┌──────────────────────────────────────────────────────────┐
│  DISCOVERY CLIENT FLOW                                   │
└──────────────────────────────────────────────────────────┘

1. Order Service wants to call Payment Service
   ┌──────────────┐
   │ Order Service│  "I need payment-service"
   └──────┬───────┘
          │
          │ 2. Query DiscoveryClient
          │    discoveryClient.getInstances("payment-service")
          ▼
   ┌──────────────┐
   │ Eureka Client│  Looks in local cache (registry)
   │ (Local Cache)│
   └──────┬───────┘
          │
          │ 3. Returns list of instances
          │    [{uri: http://192.168.1.10:8082, status: UP},
          │     {uri: http://192.168.1.11:8082, status: UP}]
          ▼
   ┌──────────────┐
   │ Order Service│  4. Choose instance (Round Robin, Random, etc.)
   │              │  5. Build URL: http://192.168.1.10:8082/payments/process
   │              │  6. Make HTTP call using RestTemplate
   └──────┬───────┘
          │
          │ 7. Direct HTTP call
          ▼
   ┌──────────────┐
   │ Payment      │
   │ Service      │  8. Process request, return response
   └──────────────┘
```

#### Method 2: Using @LoadBalanced RestTemplate (Recommended)

java

```java
package com.example.orderservice.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

/**
 * Configuration for Load Balanced RestTemplate
 */
@Configuration
public class RestTemplateConfig {

    /**
     * @LoadBalanced enables client-side load balancing
     * 
     * Magic: You can now use SERVICE NAME instead of URL!
     * Before: http://192.168.1.10:8082/payments/process
     * After:  http://PAYMENT-SERVICE/payments/process
     * 
     * Spring Cloud LoadBalancer intercepts the call,
     * resolves PAYMENT-SERVICE from Eureka,
     * chooses an instance (load balancing),
     * and makes the actual HTTP call
     */
    @Bean
    @LoadBalanced  // ⭐ KEY ANNOTATION for service discovery
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**Using LoadBalanced RestTemplate:**

java

```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class OrderServiceV2 {

    @Autowired
    private RestTemplate restTemplate;  // Load-balanced RestTemplate

    /**
     * Call Payment Service using service name (Load Balanced)
     * 
     * Much simpler than DiscoveryClient approach!
     */
    public String processOrderPayment(String orderId, Double amount) {
        
        // Use SERVICE NAME instead of actual URL
        String paymentServiceUrl = "http://payment-service/payments/process";
        
        // Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Make REST call - LoadBalancer handles everything!
        Payment response = restTemplate.postForObject(
            paymentServiceUrl,
            payment,
            Payment.class
        );
        
        return "✅ Payment successful: " + response.getPaymentId();
    }
}
```

**LoadBalanced RestTemplate Flow:**

```
┌──────────────────────────────────────────────────────────┐
│  LOAD BALANCED REST TEMPLATE FLOW                        │
└──────────────────────────────────────────────────────────┘

1. Order Service makes call
   ┌──────────────┐
   │ Order Service│  restTemplate.postForObject(
   │              │    "http://payment-service/payments/process"
   └──────┬───────┘  )
          │
          │ 2. LoadBalancerInterceptor intercepts
          │    (Because of @LoadBalanced annotation)
          ▼
   ┌────────────────┐
   │ LoadBalancer   │  "payment-service? Let me resolve that..."
   │ Interceptor    │
   └──────┬─────────┘
          │
          │ 3. Query Eureka Client for instances
          ▼
   ┌────────────────┐
   │ Eureka Client  │  Returns: [instance-1, instance-2, instance-3]
   │ (Local Cache)  │
   └──────┬─────────┘
          │
          │ 4. Choose instance using load balancing algorithm
          │    (Round Robin by default)
          │    Chosen: instance-2 (http://192.168.1.11:8082)
          ▼
   ┌────────────────┐
   │ LoadBalancer   │  Replace "payment-service" with actual URL
   │ Interceptor    │  http://192.168.1.11:8082/payments/process
   └──────┬─────────┘
          │
          │ 5. Execute actual HTTP call
          ▼
   ┌────────────────┐
   │ Payment Service│  Process request
   │ (Instance-2)   │  Return response
   └────────────────┘
```

#### Method 3: Using Spring Cloud OpenFeign (Most Elegant)

**Step 1: Add Feign Dependency**

xml

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

**Step 2: Enable Feign in Main Class**

java

```java
package com.example.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients  // ⭐ Enable Feign Clients
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

**Step 3: Create Feign Client Interface**

java

```java
package com.example.orderservice.client;

import com.example.orderservice.model.Payment;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * Feign Client for Payment Service
 * 
 * @FeignClient - Creates a REST client automatically
 * name = "payment-service" → Service name in Eureka
 * 
 * You just define the interface, Spring creates implementation!
 */
@FeignClient(name = "payment-service")  // ⭐ Service name from Eureka
public interface PaymentServiceClient {

    /**
     * Method signature matches Payment Service endpoint
     */
    @PostMapping("/payments/process")
    Payment processPayment(@RequestBody Payment payment);
}
```

**Step 4: Use Feign Client in Service**

java

```java
package com.example.orderservice.service;

import com.example.orderservice.client.PaymentServiceClient;
import com.example.orderservice.model.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class OrderServiceV3 {

    @Autowired
    private PaymentServiceClient paymentServiceClient;  // Inject Feign client

    /**
     * Process order payment using Feign
     * 
     * Cleanest approach - looks like calling a local method!
     */
    public String processOrderWithFeign(String orderId, Double amount) {
        
        // Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Call Payment Service - looks like local method call!
        Payment response = paymentServiceClient.processPayment(payment);
        
        return "✅ Payment via Feign: " + response.getPaymentId();
    }
}
```

**Comparison of Discovery Methods:**

```
┌────────────────────────────────────────────────────────────┐
│  SERVICE DISCOVERY METHOD COMPARISON                       │
└────────────────────────────────────────────────────────────┘

1. DiscoveryClient (Manual)
   Code: discoveryClient.getInstances("service-name")
   Pros: ✅ Full control over instance selection
         ✅ Can implement custom load balancing
   Cons: ❌ Verbose code
         ❌ Manual URL building
         ❌ Need to handle errors manually
   
2. @LoadBalanced RestTemplate
   Code: restTemplate.get("http://SERVICE-NAME/endpoint")
   Pros: ✅ Simple service name resolution
         ✅ Automatic load balancing
         ✅ Less code than DiscoveryClient
   Cons: ❌ Still need RestTemplate boilerplate
         ❌ Manual error handling
   
3. Feign Client (Recommended)
   Code: feignClient.methodName(params)
   Pros: ✅ Clean interface-based approach
         ✅ Automatic load balancing
         ✅ Minimal boilerplate
         ✅ Built-in error handling
         ✅ Supports circuit breakers
   Cons: ❌ Additional dependency
         ❌ Less control over HTTP details
```

----------

## 9. Complete Use Case Example {#use-case-example}

### E-Commerce Microservices Architecture

```
┌──────────────────────────────────────────────────────────┐
│  E-COMMERCE MICROSERVICES ECOSYSTEM                      │
└──────────────────────────────────────────────────────────┘

                    ┌────────────────┐
                    │  EUREKA SERVER │
                    │   Port: 8761   │
                    └────────┬───────┘
                             │
                   All services register here
                             │
      ┌──────────────────────┼──────────────────────┐
      │                      │                      │
      ▼                      ▼                      ▼
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   ORDER     │      │  PAYMENT    │      │  PRODUCT    │
│  SERVICE    │      │  SERVICE    │      │  SERVICE    │
│ Port: 8081  │      │ Port: 8082  │      │ Port: 8083  │
└─────────────┘      └─────────────┘      └─────────────┘
      │                      │                      │
      │                      │                      │
      └──────────────────────┴──────────────────────┘
              Inter-service communication
              via Eureka discovery
```

### Business Flow

```
USER PLACES ORDER:
1. POST /orders/place
   ↓
2. Order Service:
   - Validates order
   - Calls Product Service (check inventory)
   - Calls Payment Service (process payment)
   - Updates order status
   ↓
3. Returns order confirmation
```

### Implementation: Product Service

**application.yml:**

yaml

```yaml
server:
  port: 8083

spring:
  application:
    name: product-service

eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

**ProductController.java:**

java

```java
package com.example.productservice.controller;

import com.example.productservice.model.Product;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/products")
public class ProductController {

    // Mock inventory
    private Map<String, Product> inventory = new HashMap<>() {{
        put("P001", new Product("P001", "Laptop", 50000.0, 10));
        put("P002", new Product("P002", "Mouse", 500.0, 100));
        put("P003", new Product("P003", "Keyboard", 1500.0, 50));
    }};

    @GetMapping("/{productId}")
    public Product getProduct(@PathVariable String productId) {
        return inventory.getOrDefault(
            productId, 
            new Product(null, "Not Found", 0.0, 0)
        );
    }

    @GetMapping("/{productId}/check-stock")
    public Map<String, Object> checkStock(
        @PathVariable String productId,
        @RequestParam Integer quantity
    ) {
        Product product = inventory.get(productId);
        
        Map<String, Object> response = new HashMap<>();
        
        if (product == null) {
            response.put("available", false);
            response.put("message", "Product not found");
        } else if (product.getStock() >= quantity) {
            response.put("available", true);
            response.put("message", "Stock available");
            response.put("product", product);
        } else {
            response.put("available", false);
            response.put("message", "Insufficient stock");
            response.put("availableStock", product.getStock());
        }
        
        return response;
    }
}
```

### Complete Order Placement Flow

java

```java
package com.example.orderservice.service;

import com.example.orderservice.client.PaymentServiceClient;
import com.example.orderservice.client.ProductServiceClient;
import com.example.orderservice.model.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.UUID;

/**
 * Complete order processing with service discovery
 */
@Service
public class CompleteOrderService {

    @Autowired
    private ProductServiceClient productServiceClient;

    @Autowired
    private PaymentServiceClient paymentServiceClient;

    /**
     * Place order - orchestrates multiple services
     */
    public OrderResponse placeOrder(OrderRequest request) {
        
        String orderId = UUID.randomUUID().toString();
        
        System.out.println("📝 Step 1: Creating order " + orderId);
        
        // STEP 1: Check product availability
        System.out.println("📦 Step 2: Checking product stock...");
        Map<String, Object> stockCheck = productServiceClient.checkStock(
            request.getProductId(),
            request.getQuantity()
        );
        
        if (!(Boolean) stockCheck.get("available")) {
            return new OrderResponse(
                orderId,
                "FAILED",
                "Product not available: " + stockCheck.get("message")
            );
        }
        
        // STEP 2: Calculate total amount
        Product product = (Product) stockCheck.get("product");
        Double totalAmount = product.getPrice() * request.getQuantity();
        
        System.out.println("💰 Step 3: Total amount: ₹" + totalAmount);
        
        // STEP 3: Process payment
        System.out.println("💳 Step 4: Processing payment...");
        Payment paymentRequest = new Payment(
            null,
            orderId,
            totalAmount,
            request.getPaymentMethod(),
            null
        );
        
        Payment paymentResponse = paymentServiceClient.processPayment(
            paymentRequest
        );
        
        if (!"SUCCESS".equals(paymentResponse.getStatus())) {
            return new OrderResponse(
                orderId,
                "FAILED",
                "Payment failed"
            );
        }
        
        // STEP 4: Order successful
        System.out.println("✅ Step 5: Order completed successfully!");
        
        return new OrderResponse(
            orderId,
            "SUCCESS",
            "Order placed successfully. Payment ID: " + 
            paymentResponse.getPaymentId()
        );
    }
}
```

**Feign Client Interfaces:**

java

```java
// ProductServiceClient.java
@FeignClient(name = "product-service")
public interface ProductServiceClient {
    
    @GetMapping("/products/{productId}/check-stock")
    Map<String, Object> checkStock(
        @PathVariable String productId,
        @RequestParam Integer quantity
    );
}

// PaymentServiceClient.java (already shown earlier)
@FeignClient(name = "payment-service")
public interface PaymentServiceClient {
    
    @PostMapping("/payments/process")
    Payment processPayment(@RequestBody Payment payment);
}
```

----------

## 10. Execution & Testing 

### Starting the Application

**Step-by-Step Execution:**

```
┌──────────────────────────────────────────────────────────┐
│  EXECUTION SEQUENCE (IMPORTANT!)                         │
└──────────────────────────────────────────────────────────┘

STEP 1: Start Eureka Server FIRST
        ┌──────────────────────────────────┐
        │  cd eureka-server                │
        │  mvn spring-boot:run             │
        │                                  │
        │  OR                              │
        │                                  │
        │  mvn clean package               │
        │  java -jar target/eureka-server-1.0.0.jar
        └──────────────────────────────────┘
        
        Wait for: "Started EurekaServerApplication"
        Access: http://localhost:8761
        
        ⚠️ IMPORTANT: Wait 30-60 seconds for Eureka to fully start

STEP 2: Start Microservices (any order)
        
        Terminal 2 - Order Service:
        ┌──────────────────────────────────┐
        │  cd order-service                │
        │  mvn spring-boot:run             │
        └──────────────────────────────────┘
        
        Terminal 3 - Payment Service:
        ┌──────────────────────────────────┐
        │  cd payment-service              │
        │  mvn spring-boot:run             │
        └──────────────────────────────────┘
        
        Terminal 4 - Product Service:
        ┌──────────────────────────────────┐
        │  cd product-service              │
        │  mvn spring-boot:run             │
        └──────────────────────────────────┘

STEP 3: Verify Registration
        Wait 30 seconds, then check:
        http://localhost:8761
        
        You should see all three services registered!
```

### Testing the Application

#### 1. Check Eureka Dashboard

```
URL: http://localhost:8761

You should see:
┌────────────────────────────────────────────────────────┐
│  Instances currently registered with Eureka           │
├────────────────────────────────────────────────────────┤
│  Application         AMIs    Availability Zones Status│
│  ORDER-SERVICE       n/a(1)  (1)                  UP  │
│  PAYMENT-SERVICE     n/a(1)  (1)                  UP  │
│  PRODUCT-SERVICE     n/a(1)  (1)                  UP  │
└────────────────────────────────────────────────────────┘

✅ All services showing "UP" means they're registered!
```

#### 2. Test Individual Services

**Order Service:**

bash

```bash
# Get service info
curl http://localhost:8081/orders/info

Response: 🛒 Service: order-service | Port: 8081 | Status: Running

# Get all orders
curl http://localhost:8081/orders

Response: 
[
  {
    "orderId": "001",
    "customerId": "Customer-1",
    "amount": 100.0,
    "status": "COMPLETED"
  },
  {
    "orderId": "002",
    "customerId": "Customer-2",
    "amount": 250.0,
    "status": "PENDING"
  }
]

# Discover all services
curl http://localhost:8081/orders/discover

Response: ["order-service", "payment-service", "product-service"]

# Get Payment Service instances
curl http://localhost:8081/orders/discover/payment-service

Response:
[
  {
    "instanceId": "payment-service:abc123",
    "host": "192.168.1.10",
    "port": 8082,
    "uri": "http://192.168.1.10:8082",
    "metadata": {},
    "secure": false
  }
]
```

**Payment Service:**

bash

```bash
# Get service info
curl http://localhost:8082/payments/info

Response: 💳 Payment Service | Port: 8082 | Status: Running

# Process payment
curl -X POST http://localhost:8082/payments/process \
  -H "Content-Type: application/json" \
  -d '{
    "orderId": "ORD001",
    "amount": 1500.0,
    "method": "CARD"
  }'

Response:
{
  "paymentId": "PAY-uuid-generated",
  "orderId": "ORD001",
  "amount": 1500.0,
  "method": "CARD",
  "status": "SUCCESS"
}
```

**Product Service:**

bash

```bash
# Get product details
curl http://localhost:8083/products/P001

Response:
{
  "productId": "P001",
  "name": "Laptop",
  "price": 50000.0,
  "stock": 10
}

# Check stock availability
curl "http://localhost:8083/products/P001/check-stock?quantity=2"

Response:
{
  "available": true,
  "message": "Stock available",
  "product": {
    "productId": "P001",
    "name": "Laptop",
    "price": 50000.0,
    "stock": 10
  }
}
```

#### 3. Test Service-to-Service Communication

**Test Order Service calling Payment Service:**

bash

```bash
# Using Order Service endpoint that calls Payment Service internally
curl -X POST http://localhost:8081/orders/process-payment \
  -H "Content-Type: application/json" \
  -d '{
    "orderId": "ORD12345",
    "amount": 2500.0
  }'

Response: ✅ Payment successful: PAY-xyz789

# Check logs in Order Service terminal:
📞 Calling: http://payment-service/payments/process
💰 Payment processed: PAY-xyz789

# Check logs in Payment Service terminal:
💰 Payment processed: PAY-xyz789
```

#### 4. Test Complete Order Flow

bash

```bash
# Place complete order
curl -X POST http://localhost:8081/orders/place \
  -H "Content-Type: application/json" \
  -d '{
    "customerId": "CUST001",
    "productId": "P001",
    "quantity": 2,
    "paymentMethod": "CARD"
  }'

Response:
{
  "orderId": "550e8400-e29b-41d4-a716-446655440000",
  "status": "SUCCESS",
  "message": "Order placed successfully. Payment ID: PAY-abc123"
}
```

**What happens behind the scenes:**

```
┌──────────────────────────────────────────────────────────┐
│  COMPLETE ORDER FLOW TRACE                               │
└──────────────────────────────────────────────────────────┘

T=0ms    │ User → POST /orders/place
         ├─ Order Service receives request
         │
T=10ms   │ Order Service → Product Service
         ├─ "Check stock for P001, quantity: 2"
         ├─ Uses Feign Client with service discovery
         │
T=50ms   │ Product Service → Response
         ├─ "Stock available: Yes"
         │
T=60ms   │ Order Service → Calculate total
         ├─ Price: ₹50,000 × 2 = ₹1,00,000
         │
T=70ms   │ Order Service → Payment Service
         ├─ "Process payment for ₹1,00,000"
         ├─ Uses Feign Client with service discovery
         │
T=120ms  │ Payment Service → Response
         ├─ "Payment successful: PAY-abc123"
         │
T=130ms  │ Order Service → User
         └─ "Order placed successfully!"

Total Time: 130ms (fast due to local discovery cache!)
```

#### 5. Test Load Balancing (Multiple Instances)

**Start multiple instances of Payment Service:**

bash

```bash
# Terminal 3 - Instance 1 (Port 8082)
cd payment-service
mvn spring-boot:run

# Terminal 4 - Instance 2 (Port 8084)
cd payment-service
mvn spring-boot:run -Dspring-boot.run.arguments=--server.port=8084

# Terminal 5 - Instance 3 (Port 8085)
cd payment-service
mvn spring-boot:run -Dspring-boot.run.arguments=--server.port=8085
```

**Check Eureka Dashboard:**

```
http://localhost:8761

Now you'll see:
PAYMENT-SERVICE     n/a(3)  (3)                  UP
                    ↑
                3 instances!
```

**Test Load Balancing:**

bash

```bash
# Make 5 calls to Order Service
for i in {1..5}; do
  curl -X POST http://localhost:8081/orders/process-payment \
    -H "Content-Type: application/json" \
    -d '{"orderId":"ORD'$i'","amount":1000}' 
  echo ""
done
```

**Check Payment Service logs:**

```
Instance 1 (8082): Payment processed: PAY-1
Instance 2 (8084): Payment processed: PAY-2
Instance 3 (8085): Payment processed: PAY-3
Instance 1 (8082): Payment processed: PAY-4
Instance 2 (8084): Payment processed: PAY-5

✅ Round-robin load balancing working!
```

#### 6. Test Fault Tolerance

**Scenario: Kill one Payment Service instance**

bash

```bash
# Kill Instance 2 (Port 8084)
# Stop the process running on Terminal 4

# Wait 90 seconds (lease expiration time)

# Check Eureka Dashboard
http://localhost:8761

PAYMENT-SERVICE     n/a(2)  (2)                  UP
                    ↑
            Now only 2 instances!

# Make payment calls
curl -X POST http://localhost:8081/orders/process-payment \
  -H "Content-Type: application/json" \
  -d '{"orderId":"ORD999","amount":5000}'

Response: ✅ Payment successful: PAY-xyz

✅ Still works! Traffic automatically routed to healthy instances
```

**Instance Health Timeline:**

```
T=0s     Instance-2 crashes
T=30s    No heartbeat received (first miss)
T=60s    No heartbeat received (second miss)
T=90s    Lease expired! Eureka marks as DOWN
T=95s    Eviction job runs, removes from registry
T=100s   New requests only go to Instance-1 and Instance-3
```

#### 7. Testing with Postman

**Create Postman Collection:**

json

```json
{
  "info": {
    "name": "Eureka Microservices Testing",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "1. Eureka Dashboard",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "http://localhost:8761",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8761"
        }
      }
    },
    {
      "name": "2. Get All Services",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "http://localhost:8081/orders/discover",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8081",
          "path": ["orders", "discover"]
        }
      }
    },
    {
      "name": "3. Place Complete Order",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"customerId\": \"CUST001\",\n  \"productId\": \"P001\",\n  \"quantity\": 2,\n  \"paymentMethod\": \"CARD\"\n}"
        },
        "url": {
          "raw": "http://localhost:8081/orders/place",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8081",
          "path": ["orders", "place"]
        }
      }
    }
  ]
}
```

#### 8. Monitoring and Debugging

**Check Eureka Server Metrics:**

bash

```bash
# Server health
curl http://localhost:8761/actuator/health

Response:
{
  "status": "UP",
  "components": {
    "diskSpace": {"status": "UP"},
    "ping": {"status": "UP"}
  }
}

# Server metrics
curl http://localhost:8761/actuator/metrics

# Specific metric
curl http://localhost:8761/actuator/metrics/eureka.server.registry-size

Response:
{
  "name": "eureka.server.registry-size",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 3.0
    }
  ]
}
```

**Check Service Health:**

bash

```bash
curl http://localhost:8081/actuator/health

Response:
{
  "status": "UP",
  "components": {
    "discoveryComposite": {
      "status": "UP",
      "components": {
        "eureka": {
          "status": "UP",
          "details": {
            "applications": {
              "ORDER-SERVICE": 1,
              "PAYMENT-SERVICE": 3,
              "PRODUCT-SERVICE": 1
            }
          }
        }
      }
    }
  }
}
```

### Common Issues and Troubleshooting

```
┌──────────────────────────────────────────────────────────┐
│  COMMON ISSUES & SOLUTIONS                               │
└──────────────────────────────────────────────────────────┘

❌ Issue 1: Services not showing in Eureka Dashboard

Solutions:
✅ Check if Eureka Server is running (http://localhost:8761)
✅ Verify eureka.client.register-with-eureka=true in service config
✅ Check eureka.client.service-url.defaultZone URL is correct
✅ Wait 30 seconds for registration to complete
✅ Check service logs for connection errors


❌ Issue 2: Service registered but shows as DOWN

Solutions:
✅ Check if service is actually running (curl http://localhost:808X)
✅ Verify actuator health endpoint is accessible
✅ Check firewall/network connectivity
✅ Look for exceptions in service logs
✅ Verify eureka.instance.prefer-ip-address setting


❌ Issue 3: Service discovery not working

Solutions:
✅ Check if eureka.client.fetch-registry=true
✅ Verify @LoadBalanced annotation on RestTemplate
✅ Check service name matches exactly (case-sensitive)
✅ Wait for registry cache refresh (30 seconds)
✅ Check DiscoveryClient is autowired correctly


❌ Issue 4: Load balancing not distributing evenly

Solutions:
✅ Verify multiple instances are registered (check dashboard)
✅ Wait for registry cache to update
✅ Check if all instances are UP
✅ Review load balancer configuration
✅ Use different load balancing strategy if needed


❌ Issue 5: Service removed from registry unexpectedly

Solutions:
✅ Check if service is sending heartbeats (logs)
✅ Verify network connectivity
✅ Increase lease-expiration-duration-in-seconds
✅ Check if self-preservation mode triggered
✅ Look for GC pauses in JVM (might cause heartbeat delays)


❌ Issue 6: Port already in use

Solutions:
✅ Kill existing process: lsof -ti:8761 | xargs kill -9
✅ Use different port: --server.port=8762
✅ Check no other apps using same port


❌ Issue 7: Feign client connection refused

Solutions:
✅ Verify target service is running
✅ Check service name in @FeignClient matches Eureka registration
✅ Verify @EnableFeignClients annotation present
✅ Check Feign client is in component scan path
✅ Review Feign client method signatures match endpoints
```

### Performance Testing

**Load Testing Script:**

bash

```bash
#!/bin/bash
# load-test.sh

echo "🚀 Starting load test..."

# Number of requests
REQUESTS=100

# Concurrent requests
CONCURRENT=10

# Order Service URL
URL="http://localhost:8081/orders/place"

# Run Apache Bench
ab -n $REQUESTS -c $CONCURRENT -p order-payload.json \
   -T "application/json" $URL

echo "✅ Load test completed!"
```

**order-payload.json:**

json

```json
{
  "customerId": "CUST001",
  "productId": "P001",
  "quantity": 1,
  "paymentMethod": "CARD"
}
```

**Expected Results:**

```
Concurrency Level:      10
Time taken for tests:   5.234 seconds
Complete requests:      100
Failed requests:        0
Requests per second:    19.11 [#/sec]
Time per request:       523.420 [ms] (mean)
```

----------

## 11. Conclusion

### Key Takeaways

```
┌──────────────────────────────────────────────────────────┐
│  WHAT WE LEARNED                                         │
└──────────────────────────────────────────────────────────┘

✅ Netflix Eureka solves microservices discovery problems
   - No hardcoded URLs
   - Dynamic service registration
   - Automatic load balancing
   - Fault tolerance

✅ Eureka Server = Central service registry
   - Maintains list of all services
   - Monitors service health via heartbeats
   - Provides REST API for registration/discovery

✅ Service Registration is automatic
   - Services register on startup
   - Send heartbeats every 30 seconds
   - De-register on shutdown

✅ Service Discovery has 3 approaches
   - DiscoveryClient (manual, full control)
   - @LoadBalanced RestTemplate (balanced, simple)
   - Feign Client (cleanest, recommended)

✅ Key Configuration Parameters
   - register-with-eureka: true (for clients)
   - fetch-registry: true (for clients)
   - lease-renewal-interval-in-seconds: 30
   - lease-expiration-duration-in-seconds: 90
   - enable-self-preservation: true (production)

✅ Production Considerations
   - Enable self-preservation mode
   - Set up Eureka server cluster (3+ nodes)
   - Configure proper timeouts
   - Implement circuit breakers
   - Monitor registry size and health
   - Use security (Spring Security + HTTPS)
```

### Architecture Benefits

```
┌──────────────────────────────────────────────────────────┐
│  BENEFITS OF EUREKA-BASED ARCHITECTURE                   │
└──────────────────────────────────────────────────────────┘

1. SCALABILITY
   └─ Add/remove service instances dynamically
   └─ No configuration changes needed
   └─ Automatic load distribution

2. RESILIENCE
   └─ Automatic failover to healthy instances
   └─ Self-preservation during network issues
   └─ No single point of failure (with Eureka cluster)

3. MAINTAINABILITY
   └─ No hardcoded dependencies
   └─ Easy to update/replace services
   └─ Clear service boundaries

4. DEVELOPMENT SPEED
   └─ Services can be developed independently
   └─ Easy local testing
   └─ Simple integration

5. OPERATIONAL EXCELLENCE
   └─ Real-time visibility of all services
   └─ Health monitoring built-in
   └─ Easy debugging and troubleshooting
```

### Advanced Topics (Future Learning)

```
┌──────────────────────────────────────────────────────────┐
│  NEXT STEPS FOR DEEPER LEARNING                          │
└──────────────────────────────────────────────────────────┘

1. EUREKA CLUSTERING
   - Multiple Eureka servers for HA
   - Peer-to-peer replication
   - Zone awareness

2. SECURITY
   - Securing Eureka Server (Spring Security)
   - HTTPS/TLS communication
   - Service authentication

3. ADVANCED LOAD BALANCING
   - Custom load balancing rules
   - Zone-aware routing
   - Weighted load balancing

4. CIRCUIT BREAKERS
   - Resilience4j integration
   - Fallback mechanisms
   - Bulkhead patterns

5. SERVICE MESH
   - Istio/Linkerd integration
   - Replace Eureka with service mesh
   - Advanced traffic management

6. MONITORING & OBSERVABILITY
   - Distributed tracing (Zipkin/Jaeger)
   - Metrics (Prometheus/Grafana)
   - Centralized logging (ELK Stack)

7. CONTAINERIZATION
   - Docker containers
   - Kubernetes service discovery
   - Helm charts for deployment

8. API GATEWAY
   - Spring Cloud Gateway
   - Zuul (older)
   - Single entry point for clients
```

### Production Checklist

```
┌──────────────────────────────────────────────────────────┐
│  PRODUCTION READINESS CHECKLIST                          │
└──────────────────────────────────────────────────────────┘

EUREKA SERVER:
☐ Deploy 3+ Eureka servers for HA
☐ Enable peer replication
☐ Configure proper retention thresholds
☐ Enable self-preservation in production
☐ Secure with authentication
☐ Set up monitoring and alerts
☐ Configure proper JVM heap size
☐ Use external configuration (Config Server)

MICROSERVICES:
☐ Configure health check endpoints
☐ Set appropriate timeout values
☐ Implement circuit breakers
☐ Add retry logic with exponential backoff
☐ Configure proper thread pools
☐ Enable actuator with security
☐ Implement graceful shutdown
☐ Add correlation IDs for tracing

INFRASTRUCTURE:
☐ Set up load balancers
☐ Configure DNS properly
☐ Implement backup and recovery
☐ Set up CI/CD pipelines
☐ Configure log aggregation
☐ Set up APM tools
☐ Implement chaos engineering tests
☐ Document runbooks for incidents

SECURITY:
☐ Use HTTPS everywhere
☐ Implement OAuth2/JWT
☐ Enable CORS properly
☐ Scan for vulnerabilities
☐ Implement rate limiting
☐ Add input validation
☐ Secure sensitive configuration
☐ Regular security audits
```

### Final Architecture Diagram

```
┌──────────────────────────────────────────────────────────────┐
│  COMPLETE MICROSERVICES ARCHITECTURE WITH EUREKA             │
└──────────────────────────────────────────────────────────────┘

                         USERS
                           │
                           │ HTTPS
                           ▼
                    ┌──────────────┐
                    │  API GATEWAY │
                    │  (Port 8080) │
                    └──────┬───────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
              ▼            ▼            ▼
       ┌───────────┐ ┌───────────┐ ┌───────────┐
       │  EUREKA   │ │  EUREKA   │ │  EUREKA   │
       │  SERVER-1 │ │  SERVER-2 │ │  SERVER-3 │
       │ (8761)    │ │ (8762)    │ │ (8763)    │
       └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
             │             │             │
             └─────────────┼─────────────┘
                           │ Peer Replication
             ┌─────────────┴─────────────┐
             │  SERVICE REGISTRY          │
             │  (Replicated across all)   │
             └─────────────┬─────────────┘
                           │
      ┌────────────────────┼────────────────────┐
      │                    │                    │
      ▼                    ▼                    ▼
┌──────────┐         ┌──────────┐         ┌──────────┐
│  ORDER   │────────▶│ PAYMENT  │         │ PRODUCT  │
│ SERVICE  │  Feign  │ SERVICE  │◀────────│ SERVICE  │
│          │         │          │  Feign  │          │
└────┬─────┘         └────┬─────┘         └────┬─────┘
     │                    │                    │
   ┌─┴─┐                ┌─┴─┐                ┌─┴─┐
   │DB │                │DB │                │DB │
   └───┘                └───┘                └───┘

COMMUNICATION FLOW:
1. User → API Gateway
2. Gateway → Service Discovery (Eureka)
3. Gateway → Routes to appropriate service
4. Services discover each other via Eureka
5. Direct service-to-service calls (no proxy)
6. Automatic load balancing across instances
7. Health checks ensure only healthy instances receive traffic
```

### Summary in Simple Terms

**Think of Eureka like a Smart Phone Directory:**

```
WITHOUT EUREKA (Old Way):
📱 You memorize everyone's phone number
❌ When someone changes number, you can't call them
❌ You don't know if they're available
❌ You call the same person even if they're busy

WITH EUREKA (Smart Way):
📱 Everyone automatically adds themselves to directory
✅ You just look up name, get current number
✅ Directory shows who's available
✅ Automatically calls least busy person
✅ If someone's unavailable, tries someone else
```

**Real-World Analogy:**

```
EUREKA SERVER = Hotel Reception
├─ Maintains guest registry
├─ Knows which room each guest is in
├─ Knows who's in/out
└─ Helps guests find each other

SERVICES = Hotel Guests
├─ Check in when they arrive (register)
├─ Periodically confirm they're still there (heartbeat)
├─ Ask reception to find other guests (discovery)
└─ Check out when they leave (de-register)
```

----------

## Appendix: Complete Code Repository Structure

```
microservices-eureka-example/
│
├── eureka-server/
│   ├── src/main/java/com/example/eurekaserver/
│   │   └── EurekaServerApplication.java
│   ├── src/main/resources/
│   │   └── application.yml
│   └── pom.xml
│
├── order-service/
│   ├── src/main/java/com/example/orderservice/
│   │   ├── OrderServiceApplication.java
│   │   ├── controller/
│   │   │   └── OrderController.java
│   │   ├── service/
│   │   │   ├── OrderService.java
│   │   │   └── CompleteOrderService.java
│   │   ├── client/
│   │   │   ├── PaymentServiceClient.java
│   │   │   └── ProductServiceClient.java
│   │   ├── model/
│   │   │   ├── Order.java
│   │   │   ├── OrderRequest.java
│   │   │   ├── OrderResponse.java
│   │   │   └── Payment.java
│   │   └── config/
│   │       └── RestTemplateConfig.java
│   ├── src/main/resources/
│   │   └── application.yml
│   └── pom.xml
│
├── payment-service/
│   ├── src/main/java/com/example/paymentservice/
│   │   ├── PaymentServiceApplication.java
│   │   ├── controller/
│   │   │   └── PaymentController.java
│   │   └── model/
│   │       └── Payment.java
│   ├── src/main/resources/
│   │   └── application.yml
│   └── pom.xml
│
├── product-service/
│   ├── src/main/java/com/example/productservice/
│   │   ├── ProductServiceApplication.java
│   │   ├── controller/
│   │   │   └── ProductController.java
│   │   └── model/
│   │       └── Product.java
│   ├── src/main/resources/
│   │   └── application.yml
│   └── pom.xml
│
├── README.md
└── docker-compose.yml (Optional - for containerization)
```

----------

## 🎓 Congratulations!

You now understand: 
✅ Why Netflix Eureka is essential for microservices
✅ How service registry and discovery work 
✅ How to create and configure Eureka Server
✅ How to register services as Eureka clients
✅ How to discover and communicate between services
✅ How to test and troubleshoot the complete system


