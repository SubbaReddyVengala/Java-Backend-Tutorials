# Netflix Eureka: Complete Tutorial with Service Registry & Discovery

## Table of Contents

1.  Why Netflix Eureka is Required?
2.  What is Netflix Eureka & Eureka Server?
3.  Service Registry in Microservices
4.  Service Discovery in Microservices
5.  Software/Technology Stack
6.  Creating Eureka Server
7.  Registering Microservices
8.  Discovering Microservices
9.  Complete Use Case Example
10.  Execution & Testing
11.  Conclusion

----------

## 1. Why Netflix Eureka is Required?

### The Problem in Microservices Architecture

**Analogy: The Phone Directory Problem** Imagine you're in a large office building with 100+ employees. Without a phone directory:

-   You need to memorize everyone's extension number
-   When someone moves to a new desk (new extension), you lose contact
-   New employees join, but you don't know their numbers
-   Multiple people do the same job, but you only know one person's number

**Real-World Microservices Challenge:**

```
Traditional Approach (Hardcoded URLs):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order       â”‚ http://payment-service:8081/process
â”‚ Service     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
â”‚             â”‚ (What if Payment Service moves to 8082?)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (What if Payment Service has 5 instances?)
```

**Problems with Hardcoded Configuration:**

1.  **No Dynamic Scaling**: Can't add/remove service instances dynamically
2.  **No Fault Tolerance**: If one instance fails, requests still go to dead instance
3.  **Manual Configuration**: Need to update all services when URLs change
4.  **No Load Balancing**: Can't distribute load across multiple instances
5.  **Deployment Nightmares**: Configuration files become unmanageable

### The Solution: Service Registry & Discovery

```
With Eureka:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      1. Where is     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order       â”‚      Payment Service? â”‚   EUREKA     â”‚
â”‚ Service     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   SERVER     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚ (Directory)   â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                     2. Here are all        â”‚
                     healthy instances      â”‚ 3. Auto-registers
                            â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    location & health
                                                  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Payment     â”‚  â”‚ Payment     â”‚  â”‚ Payment     â”‚
â”‚ Instance-1  â”‚  â”‚ Instance-2  â”‚  â”‚ Instance-3  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

## 2. What is Netflix Eureka & Eureka Server?
### Netflix Eureka

**Definition**: Netflix Eureka is a REST-based service registry and discovery tool developed by Netflix for resilient mid-tier load balancing and failover in cloud environments.

**Analogy: GPS Navigation System**

-   **Eureka Server** = GPS Satellite Network (knows where everything is)
-   **Service Registration** = Broadcasting your location to satellites
-   **Service Discovery** = Finding the nearest restaurant using GPS

### Components of Eureka

#### A) Eureka Server

-   **Role**: Central registry/database of all microservices
-   **Responsibilities**:
    -   Maintains registry of all service instances
    -   Receives heartbeats from registered services (health checks)
    -   Provides service instance information to clients
    -   Evicts dead instances from registry

#### B) Eureka Client

-   **Role**: Microservice that registers with Eureka Server
-   **Responsibilities**:
    -   Registers itself with Eureka Server on startup
    -   Sends heartbeat every 30 seconds (default)
    -   Fetches registry from server
    -   De-registers on shutdown

### Eureka Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EUREKA SERVER (Port 8761)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚            SERVICE REGISTRY (In-Memory)              â”‚  â”‚
â”‚  â”‚                                                      â”‚  â”‚
â”‚  â”‚  Service Name    â”‚  Instance ID    â”‚  Status  â”‚ URL â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚
â”‚  â”‚  ORDER-SERVICE   â”‚  order-001      â”‚  UP      â”‚ ... â”‚  â”‚
â”‚  â”‚  ORDER-SERVICE   â”‚  order-002      â”‚  UP      â”‚ ... â”‚  â”‚
â”‚  â”‚  PAYMENT-SERVICE â”‚  payment-001    â”‚  UP      â”‚ ... â”‚  â”‚
â”‚  â”‚  PAYMENT-SERVICE â”‚  payment-002    â”‚  DOWN    â”‚ ... â”‚  â”‚
â”‚  â”‚  PRODUCT-SERVICE â”‚  product-001    â”‚  UP      â”‚ ... â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â–²                    â–²                    â–²
           â”‚ Heartbeat          â”‚ Register           â”‚ Fetch Registry
           â”‚ (30s)              â”‚ (On Startup)       â”‚ (30s)
           â”‚                    â”‚                    â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   ORDER      â”‚    â”‚  PAYMENT     â”‚    â”‚  PRODUCT     â”‚
    â”‚   SERVICE    â”‚    â”‚  SERVICE     â”‚    â”‚  SERVICE     â”‚
    â”‚ (Eureka      â”‚    â”‚ (Eureka      â”‚    â”‚ (Eureka      â”‚
    â”‚  Client)     â”‚    â”‚  Client)     â”‚    â”‚  Client)     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

## 3. Service Registry in Microservices 

### What is Service Registry?

**Definition**: A service registry is a database containing the network locations of service instances. It acts as a central directory where microservices register themselves and discover other services.

**Analogy: Hotel Reception Desk**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        HOTEL RECEPTION DESK             â”‚
â”‚      (SERVICE REGISTRY)                 â”‚
â”‚                                         â”‚
â”‚  Guest Name     â”‚  Room Number â”‚ Statusâ”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  John (Order)   â”‚  Room 101    â”‚ IN   â”‚
â”‚  Mary (Payment) â”‚  Room 205    â”‚ IN   â”‚
â”‚  Bob (Product)  â”‚  Room 310    â”‚ OUT  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

When John needs to meet Mary, he asks reception
for her room number instead of searching all 300 rooms!
```

### Types of Service Registry Patterns

#### A) Self-Registration Pattern (Used by Eureka)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVICE A   â”‚
â”‚              â”‚  1. I'm starting up!
â”‚  (Eureka     â”‚     My URL is http://192.168.1.10:8080
â”‚   Client)    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
â”‚              â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚  2. Registered! Send heartbeat    â”‚  EUREKA    â”‚
â”‚              â”‚     every 30 seconds              â”‚  SERVER    â”‚
â”‚              â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advantages:**

-   Service controls its registration logic
-   Simple and straightforward
-   Service knows when it's ready to receive traffic

**Disadvantages:**

-   Couples service to registry implementation
-   Every service needs registry client code

#### B) Third-Party Registration Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVICE A   â”‚                           â”‚  EUREKA    â”‚
â”‚              â”‚                           â”‚  SERVER    â”‚
â”‚ (No Eureka   â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  knowledge)  â”‚                                  â–²
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚
       â”‚                                          â”‚ Registers
       â”‚ Health Check                             â”‚ on behalf
       â–¼                                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚  REGISTRAR   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  (Sidecar)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Service Registry Data Model

json

```json
{
  "application": "ORDER-SERVICE",
  "instance": {
    "instanceId": "order-service-001",
    "hostName": "192.168.1.10",
    "app": "ORDER-SERVICE",
    "ipAddr": "192.168.1.10",
    "status": "UP",
    "port": {
      "enabled": true,
      "port": 8080
    },
    "healthCheckUrl": "http://192.168.1.10:8080/actuator/health",
    "statusPageUrl": "http://192.168.1.10:8080/actuator/info",
    "homePageUrl": "http://192.168.1.10:8080/",
    "metadata": {
      "version": "1.0.0",
      "zone": "us-east-1a"
    },
    "lastUpdatedTimestamp": 1635789012345,
    "lastDirtyTimestamp": 1635789012345,
    "leaseInfo": {
      "renewalIntervalInSecs": 30,
      "durationInSecs": 90
    }
  }
}
```

----------

## 4. Service Discovery in Microservices 

### What is Service Discovery?

**Definition**: Service discovery is the mechanism by which microservices locate and communicate with each other dynamically without hardcoded addresses.

**Analogy: Restaurant Delivery Service**

```
YOU (Order Service) â†’ Want pizza from Restaurant (Payment Service)

Without Discovery:
âŒ Call hardcoded phone number â†’ Number changed â†’ Can't order!

With Discovery (Eureka):
âœ… Call directory service (411) â†’ "Here's current number" â†’ Order placed!
```

### Discovery Mechanisms

#### A) Client-Side Discovery (Used by Eureka)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT-SIDE DISCOVERY FLOW                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Fetch Registry
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  1. Give me all     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order        â”‚     PAYMENT-SERVICE â”‚  EUREKA    â”‚
â”‚ Service      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  SERVER    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     instances       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ 2. Here's the list:
                          â”‚    - http://payment-1:8081 (UP)
                          â”‚    - http://payment-2:8081 (UP)
                          â–¼    - http://payment-3:8081 (DOWN)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order        â”‚
â”‚ Service      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Choose Instance (Load Balance)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order        â”‚  3. I'll use Round Robin:
â”‚ Service      â”‚     Request 1 â†’ payment-1
â”‚ (Has         â”‚     Request 2 â†’ payment-2
â”‚  Registry)   â”‚     Request 3 â†’ payment-1
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Direct Communication
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order        â”‚  4. API Call       â”‚  Payment-1   â”‚
â”‚ Service      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Service     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Advantages:**

-   No single point of failure (no proxy)
-   Client controls load balancing
-   Fewer network hops (direct communication)

**Disadvantages:**

-   Client needs discovery logic
-   Couples client to discovery mechanism

#### B) Server-Side Discovery

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order        â”‚  1. Call           â”‚  LOAD      â”‚
â”‚ Service      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  BALANCER  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  PAYMENT-SERVICE   â”‚  (Proxy)   â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                                           â”‚
                                           â”‚ 2. Query
                                           â”‚
                                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                                    â”‚  EUREKA    â”‚
                                    â”‚  SERVER    â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                           â”‚
                     3. Route to healthy   â”‚
                        instance           â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â–¼           â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚Payment-1 â”‚  â”‚Payment-2 â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

## 5. Software/Technology Stack

### Required Technologies

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TECHNOLOGY STACK FOR EUREKA MICROSERVICES             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Core Framework:
â”œâ”€ Java 11 or higher
â”œâ”€ Spring Boot 2.7.x or 3.x
â””â”€ Maven 3.6+ or Gradle 7+

Spring Cloud Dependencies:
â”œâ”€ Spring Cloud Netflix Eureka Server
â”œâ”€ Spring Cloud Netflix Eureka Client
â”œâ”€ Spring Cloud Starter LoadBalancer (Ribbon deprecated)
â””â”€ Spring Cloud Version: 2021.0.x (Jubilee) or later

Additional Dependencies:
â”œâ”€ Spring Boot Starter Web (REST APIs)
â”œâ”€ Spring Boot Starter Actuator (Health checks)
â”œâ”€ Lombok (Optional - reduces boilerplate)
â””â”€ Spring Boot DevTools (Optional - development)

Build Tools:
â”œâ”€ Maven (pom.xml)
â””â”€ Gradle (build.gradle)

IDE:
â”œâ”€ IntelliJ IDEA (Recommended)
â”œâ”€ Eclipse with Spring Tools Suite
â””â”€ Visual Studio Code with Spring extensions
```




----------

## 6. Creating Eureka Server {#creating-eureka-server}

### Step-by-Step Implementation

#### Step 1: Create Spring Boot Project

**Using Spring Initializr (start.spring.io):**

```
Project: Maven
Language: Java
Spring Boot: 2.7.14
Project Metadata:
  Group: com.example
  Artifact: eureka-server
  Name: eureka-server
  Package name: com.example.eurekaserver
  Packaging: Jar
  Java: 11

Dependencies:
  - Eureka Server
```

#### Step 2: Maven Dependencies (pom.xml)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.14</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>eureka-server</artifactId>
    <version>1.0.0</version>
    <name>eureka-server</name>
    <description>Eureka Server for Service Registry</description>
    
    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.8</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Eureka Server Dependency -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        
        <!-- Actuator for Health Checks -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Step 3: Main Application Class

java

```java
package com.example.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Eureka Server Application
 * 
 * @EnableEurekaServer - This annotation makes this Spring Boot app 
 * act as a Eureka Server (Service Registry)
 * 
 * Think of this as setting up a "Phone Directory Building"
 * where all microservices will come to register themselves
 */
@SpringBootApplication
@EnableEurekaServer  // â­ KEY ANNOTATION - Enables Eureka Server
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
        System.out.println("ğŸš€ Eureka Server Started Successfully!");
        System.out.println("ğŸ“ Dashboard: http://localhost:8761");
    }
}
```

#### Step 4: Application Configuration (application.yml)

yaml

```yaml
# Eureka Server Configuration
server:
  port: 8761  # Standard port for Eureka Server

spring:
  application:
    name: eureka-server  # Application name

eureka:
  instance:
    hostname: localhost  # Server hostname
    
  client:
    # Should this server register itself as a client? NO!
    # (It's the registry itself, not a client)
    register-with-eureka: false  # â­ Don't register with itself
    fetch-registry: false        # â­ Don't fetch registry from itself
    
    service-url:
      # URL where clients can reach this server
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    # How long to wait before removing inactive services (milliseconds)
    eviction-interval-timer-in-ms: 5000  # Check every 5 seconds
    
    # Disable self-preservation mode for development
    # (In production, keep it enabled)
    enable-self-preservation: false  # âš ï¸ Development only
    
    # Expected heartbeat threshold percentage
    renewal-percent-threshold: 0.85
    
# Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

# Logging Configuration
logging:
  level:
    com.netflix.eureka: DEBUG
    com.netflix.discovery: DEBUG
```

**Configuration Explanation:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONFIGURATION BREAKDOWN                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

register-with-eureka: false
â”œâ”€ Why? Eureka Server doesn't need to register with itself
â””â”€ Analogy: The phone directory doesn't list itself

fetch-registry: false
â”œâ”€ Why? Server IS the registry, no need to fetch
â””â”€ Analogy: The library doesn't check itself for books

enable-self-preservation: false (Development)
â”œâ”€ What? Prevents Eureka from keeping dead services
â”œâ”€ Production: Set to TRUE (prevents cascading failures)
â””â”€ Analogy: In dev, immediately remove closed shops from map
            In prod, keep them listed briefly in case of network issue

eviction-interval-timer-in-ms: 5000
â”œâ”€ How often to check for dead services
â””â”€ Default: 60 seconds, We use 5s for faster dev testing
```

#### Step 5: Alternative Properties Format (application.properties)

properties

```properties
# Server Configuration
server.port=8761

# Application Name
spring.application.name=eureka-server

# Eureka Instance Configuration
eureka.instance.hostname=localhost

# Eureka Client Configuration
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/

# Eureka Server Configuration
eureka.server.eviction-interval-timer-in-ms=5000
eureka.server.enable-self-preservation=false
eureka.server.renewal-percent-threshold=0.85

# Actuator
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always

# Logging
logging.level.com.netflix.eureka=DEBUG
logging.level.com.netflix.discovery=DEBUG
```

### Understanding Eureka Server Internals

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EUREKA SERVER INTERNAL ARCHITECTURE                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EUREKA SERVER                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  REST Endpoints                                    â”‚  â”‚
â”‚  â”‚  /eureka/apps (Get all apps)                       â”‚  â”‚
â”‚  â”‚  /eureka/apps/{appName} (Get specific app)        â”‚  â”‚
â”‚  â”‚  POST /eureka/apps/{appName} (Register)           â”‚  â”‚
â”‚  â”‚  DELETE /eureka/apps/{appName}/{instanceId}       â”‚  â”‚
â”‚  â”‚  PUT /eureka/apps/{appName}/{instanceId} (Renew)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Registry (ConcurrentHashMap)                      â”‚  â”‚
â”‚  â”‚  Key: Application Name                             â”‚  â”‚
â”‚  â”‚  Value: List<InstanceInfo>                         â”‚  â”‚
â”‚  â”‚                                                     â”‚  â”‚
â”‚  â”‚  ORDER-SERVICE â†’ [order-1, order-2]                â”‚  â”‚
â”‚  â”‚  PAYMENT-SERVICE â†’ [payment-1]                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Eviction Timer (Background Thread)                â”‚  â”‚
â”‚  â”‚  - Runs every 60s (default)                        â”‚  â”‚
â”‚  â”‚  - Checks lease expiration                         â”‚  â”‚
â”‚  â”‚  - Removes expired instances                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Self-Preservation Mode                            â”‚  â”‚
â”‚  â”‚  - Monitors heartbeat percentages                  â”‚  â”‚
â”‚  â”‚  - Protects against network partitions             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

----------

## 7. Registering Microservices (Eureka Client) {#registering-microservices}

### Creating Order Service (Eureka Client Example)

#### Step 1: Create Spring Boot Project

```
Project: Maven
Language: Java
Spring Boot: 2.7.14
Project Metadata:
  Group: com.example
  Artifact: order-service
  Name: order-service
  Package name: com.example.orderservice
  Packaging: Jar
  Java: 11

Dependencies:
  - Eureka Discovery Client
  - Spring Web
  - Spring Boot Actuator
  - Lombok (Optional)
```

#### Step 2: Maven Dependencies (pom.xml)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.14</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>order-service</artifactId>
    <version>1.0.0</version>
    <name>order-service</name>
    <description>Order Service - Eureka Client</description>
    
    <properties>
        <java.version>11</java.version>
        <spring-cloud.version>2021.0.8</spring-cloud.version>
    </properties>
    
    <dependencies>
        <!-- Eureka Client Dependency -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        
        <!-- Web for REST APIs -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Actuator for Health Checks -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Lombok (Optional) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### Step 3: Main Application Class

java

```java
package com.example.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * Order Service Application
 * 
 * @EnableEurekaClient - Registers this service with Eureka Server
 * 
 * Note: In newer Spring Cloud versions, @EnableEurekaClient is optional
 * if spring-cloud-starter-netflix-eureka-client is on classpath.
 * But it's good practice to include it for clarity.
 */
@SpringBootApplication
@EnableEurekaClient  // â­ Makes this service a Eureka Client
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
        System.out.println("ğŸ›’ Order Service Started!");
    }
}
```

#### Step 4: Application Configuration (application.yml)
yaml

```yaml
# Eureka Server Configuration
server:
  port: 8761  # Standard port for Eureka Server

spring:
  application:
    name: eureka-server  # Application name

eureka:
  instance:
    hostname: localhost  # Server hostname
    
  client:
    # Should this server register itself as a client? NO!
    # (It's the registry itself, not a client)
    register-with-eureka: false  # â­ Don't register with itself
    fetch-registry: false        # â­ Don't fetch registry from itself
    
    service-url:
      # URL where clients can reach this server
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
      
  server:
    # How long to wait before removing inactive services (milliseconds)
    eviction-interval-timer-in-ms: 5000  # Check every 5 seconds
    
    # Disable self-preservation mode for development
    # (In production, keep it enabled)
    enable-self-preservation: false  # âš ï¸ Development only
    
    # Expected heartbeat threshold percentage
    renewal-percent-threshold: 0.85
    
# Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always

# Logging
logging:
  level:
    com.netflix.discovery: DEBUG
```

**Configuration Breakdown:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EUREKA CLIENT CONFIGURATION EXPLAINED                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

spring.application.name: order-service
â”œâ”€ This is how Eureka identifies your service
â”œâ”€ All instances of Order Service share this name
â””â”€ Other services use THIS NAME to discover you

register-with-eureka: true
â”œâ”€ "Yes, please add me to the registry"
â””â”€ Analogy: Sign the guest book when entering hotel

fetch-registry: true
â”œâ”€ "Yes, give me the list of all other services"
â””â”€ Analogy: Get the hotel directory of all guests

lease-renewal-interval-in-seconds: 30
â”œâ”€ How often to send "I'm alive" heartbeat
â”œâ”€ Default: 30 seconds
â””â”€ Analogy: Check in with reception every 30 seconds

lease-expiration-duration-in-seconds: 90
â”œâ”€ If no heartbeat for 90s, mark as DOWN
â”œâ”€ Should be 3x renewal interval
â””â”€ Analogy: If no check-in for 90s, assume guest left

prefer-ip-address: true
â”œâ”€ Register with IP (192.168.1.10) not hostname (server01)
â”œâ”€ Better for containerized environments
â””â”€ Analogy: Use phone number instead of name
```

#### Step 5: REST Controller

java

```java
package com.example.orderservice.controller;

import com.example.orderservice.model.Order;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.UUID;

/**
 * Order Service REST Controller
 * Demonstrates how to create orders and discover other services
 */
@RestController
@RequestMapping("/orders")
public class OrderController {

    @Value("${spring.application.name}")
    private String applicationName;

    @Value("${server.port}")
    private String port;

    @Autowired
    private DiscoveryClient discoveryClient;  // â­ For service discovery

    /**
     * Get service info - shows this service is registered
     */
    @GetMapping("/info")
    public String getServiceInfo() {
        return String.format(
            "ğŸ›’ Service: %s | Port: %s | Status: Running",
            applicationName, port
        );
    }

    /**
     * Create a new order
     */
    @PostMapping("/create")
    public Order createOrder(@RequestBody Order order) {
        order.setOrderId(UUID.randomUUID().toString());
        order.setStatus("CREATED");
        
        System.out.println("ğŸ“¦ Order created: " + order.getOrderId());
        
        return order;
    }

    /**
     * Get all orders (mock data)
     */
    @GetMapping
    public List<Order> getAllOrders() {
        return List.of(
            new Order("001", "Customer-1", 100.0, "COMPLETED"),
            new Order("002", "Customer-2", 250.0, "PENDING")
        );
    }

    /**
     * Discover all registered services in Eureka
     */
    @GetMapping("/discover")
    public List<String> discoverServices() {
        return discoveryClient.getServices();
    }

    /**
     * Get instances of a specific service
     */
    @GetMapping("/discover/{serviceName}")
    public List<ServiceInstance> getServiceInstances(
        @PathVariable String serviceName
    ) {
        return discoveryClient.getInstances(serviceName);
    }
}
```

#### Step 6: Model Classes

java

```java
package com.example.orderservice.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Order Domain Model
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    private String orderId;
    private String customerId;
    private Double amount;
    private String status;
}
```

### Registration Flow Visualization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVICE REGISTRATION FLOW (Step-by-Step)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 1: Service Startup
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order Serviceâ”‚  Application starts
â”‚ Starting...  â”‚  Spring Boot initializes
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ STEP 2: Read Configuration
       â”‚ - Application name: order-service
       â”‚ - Eureka URL: http://localhost:8761/eureka/
       â”‚ - Port: 8081
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eureka Clientâ”‚  Initialized
â”‚ Initialized  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ STEP 3: Register with Eureka
       â”‚ POST /eureka/apps/ORDER-SERVICE
       â”‚ Body: {instanceId, hostName, ipAddr, port, status...}
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EUREKA SERVERâ”‚  Receives registration
â”‚              â”‚  Adds to registry
â”‚ âœ… Registeredâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ STEP 4: Start Heartbeat Timer
       â”‚ Every 30 seconds: PUT /eureka/apps/ORDER-SERVICE/instance-001
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order Serviceâ”‚  
â”‚ â¤ï¸ Heartbeat  â”‚  Continuously sending heartbeats
â”‚ Running...   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LIFECYCLE EVENTS:
T=0s    â†’ Service starts, registration initiated
T=1s    â†’ Registration complete, service UP
T=30s   â†’ First heartbeat sent
T=60s   â†’ Second heartbeat sent
T=90s   â†’ Third heartbeat sent (continues forever...)

If service crashes:
T=100s  â†’ Service DOWN, no heartbeat
T=190s  â†’ 90s elapsed, Eureka marks as DOWN
T=195s  â†’ Eviction job runs, removes from registry
```

----------

## 8. Discovering Microservices (Service-to-Service Communication)

### Creating Payment Service (Second Eureka Client)

#### Step 1: Payment Service Configuration (application.yml)

yaml

```yaml
# Server Configuration
server:
  port: 8082  # Different port from Order Service

# Application Configuration
spring:
  application:
    name: payment-service  # Different service name

# Eureka Client Configuration
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
      
  instance:
    instance-id: ${spring.application.name}:${random.value}
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 30
    lease-expiration-duration-in-seconds: 90

# Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
```

#### Step 2: Payment Service Main Class

java

```java
package com.example.paymentservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableEurekaClient
public class PaymentServiceApplication {

    /**
     * RestTemplate bean for making HTTP calls to other services
     * Could also use WebClient (reactive) or Feign Client
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(PaymentServiceApplication.class, args);
        System.out.println("ğŸ’³ Payment Service Started!");
    }
}
```

#### Step 3: Payment Controller

java

```java
package com.example.paymentservice.controller;

import com.example.paymentservice.model.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/payments")
public class PaymentController {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private RestTemplate restTemplate;

    /**
     * Process payment
     */
    @PostMapping("/process")
    public Payment processPayment(@RequestBody Payment payment) {
        payment.setPaymentId(UUID.randomUUID().toString());
        payment.setStatus("SUCCESS");
        
        System.out.println("ğŸ’° Payment processed: " + payment.getPaymentId());
        
        return payment;
    }

    /**
     * Get payment info
     */
    @GetMapping("/info")
    public String getInfo() {
        return "ğŸ’³ Payment Service | Port: 8082 | Status: Running";
    }
}
```

#### Step 4: Payment Model

java

```java
package com.example.paymentservice.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Payment {
    private String paymentId;
    private String orderId;
    private Double amount;
    private String method;  // CARD, UPI, NETBANKING
    private String status;
}
```

### Service Discovery Methods

#### Method 1: Using DiscoveryClient (Manual Discovery)

java

```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;

/**
 * Service layer demonstrating manual service discovery
 */
@Service
public class OrderService {

    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private RestTemplate restTemplate;

    /**
     * Call Payment Service using DiscoveryClient
     * 
     * Flow:
     * 1. Get all instances of payment-service from Eureka
     * 2. Choose one instance (simple: take first)
     * 3. Build URL manually
     * 4. Make REST call
     */
    public String callPaymentService(String orderId, Double amount) {
        // Step 1: Get all payment service instances
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("payment-service");
        
        if (instances == null || instances.isEmpty()) {
            return "âŒ Payment Service not available";
        }
        
        // Step 2: Get first available instance
        ServiceInstance instance = instances.get(0);
        
        // Step 3: Build URL
        String baseUrl = instance.getUri().toString();
        String endpoint = baseUrl + "/payments/process";
        
        System.out.println("ğŸ“ Calling: " + endpoint);
        
        // Step 4: Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Step 5: Make REST call
        Payment response = restTemplate.postForObject(
            endpoint, 
            payment, 
            Payment.class
        );
        
        return "âœ… Payment Processed: " + response.getPaymentId();
    }
    
    /**
     * Get service instances info
     */
    public List<ServiceInstance> getPaymentServiceInstances() {
        return discoveryClient.getInstances("payment-service");
    }
}
```

**DiscoveryClient Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DISCOVERY CLIENT FLOW                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Order Service wants to call Payment Service
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Order Serviceâ”‚  "I need payment-service"
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 2. Query DiscoveryClient
          â”‚    discoveryClient.getInstances("payment-service")
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Eureka Clientâ”‚  Looks in local cache (registry)
   â”‚ (Local Cache)â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 3. Returns list of instances
          â”‚    [{uri: http://192.168.1.10:8082, status: UP},
          â”‚     {uri: http://192.168.1.11:8082, status: UP}]
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Order Serviceâ”‚  4. Choose instance (Round Robin, Random, etc.)
   â”‚              â”‚  5. Build URL: http://192.168.1.10:8082/payments/process
   â”‚              â”‚  6. Make HTTP call using RestTemplate
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 7. Direct HTTP call
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Payment      â”‚
   â”‚ Service      â”‚  8. Process request, return response
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Method 2: Using @LoadBalanced RestTemplate (Recommended)

java

```java
package com.example.orderservice.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

/**
 * Configuration for Load Balanced RestTemplate
 */
@Configuration
public class RestTemplateConfig {

    /**
     * @LoadBalanced enables client-side load balancing
     * 
     * Magic: You can now use SERVICE NAME instead of URL!
     * Before: http://192.168.1.10:8082/payments/process
     * After:  http://PAYMENT-SERVICE/payments/process
     * 
     * Spring Cloud LoadBalancer intercepts the call,
     * resolves PAYMENT-SERVICE from Eureka,
     * chooses an instance (load balancing),
     * and makes the actual HTTP call
     */
    @Bean
    @LoadBalanced  // â­ KEY ANNOTATION for service discovery
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**Using LoadBalanced RestTemplate:**

java

```java
package com.example.orderservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class OrderServiceV2 {

    @Autowired
    private RestTemplate restTemplate;  // Load-balanced RestTemplate

    /**
     * Call Payment Service using service name (Load Balanced)
     * 
     * Much simpler than DiscoveryClient approach!
     */
    public String processOrderPayment(String orderId, Double amount) {
        
        // Use SERVICE NAME instead of actual URL
        String paymentServiceUrl = "http://payment-service/payments/process";
        
        // Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Make REST call - LoadBalancer handles everything!
        Payment response = restTemplate.postForObject(
            paymentServiceUrl,
            payment,
            Payment.class
        );
        
        return "âœ… Payment successful: " + response.getPaymentId();
    }
}
```

**LoadBalanced RestTemplate Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LOAD BALANCED REST TEMPLATE FLOW                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Order Service makes call
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Order Serviceâ”‚  restTemplate.postForObject(
   â”‚              â”‚    "http://payment-service/payments/process"
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  )
          â”‚
          â”‚ 2. LoadBalancerInterceptor intercepts
          â”‚    (Because of @LoadBalanced annotation)
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ LoadBalancer   â”‚  "payment-service? Let me resolve that..."
   â”‚ Interceptor    â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 3. Query Eureka Client for instances
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Eureka Client  â”‚  Returns: [instance-1, instance-2, instance-3]
   â”‚ (Local Cache)  â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 4. Choose instance using load balancing algorithm
          â”‚    (Round Robin by default)
          â”‚    Chosen: instance-2 (http://192.168.1.11:8082)
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ LoadBalancer   â”‚  Replace "payment-service" with actual URL
   â”‚ Interceptor    â”‚  http://192.168.1.11:8082/payments/process
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ 5. Execute actual HTTP call
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Payment Serviceâ”‚  Process request
   â”‚ (Instance-2)   â”‚  Return response
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Method 3: Using Spring Cloud OpenFeign (Most Elegant)

**Step 1: Add Feign Dependency**

xml

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

**Step 2: Enable Feign in Main Class**

java

```java
package com.example.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients  // â­ Enable Feign Clients
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

**Step 3: Create Feign Client Interface**

java

```java
package com.example.orderservice.client;

import com.example.orderservice.model.Payment;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * Feign Client for Payment Service
 * 
 * @FeignClient - Creates a REST client automatically
 * name = "payment-service" â†’ Service name in Eureka
 * 
 * You just define the interface, Spring creates implementation!
 */
@FeignClient(name = "payment-service")  // â­ Service name from Eureka
public interface PaymentServiceClient {

    /**
     * Method signature matches Payment Service endpoint
     */
    @PostMapping("/payments/process")
    Payment processPayment(@RequestBody Payment payment);
}
```

**Step 4: Use Feign Client in Service**

java

```java
package com.example.orderservice.service;

import com.example.orderservice.client.PaymentServiceClient;
import com.example.orderservice.model.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class OrderServiceV3 {

    @Autowired
    private PaymentServiceClient paymentServiceClient;  // Inject Feign client

    /**
     * Process order payment using Feign
     * 
     * Cleanest approach - looks like calling a local method!
     */
    public String processOrderWithFeign(String orderId, Double amount) {
        
        // Create payment object
        Payment payment = new Payment(null, orderId, amount, "CARD", null);
        
        // Call Payment Service - looks like local method call!
        Payment response = paymentServiceClient.processPayment(payment);
        
        return "âœ… Payment via Feign: " + response.getPaymentId();
    }
}
```

**Comparison of Discovery Methods:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVICE DISCOVERY METHOD COMPARISON                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. DiscoveryClient (Manual)
   Code: discoveryClient.getInstances("service-name")
   Pros: âœ… Full control over instance selection
         âœ… Can implement custom load balancing
   Cons: âŒ Verbose code
         âŒ Manual URL building
         âŒ Need to handle errors manually
   
2. @LoadBalanced RestTemplate
   Code: restTemplate.get("http://SERVICE-NAME/endpoint")
   Pros: âœ… Simple service name resolution
         âœ… Automatic load balancing
         âœ… Less code than DiscoveryClient
   Cons: âŒ Still need RestTemplate boilerplate
         âŒ Manual error handling
   
3. Feign Client (Recommended)
   Code: feignClient.methodName(params)
   Pros: âœ… Clean interface-based approach
         âœ… Automatic load balancing
         âœ… Minimal boilerplate
         âœ… Built-in error handling
         âœ… Supports circuit breakers
   Cons: âŒ Additional dependency
         âŒ Less control over HTTP details
```

----------

## 9. Complete Use Case Example {#use-case-example}

### E-Commerce Microservices Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  E-COMMERCE MICROSERVICES ECOSYSTEM                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  EUREKA SERVER â”‚
                    â”‚   Port: 8761   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                   All services register here
                             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                      â”‚                      â”‚
      â–¼                      â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ORDER     â”‚      â”‚  PAYMENT    â”‚      â”‚  PRODUCT    â”‚
â”‚  SERVICE    â”‚      â”‚  SERVICE    â”‚      â”‚  SERVICE    â”‚
â”‚ Port: 8081  â”‚      â”‚ Port: 8082  â”‚      â”‚ Port: 8083  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                      â”‚                      â”‚
      â”‚                      â”‚                      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Inter-service communication
              via Eureka discovery
```

### Business Flow

```
USER PLACES ORDER:
1. POST /orders/place
   â†“
2. Order Service:
   - Validates order
   - Calls Product Service (check inventory)
   - Calls Payment Service (process payment)
   - Updates order status
   â†“
3. Returns order confirmation
```

### Implementation: Product Service

**application.yml:**

yaml

```yaml
server:
  port: 8083

spring:
  application:
    name: product-service

eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

**ProductController.java:**

java

```java
package com.example.productservice.controller;

import com.example.productservice.model.Product;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/products")
public class ProductController {

    // Mock inventory
    private Map<String, Product> inventory = new HashMap<>() {{
        put("P001", new Product("P001", "Laptop", 50000.0, 10));
        put("P002", new Product("P002", "Mouse", 500.0, 100));
        put("P003", new Product("P003", "Keyboard", 1500.0, 50));
    }};

    @GetMapping("/{productId}")
    public Product getProduct(@PathVariable String productId) {
        return inventory.getOrDefault(
            productId, 
            new Product(null, "Not Found", 0.0, 0)
        );
    }

    @GetMapping("/{productId}/check-stock")
    public Map<String, Object> checkStock(
        @PathVariable String productId,
        @RequestParam Integer quantity
    ) {
        Product product = inventory.get(productId);
        
        Map<String, Object> response = new HashMap<>();
        
        if (product == null) {
            response.put("available", false);
            response.put("message", "Product not found");
        } else if (product.getStock() >= quantity) {
            response.put("available", true);
            response.put("message", "Stock available");
            response.put("product", product);
        } else {
            response.put("available", false);
            response.put("message", "Insufficient stock");
            response.put("availableStock", product.getStock());
        }
        
        return response;
    }
}
```

### Complete Order Placement Flow

java

```java
package com.example.orderservice.service;

import com.example.orderservice.client.PaymentServiceClient;
import com.example.orderservice.client.ProductServiceClient;
import com.example.orderservice.model.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.UUID;

/**
 * Complete order processing with service discovery
 */
@Service
public class CompleteOrderService {

    @Autowired
    private ProductServiceClient productServiceClient;

    @Autowired
    private PaymentServiceClient paymentServiceClient;

    /**
     * Place order - orchestrates multiple services
     */
    public OrderResponse placeOrder(OrderRequest request) {
        
        String orderId = UUID.randomUUID().toString();
        
        System.out.println("ğŸ“ Step 1: Creating order " + orderId);
        
        // STEP 1: Check product availability
        System.out.println("ğŸ“¦ Step 2: Checking product stock...");
        Map<String, Object> stockCheck = productServiceClient.checkStock(
            request.getProductId(),
            request.getQuantity()
        );
        
        if (!(Boolean) stockCheck.get("available")) {
            return new OrderResponse(
                orderId,
                "FAILED",
                "Product not available: " + stockCheck.get("message")
            );
        }
        
        // STEP 2: Calculate total amount
        Product product = (Product) stockCheck.get("product");
        Double totalAmount = product.getPrice() * request.getQuantity();
        
        System.out.println("ğŸ’° Step 3: Total amount: â‚¹" + totalAmount);
        
        // STEP 3: Process payment
        System.out.println("ğŸ’³ Step 4: Processing payment...");
        Payment paymentRequest = new Payment(
            null,
            orderId,
            totalAmount,
            request.getPaymentMethod(),
            null
        );
        
        Payment paymentResponse = paymentServiceClient.processPayment(
            paymentRequest
        );
        
        if (!"SUCCESS".equals(paymentResponse.getStatus())) {
            return new OrderResponse(
                orderId,
                "FAILED",
                "Payment failed"
            );
        }
        
        // STEP 4: Order successful
        System.out.println("âœ… Step 5: Order completed successfully!");
        
        return new OrderResponse(
            orderId,
            "SUCCESS",
            "Order placed successfully. Payment ID: " + 
            paymentResponse.getPaymentId()
        );
    }
}
```

**Feign Client Interfaces:**

java

```java
// ProductServiceClient.java
@FeignClient(name = "product-service")
public interface ProductServiceClient {
    
    @GetMapping("/products/{productId}/check-stock")
    Map<String, Object> checkStock(
        @PathVariable String productId,
        @RequestParam Integer quantity
    );
}

// PaymentServiceClient.java (already shown earlier)
@FeignClient(name = "payment-service")
public interface PaymentServiceClient {
    
    @PostMapping("/payments/process")
    Payment processPayment(@RequestBody Payment payment);
}
```

----------

## 10. Execution & Testing 

### Starting the Application

**Step-by-Step Execution:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EXECUTION SEQUENCE (IMPORTANT!)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 1: Start Eureka Server FIRST
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  cd eureka-server                â”‚
        â”‚  mvn spring-boot:run             â”‚
        â”‚                                  â”‚
        â”‚  OR                              â”‚
        â”‚                                  â”‚
        â”‚  mvn clean package               â”‚
        â”‚  java -jar target/eureka-server-1.0.0.jar
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Wait for: "Started EurekaServerApplication"
        Access: http://localhost:8761
        
        âš ï¸ IMPORTANT: Wait 30-60 seconds for Eureka to fully start

STEP 2: Start Microservices (any order)
        
        Terminal 2 - Order Service:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  cd order-service                â”‚
        â”‚  mvn spring-boot:run             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Terminal 3 - Payment Service:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  cd payment-service              â”‚
        â”‚  mvn spring-boot:run             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Terminal 4 - Product Service:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  cd product-service              â”‚
        â”‚  mvn spring-boot:run             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 3: Verify Registration
        Wait 30 seconds, then check:
        http://localhost:8761
        
        You should see all three services registered!
```

### Testing the Application

#### 1. Check Eureka Dashboard

```
URL: http://localhost:8761

You should see:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Instances currently registered with Eureka           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application         AMIs    Availability Zones Statusâ”‚
â”‚  ORDER-SERVICE       n/a(1)  (1)                  UP  â”‚
â”‚  PAYMENT-SERVICE     n/a(1)  (1)                  UP  â”‚
â”‚  PRODUCT-SERVICE     n/a(1)  (1)                  UP  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… All services showing "UP" means they're registered!
```

#### 2. Test Individual Services

**Order Service:**

bash

```bash
# Get service info
curl http://localhost:8081/orders/info

Response: ğŸ›’ Service: order-service | Port: 8081 | Status: Running

# Get all orders
curl http://localhost:8081/orders

Response: 
[
  {
    "orderId": "001",
    "customerId": "Customer-1",
    "amount": 100.0,
    "status": "COMPLETED"
  },
  {
    "orderId": "002",
    "customerId": "Customer-2",
    "amount": 250.0,
    "status": "PENDING"
  }
]

# Discover all services
curl http://localhost:8081/orders/discover

Response: ["order-service", "payment-service", "product-service"]

# Get Payment Service instances
curl http://localhost:8081/orders/discover/payment-service

Response:
[
  {
    "instanceId": "payment-service:abc123",
    "host": "192.168.1.10",
    "port": 8082,
    "uri": "http://192.168.1.10:8082",
    "metadata": {},
    "secure": false
  }
]
```

**Payment Service:**

bash

```bash
# Get service info
curl http://localhost:8082/payments/info

Response: ğŸ’³ Payment Service | Port: 8082 | Status: Running

# Process payment
curl -X POST http://localhost:8082/payments/process \
  -H "Content-Type: application/json" \
  -d '{
    "orderId": "ORD001",
    "amount": 1500.0,
    "method": "CARD"
  }'

Response:
{
  "paymentId": "PAY-uuid-generated",
  "orderId": "ORD001",
  "amount": 1500.0,
  "method": "CARD",
  "status": "SUCCESS"
}
```

**Product Service:**

bash

```bash
# Get product details
curl http://localhost:8083/products/P001

Response:
{
  "productId": "P001",
  "name": "Laptop",
  "price": 50000.0,
  "stock": 10
}

# Check stock availability
curl "http://localhost:8083/products/P001/check-stock?quantity=2"

Response:
{
  "available": true,
  "message": "Stock available",
  "product": {
    "productId": "P001",
    "name": "Laptop",
    "price": 50000.0,
    "stock": 10
  }
}
```

#### 3. Test Service-to-Service Communication

**Test Order Service calling Payment Service:**

bash

```bash
# Using Order Service endpoint that calls Payment Service internally
curl -X POST http://localhost:8081/orders/process-payment \
  -H "Content-Type: application/json" \
  -d '{
    "orderId": "ORD12345",
    "amount": 2500.0
  }'

Response: âœ… Payment successful: PAY-xyz789

# Check logs in Order Service terminal:
ğŸ“ Calling: http://payment-service/payments/process
ğŸ’° Payment processed: PAY-xyz789

# Check logs in Payment Service terminal:
ğŸ’° Payment processed: PAY-xyz789
```

#### 4. Test Complete Order Flow

bash

```bash
# Place complete order
curl -X POST http://localhost:8081/orders/place \
  -H "Content-Type: application/json" \
  -d '{
    "customerId": "CUST001",
    "productId": "P001",
    "quantity": 2,
    "paymentMethod": "CARD"
  }'

Response:
{
  "orderId": "550e8400-e29b-41d4-a716-446655440000",
  "status": "SUCCESS",
  "message": "Order placed successfully. Payment ID: PAY-abc123"
}
```

**What happens behind the scenes:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPLETE ORDER FLOW TRACE                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

T=0ms    â”‚ User â†’ POST /orders/place
         â”œâ”€ Order Service receives request
         â”‚
T=10ms   â”‚ Order Service â†’ Product Service
         â”œâ”€ "Check stock for P001, quantity: 2"
         â”œâ”€ Uses Feign Client with service discovery
         â”‚
T=50ms   â”‚ Product Service â†’ Response
         â”œâ”€ "Stock available: Yes"
         â”‚
T=60ms   â”‚ Order Service â†’ Calculate total
         â”œâ”€ Price: â‚¹50,000 Ã— 2 = â‚¹1,00,000
         â”‚
T=70ms   â”‚ Order Service â†’ Payment Service
         â”œâ”€ "Process payment for â‚¹1,00,000"
         â”œâ”€ Uses Feign Client with service discovery
         â”‚
T=120ms  â”‚ Payment Service â†’ Response
         â”œâ”€ "Payment successful: PAY-abc123"
         â”‚
T=130ms  â”‚ Order Service â†’ User
         â””â”€ "Order placed successfully!"

Total Time: 130ms (fast due to local discovery cache!)
```

#### 5. Test Load Balancing (Multiple Instances)

**Start multiple instances of Payment Service:**

bash

```bash
# Terminal 3 - Instance 1 (Port 8082)
cd payment-service
mvn spring-boot:run

# Terminal 4 - Instance 2 (Port 8084)
cd payment-service
mvn spring-boot:run -Dspring-boot.run.arguments=--server.port=8084

# Terminal 5 - Instance 3 (Port 8085)
cd payment-service
mvn spring-boot:run -Dspring-boot.run.arguments=--server.port=8085
```

**Check Eureka Dashboard:**

```
http://localhost:8761

Now you'll see:
PAYMENT-SERVICE     n/a(3)  (3)                  UP
                    â†‘
                3 instances!
```

**Test Load Balancing:**

bash

```bash
# Make 5 calls to Order Service
for i in {1..5}; do
  curl -X POST http://localhost:8081/orders/process-payment \
    -H "Content-Type: application/json" \
    -d '{"orderId":"ORD'$i'","amount":1000}' 
  echo ""
done
```

**Check Payment Service logs:**

```
Instance 1 (8082): Payment processed: PAY-1
Instance 2 (8084): Payment processed: PAY-2
Instance 3 (8085): Payment processed: PAY-3
Instance 1 (8082): Payment processed: PAY-4
Instance 2 (8084): Payment processed: PAY-5

âœ… Round-robin load balancing working!
```

#### 6. Test Fault Tolerance

**Scenario: Kill one Payment Service instance**

bash

```bash
# Kill Instance 2 (Port 8084)
# Stop the process running on Terminal 4

# Wait 90 seconds (lease expiration time)

# Check Eureka Dashboard
http://localhost:8761

PAYMENT-SERVICE     n/a(2)  (2)                  UP
                    â†‘
            Now only 2 instances!

# Make payment calls
curl -X POST http://localhost:8081/orders/process-payment \
  -H "Content-Type: application/json" \
  -d '{"orderId":"ORD999","amount":5000}'

Response: âœ… Payment successful: PAY-xyz

âœ… Still works! Traffic automatically routed to healthy instances
```

**Instance Health Timeline:**

```
T=0s     Instance-2 crashes
T=30s    No heartbeat received (first miss)
T=60s    No heartbeat received (second miss)
T=90s    Lease expired! Eureka marks as DOWN
T=95s    Eviction job runs, removes from registry
T=100s   New requests only go to Instance-1 and Instance-3
```

#### 7. Testing with Postman

**Create Postman Collection:**

json

```json
{
  "info": {
    "name": "Eureka Microservices Testing",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "1. Eureka Dashboard",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "http://localhost:8761",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8761"
        }
      }
    },
    {
      "name": "2. Get All Services",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "http://localhost:8081/orders/discover",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8081",
          "path": ["orders", "discover"]
        }
      }
    },
    {
      "name": "3. Place Complete Order",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"customerId\": \"CUST001\",\n  \"productId\": \"P001\",\n  \"quantity\": 2,\n  \"paymentMethod\": \"CARD\"\n}"
        },
        "url": {
          "raw": "http://localhost:8081/orders/place",
          "protocol": "http",
          "host": ["localhost"],
          "port": "8081",
          "path": ["orders", "place"]
        }
      }
    }
  ]
}
```

#### 8. Monitoring and Debugging

**Check Eureka Server Metrics:**

bash

```bash
# Server health
curl http://localhost:8761/actuator/health

Response:
{
  "status": "UP",
  "components": {
    "diskSpace": {"status": "UP"},
    "ping": {"status": "UP"}
  }
}

# Server metrics
curl http://localhost:8761/actuator/metrics

# Specific metric
curl http://localhost:8761/actuator/metrics/eureka.server.registry-size

Response:
{
  "name": "eureka.server.registry-size",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 3.0
    }
  ]
}
```

**Check Service Health:**

bash

```bash
curl http://localhost:8081/actuator/health

Response:
{
  "status": "UP",
  "components": {
    "discoveryComposite": {
      "status": "UP",
      "components": {
        "eureka": {
          "status": "UP",
          "details": {
            "applications": {
              "ORDER-SERVICE": 1,
              "PAYMENT-SERVICE": 3,
              "PRODUCT-SERVICE": 1
            }
          }
        }
      }
    }
  }
}
```

### Common Issues and Troubleshooting

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMMON ISSUES & SOLUTIONS                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Issue 1: Services not showing in Eureka Dashboard

Solutions:
âœ… Check if Eureka Server is running (http://localhost:8761)
âœ… Verify eureka.client.register-with-eureka=true in service config
âœ… Check eureka.client.service-url.defaultZone URL is correct
âœ… Wait 30 seconds for registration to complete
âœ… Check service logs for connection errors


âŒ Issue 2: Service registered but shows as DOWN

Solutions:
âœ… Check if service is actually running (curl http://localhost:808X)
âœ… Verify actuator health endpoint is accessible
âœ… Check firewall/network connectivity
âœ… Look for exceptions in service logs
âœ… Verify eureka.instance.prefer-ip-address setting


âŒ Issue 3: Service discovery not working

Solutions:
âœ… Check if eureka.client.fetch-registry=true
âœ… Verify @LoadBalanced annotation on RestTemplate
âœ… Check service name matches exactly (case-sensitive)
âœ… Wait for registry cache refresh (30 seconds)
âœ… Check DiscoveryClient is autowired correctly


âŒ Issue 4: Load balancing not distributing evenly

Solutions:
âœ… Verify multiple instances are registered (check dashboard)
âœ… Wait for registry cache to update
âœ… Check if all instances are UP
âœ… Review load balancer configuration
âœ… Use different load balancing strategy if needed


âŒ Issue 5: Service removed from registry unexpectedly

Solutions:
âœ… Check if service is sending heartbeats (logs)
âœ… Verify network connectivity
âœ… Increase lease-expiration-duration-in-seconds
âœ… Check if self-preservation mode triggered
âœ… Look for GC pauses in JVM (might cause heartbeat delays)


âŒ Issue 6: Port already in use

Solutions:
âœ… Kill existing process: lsof -ti:8761 | xargs kill -9
âœ… Use different port: --server.port=8762
âœ… Check no other apps using same port


âŒ Issue 7: Feign client connection refused

Solutions:
âœ… Verify target service is running
âœ… Check service name in @FeignClient matches Eureka registration
âœ… Verify @EnableFeignClients annotation present
âœ… Check Feign client is in component scan path
âœ… Review Feign client method signatures match endpoints
```

### Performance Testing

**Load Testing Script:**

bash

```bash
#!/bin/bash
# load-test.sh

echo "ğŸš€ Starting load test..."

# Number of requests
REQUESTS=100

# Concurrent requests
CONCURRENT=10

# Order Service URL
URL="http://localhost:8081/orders/place"

# Run Apache Bench
ab -n $REQUESTS -c $CONCURRENT -p order-payload.json \
   -T "application/json" $URL

echo "âœ… Load test completed!"
```

**order-payload.json:**

json

```json
{
  "customerId": "CUST001",
  "productId": "P001",
  "quantity": 1,
  "paymentMethod": "CARD"
}
```

**Expected Results:**

```
Concurrency Level:      10
Time taken for tests:   5.234 seconds
Complete requests:      100
Failed requests:        0
Requests per second:    19.11 [#/sec]
Time per request:       523.420 [ms] (mean)
```

----------

## 11. Conclusion

### Key Takeaways

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WHAT WE LEARNED                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… Netflix Eureka solves microservices discovery problems
   - No hardcoded URLs
   - Dynamic service registration
   - Automatic load balancing
   - Fault tolerance

âœ… Eureka Server = Central service registry
   - Maintains list of all services
   - Monitors service health via heartbeats
   - Provides REST API for registration/discovery

âœ… Service Registration is automatic
   - Services register on startup
   - Send heartbeats every 30 seconds
   - De-register on shutdown

âœ… Service Discovery has 3 approaches
   - DiscoveryClient (manual, full control)
   - @LoadBalanced RestTemplate (balanced, simple)
   - Feign Client (cleanest, recommended)

âœ… Key Configuration Parameters
   - register-with-eureka: true (for clients)
   - fetch-registry: true (for clients)
   - lease-renewal-interval-in-seconds: 30
   - lease-expiration-duration-in-seconds: 90
   - enable-self-preservation: true (production)

âœ… Production Considerations
   - Enable self-preservation mode
   - Set up Eureka server cluster (3+ nodes)
   - Configure proper timeouts
   - Implement circuit breakers
   - Monitor registry size and health
   - Use security (Spring Security + HTTPS)
```

### Architecture Benefits

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BENEFITS OF EUREKA-BASED ARCHITECTURE                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. SCALABILITY
   â””â”€ Add/remove service instances dynamically
   â””â”€ No configuration changes needed
   â””â”€ Automatic load distribution

2. RESILIENCE
   â””â”€ Automatic failover to healthy instances
   â””â”€ Self-preservation during network issues
   â””â”€ No single point of failure (with Eureka cluster)

3. MAINTAINABILITY
   â””â”€ No hardcoded dependencies
   â””â”€ Easy to update/replace services
   â””â”€ Clear service boundaries

4. DEVELOPMENT SPEED
   â””â”€ Services can be developed independently
   â””â”€ Easy local testing
   â””â”€ Simple integration

5. OPERATIONAL EXCELLENCE
   â””â”€ Real-time visibility of all services
   â””â”€ Health monitoring built-in
   â””â”€ Easy debugging and troubleshooting
```

### Advanced Topics (Future Learning)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NEXT STEPS FOR DEEPER LEARNING                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. EUREKA CLUSTERING
   - Multiple Eureka servers for HA
   - Peer-to-peer replication
   - Zone awareness

2. SECURITY
   - Securing Eureka Server (Spring Security)
   - HTTPS/TLS communication
   - Service authentication

3. ADVANCED LOAD BALANCING
   - Custom load balancing rules
   - Zone-aware routing
   - Weighted load balancing

4. CIRCUIT BREAKERS
   - Resilience4j integration
   - Fallback mechanisms
   - Bulkhead patterns

5. SERVICE MESH
   - Istio/Linkerd integration
   - Replace Eureka with service mesh
   - Advanced traffic management

6. MONITORING & OBSERVABILITY
   - Distributed tracing (Zipkin/Jaeger)
   - Metrics (Prometheus/Grafana)
   - Centralized logging (ELK Stack)

7. CONTAINERIZATION
   - Docker containers
   - Kubernetes service discovery
   - Helm charts for deployment

8. API GATEWAY
   - Spring Cloud Gateway
   - Zuul (older)
   - Single entry point for clients
```

### Production Checklist

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRODUCTION READINESS CHECKLIST                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

EUREKA SERVER:
â˜ Deploy 3+ Eureka servers for HA
â˜ Enable peer replication
â˜ Configure proper retention thresholds
â˜ Enable self-preservation in production
â˜ Secure with authentication
â˜ Set up monitoring and alerts
â˜ Configure proper JVM heap size
â˜ Use external configuration (Config Server)

MICROSERVICES:
â˜ Configure health check endpoints
â˜ Set appropriate timeout values
â˜ Implement circuit breakers
â˜ Add retry logic with exponential backoff
â˜ Configure proper thread pools
â˜ Enable actuator with security
â˜ Implement graceful shutdown
â˜ Add correlation IDs for tracing

INFRASTRUCTURE:
â˜ Set up load balancers
â˜ Configure DNS properly
â˜ Implement backup and recovery
â˜ Set up CI/CD pipelines
â˜ Configure log aggregation
â˜ Set up APM tools
â˜ Implement chaos engineering tests
â˜ Document runbooks for incidents

SECURITY:
â˜ Use HTTPS everywhere
â˜ Implement OAuth2/JWT
â˜ Enable CORS properly
â˜ Scan for vulnerabilities
â˜ Implement rate limiting
â˜ Add input validation
â˜ Secure sensitive configuration
â˜ Regular security audits
```

### Final Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMPLETE MICROSERVICES ARCHITECTURE WITH EUREKA             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                         USERS
                           â”‚
                           â”‚ HTTPS
                           â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  API GATEWAY â”‚
                    â”‚  (Port 8080) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚            â”‚            â”‚
              â–¼            â–¼            â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  EUREKA   â”‚ â”‚  EUREKA   â”‚ â”‚  EUREKA   â”‚
       â”‚  SERVER-1 â”‚ â”‚  SERVER-2 â”‚ â”‚  SERVER-3 â”‚
       â”‚ (8761)    â”‚ â”‚ (8762)    â”‚ â”‚ (8763)    â”‚
       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
             â”‚             â”‚             â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ Peer Replication
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚  SERVICE REGISTRY          â”‚
             â”‚  (Replicated across all)   â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                    â”‚                    â”‚
      â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ORDER   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ PAYMENT  â”‚         â”‚ PRODUCT  â”‚
â”‚ SERVICE  â”‚  Feign  â”‚ SERVICE  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ SERVICE  â”‚
â”‚          â”‚         â”‚          â”‚  Feign  â”‚          â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                    â”‚                    â”‚
   â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â”                â”Œâ”€â”´â”€â”
   â”‚DB â”‚                â”‚DB â”‚                â”‚DB â”‚
   â””â”€â”€â”€â”˜                â””â”€â”€â”€â”˜                â””â”€â”€â”€â”˜

COMMUNICATION FLOW:
1. User â†’ API Gateway
2. Gateway â†’ Service Discovery (Eureka)
3. Gateway â†’ Routes to appropriate service
4. Services discover each other via Eureka
5. Direct service-to-service calls (no proxy)
6. Automatic load balancing across instances
7. Health checks ensure only healthy instances receive traffic
```

### Summary in Simple Terms

**Think of Eureka like a Smart Phone Directory:**

```
WITHOUT EUREKA (Old Way):
ğŸ“± You memorize everyone's phone number
âŒ When someone changes number, you can't call them
âŒ You don't know if they're available
âŒ You call the same person even if they're busy

WITH EUREKA (Smart Way):
ğŸ“± Everyone automatically adds themselves to directory
âœ… You just look up name, get current number
âœ… Directory shows who's available
âœ… Automatically calls least busy person
âœ… If someone's unavailable, tries someone else
```

**Real-World Analogy:**

```
EUREKA SERVER = Hotel Reception
â”œâ”€ Maintains guest registry
â”œâ”€ Knows which room each guest is in
â”œâ”€ Knows who's in/out
â””â”€ Helps guests find each other

SERVICES = Hotel Guests
â”œâ”€ Check in when they arrive (register)
â”œâ”€ Periodically confirm they're still there (heartbeat)
â”œâ”€ Ask reception to find other guests (discovery)
â””â”€ Check out when they leave (de-register)
```

----------

## Appendix: Complete Code Repository Structure

```
microservices-eureka-example/
â”‚
â”œâ”€â”€ eureka-server/
â”‚   â”œâ”€â”€ src/main/java/com/example/eurekaserver/
â”‚   â”‚   â””â”€â”€ EurekaServerApplication.java
â”‚   â”œâ”€â”€ src/main/resources/
â”‚   â”‚   â””â”€â”€ application.yml
â”‚   â””â”€â”€ pom.xml
â”‚
â”œâ”€â”€ order-service/
â”‚   â”œâ”€â”€ src/main/java/com/example/orderservice/
â”‚   â”‚   â”œâ”€â”€ OrderServiceApplication.java
â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â””â”€â”€ OrderController.java
â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderService.java
â”‚   â”‚   â”‚   â””â”€â”€ CompleteOrderService.java
â”‚   â”‚   â”œâ”€â”€ client/
â”‚   â”‚   â”‚   â”œâ”€â”€ PaymentServiceClient.java
â”‚   â”‚   â”‚   â””â”€â”€ ProductServiceClient.java
â”‚   â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”‚   â”œâ”€â”€ Order.java
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderRequest.java
â”‚   â”‚   â”‚   â”œâ”€â”€ OrderResponse.java
â”‚   â”‚   â”‚   â””â”€â”€ Payment.java
â”‚   â”‚   â””â”€â”€ config/
â”‚   â”‚       â””â”€â”€ RestTemplateConfig.java
â”‚   â”œâ”€â”€ src/main/resources/
â”‚   â”‚   â””â”€â”€ application.yml
â”‚   â””â”€â”€ pom.xml
â”‚
â”œâ”€â”€ payment-service/
â”‚   â”œâ”€â”€ src/main/java/com/example/paymentservice/
â”‚   â”‚   â”œâ”€â”€ PaymentServiceApplication.java
â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â””â”€â”€ PaymentController.java
â”‚   â”‚   â””â”€â”€ model/
â”‚   â”‚       â””â”€â”€ Payment.java
â”‚   â”œâ”€â”€ src/main/resources/
â”‚   â”‚   â””â”€â”€ application.yml
â”‚   â””â”€â”€ pom.xml
â”‚
â”œâ”€â”€ product-service/
â”‚   â”œâ”€â”€ src/main/java/com/example/productservice/
â”‚   â”‚   â”œâ”€â”€ ProductServiceApplication.java
â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â””â”€â”€ ProductController.java
â”‚   â”‚   â””â”€â”€ model/
â”‚   â”‚       â””â”€â”€ Product.java
â”‚   â”œâ”€â”€ src/main/resources/
â”‚   â”‚   â””â”€â”€ application.yml
â”‚   â””â”€â”€ pom.xml
â”‚
â”œâ”€â”€ README.md
â””â”€â”€ docker-compose.yml (Optional - for containerization)
```

----------

## ğŸ“ Congratulations!

You now understand: 
âœ… Why Netflix Eureka is essential for microservices
âœ… How service registry and discovery work 
âœ… How to create and configure Eureka Server
âœ… How to register services as Eureka clients
âœ… How to discover and communicate between services
âœ… How to test and troubleshoot the complete system


