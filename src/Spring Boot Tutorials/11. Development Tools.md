# Complete Guide: Maven, Logging, Postman & Lombok

## Table of Contents

1.  Maven
2.  Logging
3.  Postman
4.  Lombok

----------

# Maven

## What is Maven?

**Analogy**: Think of Maven as a  **construction project manager**  for your Java application. Just like a construction manager handles blueprints, orders materials, coordinates workers, and ensures everything is built in the right sequence, Maven manages your project dependencies, builds your code, and organizes your project structure.

## Core Concepts

### 1. Project Object Model (POM)

The  `pom.xml`  file is Maven's blueprint - it's the heart of every Maven project.

**Memory Visualization**:

```
┌─────────────────────────────────────┐
│          pom.xml File               │
├─────────────────────────────────────┤
│  Project Coordinates (GAV)          │
│  ├─ GroupId: com.mycompany         │
│  ├─ ArtifactId: my-app             │
│  └─ Version: 1.0.0                 │
├─────────────────────────────────────┤
│  Dependencies                       │
│  ├─ Spring Framework 5.3.0         │
│  ├─ JUnit 4.13                     │
│  └─ Lombok 1.18.24                 │
├─────────────────────────────────────┤
│  Build Configuration                │
│  └─ Plugins (Compiler, JAR, etc.)  │
└─────────────────────────────────────┘
```

### 2. Maven Coordinates (GAV)

Every Maven artifact is uniquely identified by three coordinates:

-   **GroupId**: Organization/company (e.g.,  `com.netflix`)
-   **ArtifactId**: Project name (e.g.,  `hystrix-core`)
-   **Version**: Version number (e.g.,  `1.5.18`)

**Analogy**: Think of it like a  **postal address**:

-   GroupId = Country/State
-   ArtifactId = City/Street
-   Version = House number

### 3. Maven Repository

**Local Repository**:  `~/.m2/repository`  (your personal library)  **Central Repository**: Maven Central (the public library)

**Memory Visualization**:

```
Maven Dependency Resolution Flow:
┌──────────────┐
│ Your Project │
└──────┬───────┘
       │ Need: Spring 5.3.0
       ↓
┌─────────────────┐     NO      ┌──────────────────┐
│ Local Repo      │────────────→│ Maven Central    │
│ ~/.m2/repository│             │ (Internet)       │
└─────────────────┘             └────────┬─────────┘
       ↑                                  │
       └──────────── Download ────────────┘
       │
       │ Found! Load into project
       ↓
┌──────────────┐
│ Your Project │
│ (with Spring)│
└──────────────┘
```

## Maven Lifecycle

Maven has three built-in lifecycles:

### 1.  **Default Lifecycle**  (for building and deploying)

**Analogy**: Like cooking a meal step-by-step:

```
validate  →  compile  →  test  →  package  →  install  →  deploy
   ↓            ↓         ↓         ↓           ↓          ↓
Check       Cook      Taste    Put in     Store in    Share with
recipe    ingredients  food   container   pantry      friends
```

**Key Phases**:

-   **validate**: Check if project is correct
-   **compile**: Compile source code
-   **test**: Run unit tests
-   **package**: Create JAR/WAR file
-   **install**: Install to local repository
-   **deploy**: Copy to remote repository

## Simple Example

### Basic pom.xml

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    
    <!-- Project Coordinates -->
    <groupId>com.example</groupId>
    <artifactId>my-first-app</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    
    <!-- Project Properties -->
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <!-- Dependencies -->
    <dependencies>
        <!-- JUnit for testing -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### Common Maven Commands

bash

```bash
# Clean the project (delete target folder)
mvn clean

# Compile the source code
mvn compile

# Run tests
mvn test

# Create JAR/WAR file
mvn package

# Install to local repository
mvn install

# Clean and package in one command
mvn clean package
```

### Dependency Scopes

**Memory Visualization**:

```
┌─────────────────────────────────────────┐
│        Dependency Scopes                │
├─────────────────────────────────────────┤
│ compile (default)                       │
│ ├─ Available: Everywhere                │
│ └─ Example: Spring Framework            │
├─────────────────────────────────────────┤
│ test                                    │
│ ├─ Available: Only in test code         │
│ └─ Example: JUnit                       │
├─────────────────────────────────────────┤
│ provided                                │
│ ├─ Available: Compile time only         │
│ └─ Example: Servlet API (server has it) │
├─────────────────────────────────────────┤
│ runtime                                 │
│ ├─ Available: Runtime only              │
│ └─ Example: JDBC drivers                │
└─────────────────────────────────────────┘
```

----------

# Logging

## What is Logging?

**Analogy**: Logging is like a  **flight recorder (black box)**  in an airplane. It continuously records what's happening so you can understand what went wrong if there's a problem, or verify that everything worked correctly.

## Why Logging Over System.out.println()?

**Comparison**:

```
System.out.println()        vs        Proper Logging
─────────────────                     ──────────────
❌ No log levels                       ✅ DEBUG, INFO, WARN, ERROR
❌ Can't turn off                      ✅ Configure per environment
❌ Goes only to console                ✅ File, database, cloud
❌ No timestamps                       ✅ Automatic timestamps
❌ Hard to search                      ✅ Structured, searchable
❌ Performance impact                  ✅ Efficient, asynchronous
```

## Logging Levels

**Memory Visualization**:

```
        ┌─────────────────────────────────┐
        │  Logging Level Hierarchy        │
        └─────────────────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   TRACE (Most Verbose)│  "Entering method calculateTotal()"
        └──────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   DEBUG               │  "User ID: 123, Cart items: 5"
        └──────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   INFO                │  "Order placed successfully"
        └──────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   WARN                │  "Low inventory for item X"
        └──────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   ERROR               │  "Failed to process payment"
        └──────────────────────┘
                     ↓
        ┌──────────────────────┐
        │   FATAL (Least Verbose)│ "Database connection lost"
        └──────────────────────┘
```

**When to use each level**:

-   **TRACE**: Very detailed, step-by-step execution
-   **DEBUG**: Debugging information, variable values
-   **INFO**: General information, normal operations
-   **WARN**: Potential issues, deprecated usage
-   **ERROR**: Errors that don't crash the app
-   **FATAL**: Severe errors that cause shutdown

## Popular Logging Frameworks

### 1. SLF4J (Simple Logging Facade for Java)

**Analogy**: SLF4J is like a  **universal remote control**. Just as a universal remote can control different TV brands, SLF4J provides a common interface for different logging implementations.

**Architecture**:

```
Your Application Code
        ↓
    SLF4J API (Interface)
        ↓
   Binding Layer
        ↓
┌───────┴───────┬──────────┐
│               │          │
Logback      Log4j2      JUL
(Implementation)
```

### 2. Logback (Most Popular)

**Maven Dependency**:

xml

```xml
<dependencies>
    <!-- SLF4J API -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.9</version>
    </dependency>
    
    <!-- Logback Implementation -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.11</version>
    </dependency>
</dependencies>
```

### Simple Logging Example

java

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class UserService {
    // Create logger for this class
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);
    
    public void createUser(String username, String email) {
        logger.info("Creating new user: {}", username);
        
        try {
            // Business logic
            validateEmail(email);
            saveToDatabase(username, email);
            
            logger.info("User created successfully: {}", username);
            
        } catch (InvalidEmailException e) {
            logger.error("Invalid email for user {}: {}", username, email, e);
            throw e;
            
        } catch (DatabaseException e) {
            logger.error("Database error while creating user {}", username, e);
            throw e;
        }
    }
    
    private void validateEmail(String email) {
        logger.debug("Validating email: {}", email);
        
        if (!email.contains("@")) {
            logger.warn("Email validation failed: missing @ symbol");
            throw new InvalidEmailException("Invalid email format");
        }
    }
}
```

### Logback Configuration (logback.xml)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
    
    <!-- Specific package logging -->
    <logger name="com.example.service" level="DEBUG" />
    
</configuration>
```

### Log Pattern Explained

```
Pattern: %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

Output: 14:32:45.123 [main] INFO  com.example.UserService - User created successfully: john

Breakdown:
%d{HH:mm:ss.SSS}  →  14:32:45.123        (Timestamp)
[%thread]          →  [main]              (Thread name)
%-5level           →  INFO                (Log level, padded to 5 chars)
%logger{36}        →  com.example.UserService (Logger name, max 36 chars)
-                  →  -                   (Separator)
%msg               →  User created...     (Your message)
%n                 →  (newline)
```

### Memory Visualization: How Logging Works

```
┌───────────────────────────────────────────────┐
│         Logging Architecture                  │
└───────────────────────────────────────────────┘

1. Your Code:
   logger.info("User {} logged in", username);
           ↓
2. SLF4J API (Interface):
   Receives the log request
           ↓
3. Logback (Implementation):
   ├─ Checks log level (is INFO enabled?)
   ├─ Formats the message
   └─ Passes to appenders
           ↓
4. Appenders (Destinations):
   ├─ Console Appender → System.out
   ├─ File Appender → application.log
   └─ Custom Appender → Database, Slack, etc.
```

----------

# Postman

## What is Postman?

**Analogy**: Postman is like a  **mail delivery service tester**. Before you build a full mailbox system, you want to test if letters (requests) can be delivered correctly and you get the right responses back. Postman lets you send HTTP requests and see responses without writing code.

## Why Use Postman?

```
Without Postman:                With Postman:
───────────────                 ─────────────
1. Write Java code              1. Click and type
2. Compile                      2. Send request
3. Run application              3. See response immediately
4. Debug issues                 4. Save for reuse
5. Restart for changes          5. Share with team
```

## HTTP Request Structure

**Memory Visualization**:

```
┌─────────────────────────────────────────┐
│         HTTP Request                    │
├─────────────────────────────────────────┤
│ METHOD: GET, POST, PUT, DELETE, etc.    │
├─────────────────────────────────────────┤
│ URL: http://api.example.com/users/123   │
├─────────────────────────────────────────┤
│ HEADERS:                                │
│   Content-Type: application/json        │
│   Authorization: Bearer token123        │
├─────────────────────────────────────────┤
│ BODY (for POST/PUT):                    │
│   {                                     │
│     "name": "John",                     │
│     "email": "john@example.com"         │
│   }                                     │
└─────────────────────────────────────────┘
          ↓
    Send to Server
          ↓
┌─────────────────────────────────────────┐
│         HTTP Response                   │
├─────────────────────────────────────────┤
│ STATUS CODE: 200 OK                     │
├─────────────────────────────────────────┤
│ HEADERS:                                │
│   Content-Type: application/json        │
├─────────────────────────────────────────┤
│ BODY:                                   │
│   {                                     │
│     "id": 123,                          │
│     "name": "John",                     │
│     "email": "john@example.com"         │
│   }                                     │
└─────────────────────────────────────────┘
```

## HTTP Methods (CRUD Operations)

**Analogy**: Think of HTTP methods as  **actions at a library**:

```
HTTP Method    CRUD      Library Analogy              Example URL
───────────    ────      ───────────────              ───────────
GET            Read      Browse/Read a book           GET /books/123
POST           Create    Add new book to library      POST /books
PUT            Update    Replace entire book          PUT /books/123
PATCH          Update    Update book's page           PATCH /books/123
DELETE         Delete    Remove book from library     DELETE /books/123
```

## Status Codes

**Memory Visualization**:

```
┌────────────────────────────────────────────────┐
│          HTTP Status Codes                     │
├────────────────────────────────────────────────┤
│ 1xx: Informational (rare)                      │
│   100 - Continue                               │
├────────────────────────────────────────────────┤
│ 2xx: Success ✅                                │
│   200 - OK (GET request succeeded)             │
│   201 - Created (POST created new resource)    │
│   204 - No Content (DELETE succeeded)          │
├────────────────────────────────────────────────┤
│ 3xx: Redirection                               │
│   301 - Moved Permanently                      │
│   302 - Found (temporary redirect)             │
├────────────────────────────────────────────────┤
│ 4xx: Client Errors ❌                          │
│   400 - Bad Request (invalid data)             │
│   401 - Unauthorized (not logged in)           │
│   403 - Forbidden (no permission)              │
│   404 - Not Found (resource doesn't exist)     │
│   409 - Conflict (duplicate entry)             │
├────────────────────────────────────────────────┤
│ 5xx: Server Errors 💥                          │
│   500 - Internal Server Error                  │
│   502 - Bad Gateway                            │
│   503 - Service Unavailable                    │
└────────────────────────────────────────────────┘
```

## Postman Features

### 1. Collections

**Analogy**: Collections are like  **recipe books**. Each collection contains related API requests, just like a recipe book contains related recipes.

```
Collection: E-commerce API
├── Users
│   ├── GET All Users
│   ├── GET User by ID
│   ├── POST Create User
│   ├── PUT Update User
│   └── DELETE User
├── Products
│   ├── GET All Products
│   ├── POST Create Product
│   └── DELETE Product
└── Orders
    ├── POST Create Order
    └── GET Order History
```

### 2. Environment Variables

**Analogy**: Like having  **different phone numbers**  for work and home. Environments let you switch between different servers (dev, staging, production) easily.

```
Development Environment:
├── base_url: http://localhost:8080
├── api_key: dev_key_123
└── db_name: dev_database

Production Environment:
├── base_url: https://api.production.com
├── api_key: prod_key_xyz
└── db_name: prod_database

Usage in Postman:
{{base_url}}/api/users
```

### 3. Example Request Flow

#### GET Request Example

```
Request:
GET {{base_url}}/api/users/123
Headers:
  Authorization: Bearer {{token}}
  Accept: application/json

Response (200 OK):
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-01-15T10:30:00Z"
}
```

#### POST Request Example

```
Request:
POST {{base_url}}/api/users
Headers:
  Content-Type: application/json
  Authorization: Bearer {{token}}
Body (JSON):
{
  "name": "Jane Smith",
  "email": "jane@example.com",
  "password": "secure123"
}

Response (201 Created):
{
  "id": 124,
  "name": "Jane Smith",
  "email": "jane@example.com",
  "createdAt": "2025-10-26T14:30:00Z"
}
```

### 4. Tests in Postman

Postman allows you to write JavaScript tests to verify responses:

javascript

```javascript
// Test 1: Check status code
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

// Test 2: Check response time
pm.test("Response time is less than 500ms", function () {
    pm.expect(pm.response.responseTime).to.be.below(500);
});

// Test 3: Verify response structure
pm.test("Response has user data", function () {
    var jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property('id');
    pm.expect(jsonData).to.have.property('name');
    pm.expect(jsonData.email).to.include('@');
});

// Test 4: Save data for next request
pm.test("Save user ID", function () {
    var jsonData = pm.response.json();
    pm.environment.set("user_id", jsonData.id);
});
```

----------

# Lombok

## What is Lombok?

**Analogy**: Lombok is like a  **smart assistant**  that writes repetitive code for you. Just like you might say "Hey assistant, write a formal letter" and they handle the template, Lombok generates boilerplate Java code automatically.

## The Boilerplate Problem

**Without Lombok**  - Traditional Java Class:

java

```java
public class User {
    private Long id;
    private String name;
    private String email;
    private LocalDateTime createdAt;
    
    // Default constructor
    public User() {
    }
    
    // All-args constructor
    public User(Long id, String name, String email, LocalDateTime createdAt) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.createdAt = createdAt;
    }
    
    // Getters
    public Long getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    // Setters
    public void setId(Long id) {
        this.id = id;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    // equals()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id) &&
               Objects.equals(name, user.name) &&
               Objects.equals(email, user.email) &&
               Objects.equals(createdAt, user.createdAt);
    }
    
    // hashCode()
    @Override
    public int hashCode() {
        return Objects.hash(id, name, email, createdAt);
    }
    
    // toString()
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", createdAt=" + createdAt +
                '}';
    }
}
// Total: ~100 lines of code 😫
```

**With Lombok**  - Same Functionality:

java

```java
import lombok.Data;

@Data
public class User {
    private Long id;
    private String name;
    private String email;
    private LocalDateTime createdAt;
}
// Total: 8 lines of code! 🎉
```

## How Lombok Works

**Memory Visualization**:

```
┌────────────────────────────────────────────────┐
│        Lombok Processing Flow                  │
└────────────────────────────────────────────────┘

1. You Write:
   @Data
   public class User {
       private String name;
   }
           ↓
2. Compile Time (javac):
   Lombok Annotation Processor intercepts
           ↓
3. Lombok Generates:
   - getName()
   - setName()
   - equals()
   - hashCode()
   - toString()
           ↓
4. Compiled .class file contains:
   All generated methods
           ↓
5. Runtime:
   Full class with all methods available
```

## Maven Setup

xml

```xml
<dependencies>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
```

**Note**:  `scope=provided`  means Lombok is only needed at compile time, not at runtime.

## Popular Lombok Annotations

### 1. @Getter and @Setter

java

```java
import lombok.Getter;
import lombok.Setter;

public class Product {
    @Getter @Setter
    private Long id;
    
    @Getter @Setter
    private String name;
    
    @Getter  // Only getter, no setter (immutable)
    private Double price;
    
    public Product(Long id, String name, Double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
}

// Usage:
Product product = new Product(1L, "Laptop", 999.99);
System.out.println(product.getName());  // Laptop
product.setName("Desktop");  // Works
// product.setPrice(1200.00);  // ❌ No setter generated
```

### 2. @ToString

java

```java
import lombok.ToString;

@ToString
public class Order {
    private Long orderId;
    private String customerName;
    private Double totalAmount;
}

// Generated toString():
// Order(orderId=123, customerName=John, totalAmount=299.99)

// Exclude sensitive fields:
@ToString(exclude = {"creditCardNumber"})
public class Payment {
    private Long paymentId;
    private String creditCardNumber;
    private Double amount;
}
```

### 3. @EqualsAndHashCode

java

```java
import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class Student {
    private Long studentId;
    private String name;
    private String email;
}

// Usage:
Student s1 = new Student(1L, "John", "john@edu.com");
Student s2 = new Student(1L, "John", "john@edu.com");
System.out.println(s1.equals(s2));  // true

// Exclude fields from equals/hashCode:
@EqualsAndHashCode(exclude = {"lastLoginDate"})
public class User {
    private Long userId;
    private String username;
    private LocalDateTime lastLoginDate;
}
```

### 4. @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor

java

```java
import lombok.*;

@NoArgsConstructor        // Default constructor
@AllArgsConstructor       // Constructor with all fields
public class Employee {
    private Long id;
    private String name;
    private String department;
}

// Generated constructors:
Employee e1 = new Employee();                        // NoArgs
Employee e2 = new Employee(1L, "John", "IT");       // AllArgs

// RequiredArgsConstructor: Constructor for final/non-null fields only
@RequiredArgsConstructor
public class Service {
    private final Database database;  // Required
    private final Logger logger;      // Required
    private String configFile;        // Optional
}

// Generated constructor:
Service service = new Service(database, logger);
```

### 5. @Data (The Swiss Army Knife)

**@Data is a shortcut annotation that combines:**

-   @Getter (on all fields)
-   @Setter (on all non-final fields)
-   @ToString
-   @EqualsAndHashCode
-   @RequiredArgsConstructor

java

```java
import lombok.Data;

@Data
public class Book {
    private Long id;
    private String title;
    private String author;
    private Double price;
    private Integer quantity;
}

// Equivalent to writing all of these:
// @Getter @Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor
```

### 6. @Builder (Design Pattern Made Easy)

**Analogy**: Builder pattern is like ordering at  **Subway**  - you pick and choose what you want step by step.

java

```java
import lombok.Builder;

@Builder
public class Pizza {
    private String size;
    private boolean cheese;
    private boolean pepperoni;
    private boolean mushrooms;
    private boolean olives;
}

// Usage - Fluent API:
Pizza myPizza = Pizza.builder()
    .size("Large")
    .cheese(true)
    .pepperoni(true)
    .mushrooms(false)
    .olives(true)
    .build();

// Can skip optional fields:
Pizza simplePizza = Pizza.builder()
    .size("Medium")
    .cheese(true)
    .build();
```

### 7. @Slf4j (Logging Integration)

java

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class UserService {
    
    public void createUser(String username) {
        log.info("Creating user: {}", username);
        
        try {
            // Business logic
            log.debug("Validating username: {}", username);
            
        } catch (Exception e) {
            log.error("Error creating user: {}", username, e);
        }
    }
}

// Lombok generates:
// private static final Logger log = LoggerFactory.getLogger(UserService.class);
```

### 8. @Value (Immutable Classes)

java

```java
import lombok.Value;

@Value  // Creates immutable class
public class Point {
    int x;
    int y;
}

// Generated:
// - All fields are private final
// - Only getters (no setters)
// - AllArgsConstructor
// - equals(), hashCode(), toString()

Point p = new Point(10, 20);
// p.setX(15);  // ❌ No setters - immutable!
System.out.println(p.getX());  // 10
```

### 9. @NonNull (Null Checks)

java

```java
import lombok.NonNull;

public class UserService {
    
    public void sendEmail(@NonNull String email, @NonNull String subject) {
        // Lombok adds null checks automatically
        // If email or subject is null, throws NullPointerException
        System.out.println("Sending email to: " + email);
    }
}

// Generated code includes:
// if (email == null) throw new NullPointerException("email is marked non-null but is null");
```

### 10. @Cleanup (Resource Management)

java

```java
import lombok.Cleanup;
import java.io.*;

public class FileProcessor {
    
    public void readFile(String path) throws IOException {
        @Cleanup InputStream in = new FileInputStream(path);
        // File will be automatically closed at end of scope
        // Similar to try-with-resources
    }
}

// Lombok generates:
// try {
//     InputStream in = new FileInputStream(path);
//     // your code
// } finally {
//     in.close();
// }
```

## Practical Example: Combining Multiple Annotations

java

```java
import lombok.*;
import lombok.extern.slf4j.Slf4j;

@Data
@Builder
@Slf4j
@NoArgsConstructor
@AllArgsConstructor
public class BlogPost {
    
    private Long id;
    
    @NonNull
    private String title;
    
    @NonNull
    private String content;
    
    private String author;
    
    @Builder.Default
    private Integer views = 0;
    
    @Builder.Default
    private LocalDateTime createdAt = LocalDateTime.now();
    
    // Custom business method
    public void incrementViews() {
        this.views++;
        log.info("Post '{}' views incremented to {}", title, views);
    }
}

// Usage:
BlogPost post = BlogPost.builder()
    .id(1L)
    .title("Learning Lombok")
    .content("Lombok makes Java development easier...")
    .author("John Doe")
    .build();

post.incrementViews();
System.out.println(post);  // Uses @ToString
```

## Common Pitfalls and Best Practices

### ❌ Don't Use @Data with JPA Entities

**Problem**: @Data includes @EqualsAndHashCode which can cause issues with lazy loading.

java

```java
// ❌ BAD - Can cause issues
@Data
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany
    private List<Order> orders;
}

// ✅ GOOD - Use specific annotations
@Getter
@Setter
@ToString(exclude = "orders")
@EqualsAndHashCode(of = "id")
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany
    private List<Order> orders;
}
```

### ✅ Use @Builder with @Value for Immutable Objects

java

```java
@Value
@Builder
public class Configuration {
    String serverUrl;
    int timeout;
    boolean sslEnabled;
}

Configuration config = Configuration.builder()
    .serverUrl("https://api.example.com")
    .timeout(30)
    .sslEnabled(true)
    .build();
```

### ✅ Combine with Validation Annotations

java

```java
import lombok.Data;
import javax.validation.constraints.*;

@Data
public class UserRegistration {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 20)
    private String username;
    
    @Email(message = "Email should be valid")
    @NotBlank
    private String email;
    
    @NotNull
    @Min(18)
    private Integer age;
}
```

## Memory Visualization: Lombok vs Traditional Code

```
┌─────────────────────────────────────────────────┐
│     Code Size Comparison                        │
├─────────────────────────────────────────────────┤
│                                                 │
│  Traditional Java Class:                        │
│  ████████████████████████████████████ 120 lines│
│                                                 │
│  With Lombok:                                   │
│  ████ 15 lines                                  │
│                                                 │
│  Reduction: 87.5% less code!                    │
└─────────────────────────────────────────────────┘

Benefits:
✅ Less code to write
✅ Less code to maintain
✅ Fewer bugs in boilerplate
✅ Better readability
✅ Faster development
```

----------

# Integrated Example: All Tools Together

Let's build a simple REST API using all four tools:

## Project Structure

```
my-api-project/
├── pom.xml                    (Maven)
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/
│   │   │       ├── model/
│   │   │       │   └── User.java        (Lombok)
│   │   │       ├── repository/
│   │   │       │   └── UserRepository.java
│   │   │       ├── service/
│   │   │       │   └── UserService.java (Logging)
│   │   │       └── controller/
│   │   │           └── UserController.java
│   │   └── resources/
│   │       └── logback.xml              (Logging config)
│   └── test/
└── target/
```

## Complete Example Code

### 1. pom.xml (Maven)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>user-api</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.5</version>
    </parent>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>
        
        <!-- Logging (included in spring-boot-starter-web) -->
        <!-- Uses SLF4J + Logback by default -->
        
        <!-- Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2. User.java (Model with Lombok)

java

```java
package com.example.model;

import lombok.*;
import javax.validation.constraints.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    private Long id;
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50)
    private String name;
    
    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    private String email;
    
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must be less than 120")
    private Integer age;
    
    @Builder.Default
    private LocalDateTime createdAt = LocalDateTime.now();
    
    @Builder.Default
    private boolean active = true;
}
```

### 3. UserService.java (Business Logic with Logging)

java

```java
package com.example.service;

import com.example.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@Slf4j
@Service
public class UserService {
    
    private final Map<Long, User> userDatabase = new ConcurrentHashMap<>();
    private final AtomicLong idGenerator = new AtomicLong(1);
    
    public User createUser(User user) {
        log.info("Creating new user with email: {}", user.getEmail());
        
        // Check if email already exists
        boolean emailExists = userDatabase.values().stream()
            .anyMatch(u -> u.getEmail().equals(user.getEmail()));
        
        if (emailExists) {
            log.warn("User creation failed: Email {} already exists", user.getEmail());
            throw new IllegalArgumentException("Email already exists");
        }
        
        Long id = idGenerator.getAndIncrement();
        user.setId(id);
        userDatabase.put(id, user);
        
        log.info("User created successfully with ID: {}", id);
        log.debug("User details: {}", user);
        
        return user;
    }
    
    public Optional<User> getUserById(Long id) {
        log.debug("Fetching user with ID: {}", id);
        
        User user = userDatabase.get(id);
        if (user == null) {
            log.warn("User not found with ID: {}", id);
        }
        
        return Optional.ofNullable(user);
    }
    
    public List<User> getAllUsers() {
        log.info("Fetching all users. Total count: {}", userDatabase.size());
        return new ArrayList<>(userDatabase.values());
    }
    
    public User updateUser(Long id, User updatedUser) {
        log.info("Updating user with ID: {}", id);
        
        User existingUser = userDatabase.get(id);
        if (existingUser == null) {
            log.error("Update failed: User not found with ID: {}", id);
            throw new NoSuchElementException("User not found");
        }
        
        existingUser.setName(updatedUser.getName());
        existingUser.setEmail(updatedUser.getEmail());
        existingUser.setAge(updatedUser.getAge());
        
        log.info("User updated successfully: {}", id);
        return existingUser;
    }
    
    public void deleteUser(Long id) {
        log.info("Deleting user with ID: {}", id);
        
        User removed = userDatabase.remove(id);
        if (removed == null) {
            log.error("Delete failed: User not found with ID: {}", id);
            throw new NoSuchElementException("User not found");
        }
        
        log.info("User deleted successfully: {}", id);
    }
}
```

### 4. UserController.java (REST API)

java

```java
package com.example.controller;

import com.example.model.User;
import com.example.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Validated
public class UserController {
    
    private final UserService userService;
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
        log.info("POST /api/users - Creating user");
        User createdUser = userService.createUser(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        log.info("GET /api/users/{} - Fetching user", id);
        return userService.getUserById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        log.info("GET /api/users - Fetching all users");
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody User user) {
        log.info("PUT /api/users/{} - Updating user", id);
        User updatedUser = userService.updateUser(id, user);
        return ResponseEntity.ok(updatedUser);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        log.info("DELETE /api/users/{} - Deleting user", id);
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgument(IllegalArgumentException e) {
        log.error("Validation error: {}", e.getMessage());
        return ResponseEntity.badRequest().body(e.getMessage());
    }
    
    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<String> handleNotFound(NoSuchElementException e) {
        log.error("Not found: {}", e.getMessage());
        return ResponseEntity.notFound().build();
    }
}
```

### 5. logback.xml (Logging Configuration)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/user-api.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/user-api.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
    
    <logger name="com.example" level="DEBUG" />
    
</configuration>
```

## Testing with Postman

### Step 1: Create User (POST)

```
POST http://localhost:8080/api/users
Content-Type: application/json

Body:
{
  "name": "John Doe",
  "email": "john@example.com",
  "age": 25
}

Response (201 Created):
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "age": 25,
  "createdAt": "2025-10-26T15:30:00",
  "active": true
}
```

### Step 2: Get User by ID (GET)

```
GET http://localhost:8080/api/users/1

Response (200 OK):
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "age": 25,
  "createdAt": "2025-10-26T15:30:00",
  "active": true
}
```

### Step 3: Get All Users (GET)

```
GET http://localhost:8080/api/users

Response (200 OK):
[
  {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com",
    "age": 25,
    "createdAt": "2025-10-26T15:30:00",
    "active": true
  }
]
```

### Step 4: Update User (PUT)

```
PUT http://localhost:8080/api/users/1
Content-Type: application/json

Body:
{
  "name": "John Smith",
  "email": "john.smith@example.com",
  "age": 26
}

Response (200 OK):
{
  "id": 1,
  "name": "John Smith",
  "email": "john.smith@example.com",
  "age": 26,
  "createdAt": "2025-10-26T15:30:00",
  "active": true
}
```

### Step 5: Delete User (DELETE)

```
DELETE http://localhost:8080/api/users/1

Response (204 No Content)
```

----------

# Quick Reference Cheat Sheet

## Maven Commands

bash

```bash
mvn clean          # Clean target folder
mvn compile        # Compile source code
mvn test           # Run tests
mvn package        # Create JAR/WAR
mvn install        # Install to local repo
mvn clean install  # Clean and install
```

## Logging Levels (Priority Order)

```
TRACE < DEBUG < INFO < WARN < ERROR < FATAL
```

## HTTP Status Codes

```
200 OK              # Success
201 Created         # Resource created
204 No Content      # Success, no body
400 Bad Request     # Invalid data
401 Unauthorized    # Not authenticated
404 Not Found       # Resource doesn't exist
500 Server Error    # Internal error
```

## Lombok Annotations

java

```java
@Getter @Setter     // Generate getters/setters
@ToString           // Generate toString()
@EqualsAndHashCode  // Generate equals() and hashCode()
@Data               // All of the above
@Builder            // Builder pattern
@Slf4j              // Logger instance
@Value              // Immutable class
@NonNull            // Null checks
```

----------

# Summary

## Maven

-   **Purpose**: Build automation and dependency management
-   **Key File**: pom.xml
-   **Think of it as**: A construction project manager

## Logging

-   **Purpose**: Track application behavior and debug issues
-   **Key Libraries**: SLF4J (API) + Logback (Implementation)
-   **Think of it as**: A flight recorder (black box)

## Postman

-   **Purpose**: Test and document APIs
-   **Key Concept**: HTTP requests/responses
-   **Think of it as**: A mail delivery service tester

## Lombok

-   **Purpose**: Reduce boilerplate code
-   **Key Annotations**: @Data, @Builder, @Slf4j
-   **Think of it as**: A smart coding assistant

----------
