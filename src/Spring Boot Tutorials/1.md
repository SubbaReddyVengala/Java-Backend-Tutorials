
# Spring Boot Core Module - Complete Tutorial

## Table of Contents

1.  Introduction to Spring Boot
2.  Creating Spring Boot Applications
3.  Spring Boot Starters
4.  Core Annotations
5.  Auto-Configuration
6.  Runners

----------

## 1. Introduction to Spring Boot 
### What is Spring Boot?

**Analogy**: Think of Spring Boot as a **pre-furnished apartment** versus traditional Spring as an **empty apartment**.

-   **Traditional Spring**: You get an empty space and must bring your own furniture (configurations), arrange everything (XML/Java config), connect utilities (dependencies), etc.
-   **Spring Boot**: You get a move-in-ready apartment with furniture already placed, utilities connected, and sensible defaults set up.

### Why Spring Boot?

**Problems it solves:**

1.  **Dependency Management Hell** → Starter POMs
2.  **XML Configuration Overload** → Auto-configuration
3.  **Server Deployment Complexity** → Embedded servers
4.  **Manual Setup Time** → Convention over configuration

### Memory Visualization

```
┌─────────────────────────────────────────┐
│     TRADITIONAL SPRING APPLICATION      │
├─────────────────────────────────────────┤
│  ├─ web.xml (100+ lines)                │
│  ├─ applicationContext.xml (200+ lines) │
│  ├─ dispatcher-servlet.xml              │
│  ├─ Manual dependency versions          │
│  ├─ External Tomcat setup                │
│  └─ Component scanning config            │
│                                          │
│  Time to Setup: 2-3 hours               │
└─────────────────────────────────────────┘
                    ↓
         Spring Boot Magic ✨
                    ↓
┌─────────────────────────────────────────┐
│      SPRING BOOT APPLICATION            │
├─────────────────────────────────────────┤
│  ├─ @SpringBootApplication (1 line)     │
│  ├─ application.properties (optional)   │
│  ├─ pom.xml with starters               │
│  └─ Embedded server (auto-configured)   │
│                                          │
│  Time to Setup: 5 minutes               │
└─────────────────────────────────────────┘
```

----------

## 2. Creating Spring Boot Applications 
### Method 1: Spring Initializer (start.spring.io)

**Analogy**: Like using a **restaurant menu ordering system** where you select ingredients (dependencies), and the kitchen (Spring Initializer) prepares your base project.

**Steps:**

1.  Visit [https://start.spring.io](https://start.spring.io)
2.  Choose Project: Maven/Gradle
3.  Select Language: Java
4.  Choose Spring Boot version
5.  Add dependencies (starters)
6.  Generate and download

**Visual Flow:**

```
User Interface (start.spring.io)
         ↓
[Project Metadata Input]
  - Group: com.example
  - Artifact: demo
  - Dependencies: Web, JPA, DevTools
         ↓
[Generate Button Click]
         ↓
[ZIP File Downloaded]
  ├─ src/main/java
  │   └─ DemoApplication.java
  ├─ src/main/resources
  │   └─ application.properties
  ├─ pom.xml (pre-configured)
  └─ README.md
```

### Method 2: Spring Starter Wizard in STS/IntelliJ

**STS (Spring Tool Suite) Steps:**

```
File → New → Spring Starter Project
         ↓
[Wizard Opens - Same as Web Interface]
  - Fill project details
  - Select dependencies
  - Click Finish
         ↓
[Project created in workspace]
```

**Advantage**: Direct integration with IDE, no download/import needed.

### Method 3: Maven Approach (Manual)

**Step 1**: Create Maven project structure

```
my-app/
├─ src/
│  ├─ main/
│  │  ├─ java/
│  │  └─ resources/
│  └─ test/
└─ pom.xml
```

**Step 2**: Configure pom.xml (shown in examples below)

----------

## 3. Spring Boot Starters 

### Understanding Starters

**Analogy**: Starters are like **combo meals at a fast-food restaurant**.

-   Instead of ordering burger + fries + drink separately (individual dependencies)
-   You order "Combo #1" (starter) and get everything together
-   All items are compatible and tested together

### Visualization: Starter Dependency Tree

```
spring-boot-starter-web
         │
         ├─→ spring-boot-starter
         │        ├─→ spring-boot
         │        ├─→ spring-boot-autoconfigure
         │        ├─→ spring-boot-starter-logging
         │        └─→ spring-core
         │
         ├─→ spring-boot-starter-tomcat (Embedded Server)
         │        ├─→ tomcat-embed-core
         │        ├─→ tomcat-embed-el
         │        └─→ tomcat-embed-websocket
         │
         ├─→ spring-web
         ├─→ spring-webmvc
         └─→ jackson-databind (JSON processing)
```

----------

### A. Spring Boot Parent Starter

**Purpose**: Provides dependency management and default configurations.

**Analogy**: Like a **family inheritance** - children inherit properties/characteristics from parent without explicitly defining them.

**pom.xml Configuration:**

xml

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.2.0</version>
    <relativePath/>
</parent>
```

**What it provides:**

```
spring-boot-starter-parent
    ↓
Inherits from spring-boot-dependencies
    ↓
Provides:
├─ Java version (17/21)
├─ UTF-8 encoding
├─ Dependency versions (200+ libraries)
├─ Maven plugins configuration
├─ Resource filtering
└─ Plugin management
```

**Memory Layout:**

```
┌───────────────────────────────────────┐
│    YOUR APPLICATION POM.XML           │
├───────────────────────────────────────┤
│  <parent>                             │
│    spring-boot-starter-parent         │
│  </parent>                            │
│         ↓ (inherits)                  │
│  ┌─────────────────────────────────┐ │
│  │ Version Management              │ │
│  │  - Spring: 6.1.0                │ │
│  │  - Hibernate: 6.3.1             │ │
│  │  - Jackson: 2.15.3              │ │
│  │  - Tomcat: 10.1.15              │ │
│  │  (No need to specify versions!) │ │
│  └─────────────────────────────────┘ │
└───────────────────────────────────────┘
```

----------

### B. spring-boot-starter

**Purpose**: Core starter - Foundation for all Spring Boot applications.

**Analogy**: Like the **engine of a car** - you don't see it directly, but everything depends on it.

**Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
</dependency>
```

**What's included:**

```
spring-boot-starter
    ├─ spring-boot (Core classes)
    ├─ spring-boot-autoconfigure (Magic!)
    ├─ spring-boot-starter-logging
    │   ├─ Logback (default)
    │   ├─ SLF4J
    │   └─ Log4j-to-slf4j bridge
    ├─ spring-core
    ├─ spring-context
    └─ snakeyaml (YAML support)
```

**Example Usage:**

java

```java
// This starter is automatically included in other starters
// You rarely add it explicitly
```

----------

### C. spring-boot-starter-web

**Purpose**: Build web applications, REST APIs, MVC applications.

**Analogy**: Like a **complete kitchen setup** for a restaurant - includes stove (server), utensils (HTTP handling), ingredients (JSON processing).

**Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

**Complete Example:**

**pom.xml:**

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>web-demo</artifactId>
    <version>1.0.0</version>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
</project>
```

**Application Class:**

java

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(WebDemoApplication.class, args);
    }
}
```

**REST Controller:**

java

```java
package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class HelloController {
    
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, Spring Boot!";
    }
    
    @GetMapping("/greet/{name}")
    public String greet(@PathVariable String name) {
        return "Hello, " + name + "!";
    }
    
    @PostMapping("/user")
    public User createUser(@RequestBody User user) {
        return user; // Auto-converted to JSON
    }
}

class User {
    private String name;
    private String email;
    
    // Constructors, getters, setters
}
```

**What happens automatically:**

```
Application Startup
    ↓
[Embedded Tomcat starts on port 8080]
    ↓
[DispatcherServlet auto-configured]
    ↓
[JSON converter (Jackson) configured]
    ↓
[Error handling configured]
    ↓
Application Ready!

Test: http://localhost:8080/api/hello
```

----------

### D. spring-boot-starter-data-jpa

**Purpose**: Database operations with JPA/Hibernate.

**Analogy**: Like hiring a **professional translator** between your Java code and database - you speak Java, database speaks SQL, JPA translates.

**Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

**Memory Flow:**

```
Java Object (Entity)
    ↓
JPA/Hibernate (ORM Layer)
    ↓
JDBC
    ↓
Database
```

**Complete Example:**

**Entity Class:**

java

```java
package com.example.demo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "students")
public class Student {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    private Integer age;
    
    // Constructors
    public Student() {}
    
    public Student(String name, String email, Integer age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
}
```

**Repository Interface:**

java

```java
package com.example.demo.repository;

import com.example.demo.entity.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Custom query methods (no implementation needed!)
    List<Student> findByName(String name);
    
    List<Student> findByAgeGreaterThan(Integer age);
    
    Student findByEmail(String email);
}
```

**Service Layer:**

java

```java
package com.example.demo.service;

import com.example.demo.entity.Student;
import com.example.demo.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class StudentService {
    
    @Autowired
    private StudentRepository repository;
    
    public Student saveStudent(Student student) {
        return repository.save(student);
    }
    
    public List<Student> getAllStudents() {
        return repository.findAll();
    }
    
    public Student getStudentById(Long id) {
        return repository.findById(id).orElse(null);
    }
    
    public void deleteStudent(Long id) {
        repository.deleteById(id);
    }
}
```

**application.properties:**

properties

```properties
# H2 Database Configuration
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA Configuration
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# H2 Console (for testing)
spring.h2.console.enabled=true
```

**Auto-Configuration Visualization:**

```
spring-boot-starter-data-jpa detected
         ↓
Auto-configures:
├─ DataSource (connection pool)
├─ EntityManagerFactory
├─ TransactionManager
├─ JPA repositories
└─ Hibernate properties

You just write:
├─ Entity classes
├─ Repository interfaces
└─ Configuration properties
```

----------

### E. spring-boot-devtools

**Purpose**: Developer productivity tools - hot reload, automatic restart.

**Analogy**: Like having a **personal assistant** who automatically refreshes your work when you make changes - no manual restarts needed.

**Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

**Features:**

```
┌────────────────────────────────────┐
│     DEVTOOLS FEATURES              │
├────────────────────────────────────┤
│ 1. Automatic Restart               │
│    - Watches classpath changes     │
│    - Fast restart (not full JVM)   │
│                                    │
│ 2. LiveReload                      │
│    - Auto-refresh browser          │
│    - No manual F5 needed           │
│                                    │
│ 3. Property Defaults               │
│    - Caching disabled in dev       │
│    - Template caching off          │
│                                    │
│ 4. H2 Console Auto-enabled         │
│                                    │
│ 5. Enhanced Logging                │
└────────────────────────────────────┘
```

**How it works:**

```
1. You modify Java file
         ↓
2. IDE auto-compiles (Ctrl+S or Auto-save)
         ↓
3. DevTools detects .class file change
         ↓
4. Restarts only application context
   (not entire JVM - FAST!)
         ↓
5. Application ready in 2-3 seconds
```

**Example Scenario:**

**Before DevTools:**

```
1. Modify HelloController.java
2. Stop application (manual)
3. Wait for graceful shutdown (5s)
4. Start application (manual)
5. Wait for full startup (20s)
6. Test change
Total: ~25 seconds per change
```

**With DevTools:**

```
1. Modify HelloController.java
2. Save file (Ctrl+S)
3. Auto-restart happens
4. Ready in 2-3 seconds
Total: ~3 seconds per change
```

**Configuration (application.properties):**

properties

```properties
# DevTools is enabled by default in development

# Customize if needed:
spring.devtools.restart.enabled=true
spring.devtools.livereload.enabled=true

# Exclude certain paths from triggering restart
spring.devtools.restart.exclude=static/**,public/**

# Additional paths to watch
spring.devtools.restart.additional-paths=src/main/resources
```

----------

### F. spring-boot-actuator

**Purpose**: Production-ready features - health checks, metrics, monitoring.

**Analogy**: Like the **dashboard in a car** - shows you engine temperature, fuel level, speed, warnings, etc. Actuator shows your application's health.

**Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Built-in Endpoints:**

```
┌─────────────────────────────────────────┐
│      ACTUATOR ENDPOINTS                 │
├─────────────────────────────────────────┤
│ /actuator/health                        │
│   → Is application healthy?             │
│                                         │
│ /actuator/info                          │
│   → Application metadata                │
│                                         │
│ /actuator/metrics                       │
│   → JVM memory, CPU, HTTP requests      │
│                                         │
│ /actuator/env                           │
│   → Environment properties              │
│                                         │
│ /actuator/loggers                       │
│   → View/modify log levels              │
│                                         │
│ /actuator/beans                         │
│   → All Spring beans in context         │
│                                         │
│ /actuator/mappings                      │
│   → All @RequestMapping endpoints       │
└─────────────────────────────────────────┘
```

**Configuration Example:**

**application.properties:**

properties

```properties
# Expose all endpoints (careful in production!)
management.endpoints.web.exposure.include=*

# Or expose specific endpoints
management.endpoints.web.exposure.include=health,info,metrics

# Base path (default: /actuator)
management.endpoints.web.base-path=/manage

# Health endpoint details
management.endpoint.health.show-details=always

# Custom application info
info.app.name=My Spring Boot App
info.app.version=1.0.0
info.app.description=Demo application
```

**Custom Health Indicator:**

java

```java
package com.example.demo.health;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        // Check custom health condition
        boolean databaseConnected = checkDatabase();
        
        if (databaseConnected) {
            return Health.up()
                    .withDetail("database", "Connected")
                    .withDetail("timestamp", System.currentTimeMillis())
                    .build();
        } else {
            return Health.down()
                    .withDetail("database", "Disconnected")
                    .withDetail("error", "Cannot reach database")
                    .build();
        }
    }
    
    private boolean checkDatabase() {
        // Your database check logic
        return true;
    }
}
```

**Response Examples:**

**GET /actuator/health:**

json

```json
{
  "status": "UP",
  "components": {
    "custom": {
      "status": "UP",
      "details": {
        "database": "Connected",
        "timestamp": 1234567890
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 500000000000,
        "free": 300000000000,
        "threshold": 10485760
      }
    }
  }
}
```

**GET /actuator/metrics/jvm.memory.used:**

json

```json
{
  "name": "jvm.memory.used",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 156789120
    }
  ],
  "availableTags": [
    {
      "tag": "area",
      "values": ["heap", "nonheap"]
    }
  ]
}
```

----------

## 4. Core Annotations and Bootstrapping 

### @SpringBootApplication Annotation

**Analogy**: Like a **Swiss Army knife** - one tool that combines multiple functions.

**Breakdown:**

java

```java
@SpringBootApplication
    = @SpringBootConfiguration
    + @EnableAutoConfiguration
    + @ComponentScan
```

**Visual Representation:**

```
@SpringBootApplication
    │
    ├─→ @SpringBootConfiguration
    │     (Marks class as configuration source)
    │     Equivalent to @Configuration
    │
    ├─→ @EnableAutoConfiguration
    │     (Enables Spring Boot's auto-magic)
    │     Scans classpath and auto-configures beans
    │
    └─→ @ComponentScan
          (Scans current package and sub-packages)
          Finds @Component, @Service, @Repository, @Controller
```

**Example:**

java

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// This one annotation does it all!
@SpringBootApplication
public class DemoApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**Equivalent Long Form:**

java

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootConfiguration;
import org.springframework.context.annotation.ComponentScan;

@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(basePackages = "com.example.demo")
public class DemoApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**Customizing Component Scan:**

java

```java
@SpringBootApplication(
    scanBasePackages = {"com.example.demo", "com.external.lib"}
)
public class DemoApplication {
    // ...
}

// Or exclude specific auto-configurations
@SpringBootApplication(
    exclude = {DataSourceAutoConfiguration.class}
)
public class DemoApplication {
    // ...
}
```

----------

### SpringApplication.run() Method

**Analogy**: Like the **ignition key** in a car - starts the entire engine (Spring context).

**Method Signature:**

java

```java
public static ConfigurableApplicationContext run(
    Class<?> primarySource, 
    String... args
)
```

**What happens inside (simplified):**

```
SpringApplication.run(DemoApplication.class, args)
         ↓
┌─────────────────────────────────────────┐
│  STEP 1: Create SpringApplication      │
│  - Set primary source (main class)      │
│  - Detect web application type          │
│  - Load ApplicationContext initializers │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│  STEP 2: Prepare Environment            │
│  - Load application.properties          │
│  - Process command-line arguments        │
│  - Set active profiles                   │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│  STEP 3: Create ApplicationContext      │
│  - Choose context type (Servlet/Reactive)│
│  - Register bean definitions            │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│  STEP 4: Refresh Context                │
│  - Instantiate beans                     │
│  - Inject dependencies                   │
│  - Call @PostConstruct methods           │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│  STEP 5: Run Runners                    │
│  - Execute ApplicationRunner             │
│  - Execute CommandLineRunner             │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│  STEP 6: Start Server (if web app)      │
│  - Start embedded Tomcat                │
│  - Application ready!                    │
└─────────────────────────────────────────┘
```

**Customizing SpringApplication:**

java

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.Banner;

@SpringBootApplication
public class DemoApplication {
    
    public static void main(String[] args) {
        // Method 1: Simple (most common)
        SpringApplication.run(DemoApplication.class, args);
        
        // Method 2: Customized
        SpringApplication app = new SpringApplication(DemoApplication.class);
        
        // Disable banner
        app.setBannerMode(Banner.Mode.OFF);
        
        // Set additional profiles
        app.setAdditionalProfiles("dev", "debug");
        
        // Add listeners
        app.addListeners(event -> {
            System.out.println("Event: " + event.getClass().getSimpleName());
        });
        
        // Run the application
        app.run(args);
    }
}
```

**Accessing ApplicationContext:**

java

```java
@SpringBootApplication
public class DemoApplication {
    
    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(DemoApplication.class, args);
        
        // Get beans from context
        MyService service = context.getBean(MyService.class);
        service.doSomething();
        
        // Get environment properties
        String appName = context.getEnvironment()
            .getProperty("spring.application.name");
        
        System.out.println("Application: " + appName);
        
        // Close context (usually automatic)
        // context.close();
    }
}
```

----------

## 5. Auto-Configuration 

### Understanding Auto-Configuration

**Analogy**: Imagine a **smart home system** that automatically:

-   Turns on lights when you enter (detects presence)
-   Adjusts temperature based on weather (environmental awareness)
-   Orders groceries when fridge is empty (dependency management)

Spring Boot Auto-Configuration does similar magic for your application.

**How it works:**

```
Application Starts
         ↓
Spring Boot scans classpath
         ↓
┌─────────────────────────────────────────┐
│  CONDITIONAL CHECKS                     │
├─────────────────────────────────────────┤
│  Is spring-web jar present?             │
│  → YES: Configure DispatcherServlet     │
│                                         │
│  Is H2 database jar present?            │
│  → YES: Configure DataSource            │
│                                         │
│  Is Thymeleaf jar present?              │
│  → YES: Configure TemplateEngine        │
│                                         │
│  Is user-defined DataSource bean?       │
│  → YES: Skip auto-config DataSource     │
└─────────────────────────────────────────┘
```

**Key Auto-Configuration Classes:**

```
spring-boot-autoconfigure.jar
    ├─ DataSourceAutoConfiguration
    ├─ WebMvcAutoConfiguration
    ├─ JpaRepositoriesAutoConfiguration
    ├─ ThymeleafAutoConfiguration
    ├─ SecurityAutoConfiguration
    └─ ... 100+ more
```

**Conditional Annotations:**

java

```java
// Pseudo-code showing how auto-config works

@Configuration
@ConditionalOnClass(DataSource.class)  // Only if class exists
@ConditionalOnMissingBean(DataSource.class)  // User didn't define
public class DataSourceAutoConfiguration {
    
    @Bean
    public DataSource dataSource() {
        // Create and configure DataSource
        return new HikariDataSource();
    }
}
```

**Real Example - Custom Auto-Configuration:**

**1. Create Configuration Class:**

java

```java
package com.example.demo.config;

import org.springframework.boot.autoconfigure.condition.*;
import org.springframework.context.annotation.*;

@Configuration
@ConditionalOnClass(MyCustomService.class)
@ConditionalOnProperty(
    name = "myapp.service.enabled",
    havingValue = "true",
    matchIfMissing = true
)
public class MyCustomAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public MyCustomService myCustomService() {
        return new MyCustomService();
    }
}
```

**2. Service Class:**

java

```java
package com.example.demo.service;

public class MyCustomService {
    public void execute() {
        System.out.println("Custom service executing!");
    }
}
```

**3. Register Auto-Configuration:**

Create file: `src/main/resources/META-INF/spring.factories`

properties

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.demo.config.MyCustomAutoConfiguration
```

**Debugging Auto-Configuration:**

**application.properties:**

properties

```properties
# Show auto-configuration report
debug=true

# Or via command line
# java -jar app.jar --debug
```

**Output shows:**

```
============================
CONDITIONS EVALUATION REPORT
============================

Positive matches: (Auto-configurations ENABLED)
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required classes
      
   WebMvcAutoConfiguration matched:
      - @ConditionalOnClass found required classes
      - @ConditionalOnWebApplication matched

Negative matches: (Auto-configurations DISABLED)
-----------------
   SecurityAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class
         
   MongoAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class
```

**Disabling Specific Auto-Configurations:**

java

```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    HibernateJpaAutoConfiguration.class
})
public class DemoApplication {
    // Application will not auto-configure DataSource and JPA
}
```

**Memory Visualization of Auto-Configuration:**

```
┌────────────────────────────────────────────┐
│         CLASSPATH                          │
├────────────────────────────────────────────┤
│  ✓ spring-boot-starter-web.jar            │
│  ✓ spring-boot-starter-data-jpa.jar       │
│  ✓ h2.jar                                  │
│  ✗ spring-boot-starter-security.jar       │
└────────────────────────────────────────────┘
                    ↓
      @EnableAutoConfiguration scans
                    ↓
┌────────────────────────────────────────────┐
│     AUTO-CONFIGURED BEANS                  │
├────────────────────────────────────────────┤
│  ✓ DispatcherServlet (web jar found)      │
│  ✓ DataSource (h2 jar found)              │
│  ✓ EntityManagerFactory (jpa jar found)   │
│  ✗ SecurityFilterChain (security not found)│
└────────────────────────────────────────────┘
```

----------

## 6. Runners in Spring Boot 

### Understanding Runners

**Analogy**: Runners are like **initialization scripts** that run after your car engine starts but before you start driving. They perform setup tasks like:

-   Loading data into memory
-   Checking system status
-   Printing startup information

**When Runners Execute:**

```
Application Startup Sequence:
    ↓
1. SpringApplication.run() called
    ↓
2. ApplicationContext created
    ↓
3. All beans instantiated
    ↓
4. Server started (for web apps)
    ↓
5. ✨ RUNNERS EXECUTE HERE ✨
    ↓
6. Application ready to serve requests
```

### Two Types of Runners

```
┌─────────────────────────────────────────┐
│         ApplicationRunner               │
├─────────────────────────────────────────┤
│ • Receives ApplicationArguments         │
│ • Structured access to arguments        │
│ • Can distinguish option args           │
│ • Example: --name=John --age=25         │
│   args.getOptionValues("name") → [John] │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│         CommandLineRunner               │
├─────────────────────────────────────────┤
│ • Receives raw String array             │
│ • Simple string arguments               │
│ • Direct access to args                 │
│ • Example: arg1 arg2 arg3               │
│   args[0] → "arg1"                      │
└─────────────────────────────────────────┘
```

----------

### A. ApplicationRunner

**Purpose**: Execute code with structured access to application arguments.

**Interface:**

java

```java
@FunctionalInterface
public interface ApplicationRunner {
    void run(ApplicationArguments args) throws Exception;
}
```

**Complete Example 1: Database Initialization**

java

```java
package com.example.demo.runner;

import com.example.demo.entity.Student;
import com.example.demo.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(1)  // Executes first (lower number = higher priority)
public class DataInitializerRunner implements ApplicationRunner {
    
    @Autowired
    private StudentRepository studentRepository;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=== DataInitializerRunner Executing ===");
        
        // Check if data already exists
        if (studentRepository.count() == 0) {
            System.out.println("Initializing database with sample data...");
            
            // Create sample students
            Student s1 = new Student("Alice Johnson", "alice@example.com", 20);
            Student s2 = new Student("Bob Smith", "bob@example.com", 22);
            Student s3 = new Student("Charlie Brown", "charlie@example.com", 21);
            
            studentRepository.save(s1);
            studentRepository.save(s2);
            studentRepository.save(s3);
            
            System.out.println("✓ Sample data loaded: " + studentRepository.count() + " students");
        } else {
            System.out.println("Database already contains data. Skipping initialization.");
        }
        
        // Access command-line arguments
        if (args.containsOption("debug")) {
            System.out.println("Debug mode enabled");
            System.out.println("All students: " + studentRepository.findAll());
        }
        
        System.out.println("=== DataInitializerRunner Complete ===\n");
    }
}
```

**Complete Example 2: Configuration Validator**

java

```java
package com.example.demo.runner;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(2)  // Executes second
public class ConfigValidatorRunner implements ApplicationRunner {
    
    @Value("${app.name:MyApp}")
    private String appName;
    
    @Value("${app.version:1.0}")
    private String appVersion;
    
    @Value("${server.port:8080}")
    private String serverPort;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=== ConfigValidatorRunner Executing ===");
        
        // Display application information
        System.out.println("Application Name: " + appName);
        System.out.println("Application Version: " + appVersion);
        System.out.println("Server Port: " + serverPort);
        
        // Parse command-line arguments
        System.out.println("\nCommand-Line Arguments Analysis:");
        System.out.println("  Total arguments: " + args.getSourceArgs().length);
        
        // Option arguments (--key=value or --key)
        System.out.println("  Option names: " + args.getOptionNames());
        for (String optionName : args.getOptionNames()) {
            System.out.println("    --" + optionName + " = " + 
                args.getOptionValues(optionName));
        }
        
        // Non-option arguments (plain values)
        System.out.println("  Non-option args: " + args.getNonOptionArgs());
        
        // Check for specific options
        if (args.containsOption("env")) {
            String env = args.getOptionValues("env").get(0);
            System.out.println("\n✓ Running in environment: " + env);
        }
        
        if (args.containsOption("maintenance")) {
            System.out.println("\n⚠ MAINTENANCE MODE ENABLED");
        }
        
        System.out.println("=== ConfigValidatorRunner Complete ===\n");
    }
}
```

**Running with arguments:**

bash

```bash
# Run with various arguments
java -jar myapp.jar --env=production --debug --name=John arg1 arg2

# Output will show:
# Option names: [env, debug, name]
# --env = [production]
# --debug = []
# --name = [John]
# Non-option args: [arg1, arg2]
```

----------

### B. CommandLineRunner

**Purpose**: Execute code with raw access to command-line arguments (simpler than ApplicationRunner).

**Interface:**

java

```java
@FunctionalInterface
public interface CommandLineRunner {
    void run(String... args) throws Exception;
}
```

**Complete Example 1: System Health Check**

java

```java
package com.example.demo.runner;

import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.RuntimeMXBean;

@Component
@Order(3)  // Executes third
public class SystemHealthCheckRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("=== SystemHealthCheckRunner Executing ===");
        
        // Get system information
        RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        
        System.out.println("\nSystem Information:");
        System.out.println("  JVM Name: " + runtimeBean.getVmName());
        System.out.println("  JVM Version: " + runtimeBean.getVmVersion());
        System.out.println("  Java Version: " + System.getProperty("java.version"));
        System.out.println("  OS: " + System.getProperty("os.name") + " " + 
            System.getProperty("os.version"));
        
        // Memory information
        long heapMemory = memoryBean.getHeapMemoryUsage().getUsed() / (1024 * 1024);
        long maxHeapMemory = memoryBean.getHeapMemoryUsage().getMax() / (1024 * 1024);
        
        System.out.println("\nMemory Status:");
        System.out.println("  Heap Memory Used: " + heapMemory + " MB");
        System.out.println("  Max Heap Memory: " + maxHeapMemory + " MB");
        
        // Raw arguments
        System.out.println("\nRaw Command-Line Arguments: " + args.length);
        for (int i = 0; i < args.length; i++) {
            System.out.println("  args[" + i + "] = " + args[i]);
        }
        
        System.out.println("\n✓ System health check complete");
        System.out.println("=== SystemHealthCheckRunner Complete ===\n");
    }
}
```

**Complete Example 2: Welcome Banner**

java

```java
package com.example.demo.runner;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
@Order(4)  // Executes last
public class WelcomeBannerRunner implements CommandLineRunner {
    
    @Value("${app.name:Spring Boot Application}")
    private String appName;
    
    @Value("${app.version:1.0.0}")
    private String appVersion;
    
    @Override
    public void run(String... args) throws Exception {
        String banner = generateBanner();
        System.out.println(banner);
    }
    
    private String generateBanner() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(formatter);
        
        StringBuilder sb = new StringBuilder();
        sb.append("\n");
        sb.append("╔════════════════════════════════════════════════════════╗\n");
        sb.append("║                                                        ║\n");
        sb.append("║           🚀 APPLICATION STARTED SUCCESSFULLY 🚀        ║\n");
        sb.append("║                                                        ║\n");
        sb.append("╠════════════════════════════════════════════════════════╣\n");
        sb.append(String.format("║  Application: %-40s ║\n", appName));
        sb.append(String.format("║  Version:     %-40s ║\n", appVersion));
        sb.append(String.format("║  Started:     %-40s ║\n", timestamp));
        sb.append("║                                                        ║\n");
        sb.append("║  All runners completed successfully!                  ║\n");
        sb.append("║  Application is ready to accept requests.             ║\n");
        sb.append("║                                                        ║\n");
        sb.append("╚════════════════════════════════════════════════════════╝\n");
        sb.append("\n");
        
        return sb.toString();
    }
}
```

----------

### Runner Execution Order Visualization

```
Application Startup Timeline:
════════════════════════════════════════════════

t=0s    Application main() method called
        │
t=2s    Spring context loading
        ├─ Bean definitions scanned
        ├─ Auto-configuration applied
        └─ Beans instantiated
        │
t=4s    Embedded server started (Tomcat/Jetty)
        │
t=5s    ┌─────────────────────────────────┐
        │  RUNNERS EXECUTE IN ORDER       │
        ├─────────────────────────────────┤
        │  @Order(1) → DataInitializer    │
        │  @Order(2) → ConfigValidator    │
        │  @Order(3) → HealthCheck        │
        │  @Order(4) → WelcomeBanner      │
        └─────────────────────────────────┘
        │
t=6s    ✓ Application ready!
        │
        Ready to serve HTTP requests
        
════════════════════════════════════════════════
```

**Multiple Runners in One Class:**

java

```java
package com.example.demo.runner;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class MultiRunner implements ApplicationRunner, CommandLineRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("ApplicationRunner executed");
        System.out.println("Option args: " + args.getOptionNames());
    }
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("CommandLineRunner executed");
        System.out.println("Raw args length: " + args.length);
    }
}
```

**Conditional Runner (Only in specific profiles):**

java

```java
package com.example.demo.runner;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("dev")  // Only runs in 'dev' profile
public class DevDataLoader implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("Loading development data...");
        // Load test data for development
    }
}
```

**Runner with Exception Handling:**

java

```java
package com.example.demo.runner;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class SafeRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        try {
            // Risky operation
            performStartupTask();
            System.out.println("✓ Startup task completed successfully");
        } catch (Exception e) {
            System.err.println("✗ Startup task failed: " + e.getMessage());
            // Don't throw - let application continue
            // Or throw to prevent startup if critical
        }
    }
    
    private void performStartupTask() throws Exception {
        // Simulate task
        System.out.println("Performing critical startup task...");
    }
}
```

----------

## 7. Complete Working Example - Putting It All Together

### Project Structure

```
spring-boot-demo/
├─ src/
│  ├─ main/
│  │  ├─ java/
│  │  │  └─ com/example/demo/
│  │  │     ├─ DemoApplication.java
│  │  │     ├─ controller/
│  │  │     │  └─ StudentController.java
│  │  │     ├─ entity/
│  │  │     │  └─ Student.java
│  │  │     ├─ repository/
│  │  │     │  └─ StudentRepository.java
│  │  │     ├─ service/
│  │  │     │  └─ StudentService.java
│  │  │     └─ runner/
│  │  │        ├─ DataInitRunner.java
│  │  │        └─ InfoDisplayRunner.java
│  │  └─ resources/
│  │     └─ application.properties
│  └─ test/
└─ pom.xml
```

### Complete pom.xml

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <!-- Spring Boot Parent -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>spring-boot-demo</artifactId>
    <version>1.0.0</version>
    <name>Spring Boot Complete Demo</name>
    <description>Comprehensive Spring Boot demonstration</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- JPA Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- H2 Database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- DevTools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Test Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### application.properties

properties

```properties
# Application Info
spring.application.name=Spring Boot Demo
app.name=Student Management System
app.version=1.0.0

# Server Configuration
server.port=8080

# H2 Database
spring.datasource.url=jdbc:h2:mem:studentdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA/Hibernate
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# H2 Console
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Actuator
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always
info.app.name=${app.name}
info.app.version=${app.version}

# Logging
logging.level.com.example.demo=DEBUG
logging.level.org.springframework.web=INFO
```

### Main Application Class

java

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Main Spring Boot Application Class
 * 
 * @SpringBootApplication combines:
 *  - @SpringBootConfiguration
 *  - @EnableAutoConfiguration
 *  - @ComponentScan
 */
@SpringBootApplication
public class DemoApplication {
    
    public static void main(String[] args) {
        System.out.println("Starting Spring Boot Application...\n");
        
        // Bootstrap the application
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

### Testing the Application

**1. Build and Run:**

bash

```bash
# Using Maven
mvn clean install
mvn spring-boot:run

# Or run with arguments
mvn spring-boot:run -Dspring-boot.run.arguments="--debug --env=dev"

# Using JAR
java -jar target/spring-boot-demo-1.0.0.jar
```

**2. Test Endpoints:**

bash

```bash
# Create a student
curl -X POST http://localhost:8080/api/students \
  -H "Content-Type: application/json" \
  -d '{"name":"John Doe","email":"john@example.com","age":22}'

# Get all students
curl http://localhost:8080/api/students

# Get student by ID
curl http://localhost:8080/api/students/1

# Health check
curl http://localhost:8080/actuator/health

# Application info
curl http://localhost:8080/actuator/info
```

----------

## 8. Summary and Best Practices

### Key Takeaways

```
┌──────────────────────────────────────────────────┐
│  SPRING BOOT CORE CONCEPTS                       │
├──────────────────────────────────────────────────┤
│  1. Auto-Configuration                           │
│     └─ Convention over configuration             │
│                                                  │
│  2. Starters                                     │
│     └─ Curated dependency bundles                │
│                                                  │
│  3. Embedded Servers                             │
│     └─ No external server needed                 │
│                                                  │
│  4. Production-Ready Features                    │
│     └─ Actuator, metrics, health checks          │
│                                                  │
│  5. Rapid Development                            │
│     └─ DevTools, hot reload                      │
└──────────────────────────────────────────────────┘
```

### Best Practices

1.  **Use Appropriate Starters**
    -   Don't add individual dependencies when a starter exists
    -   Let Spring Boot manage versions
2.  **Leverage Auto-Configuration**
    -   Understand what's auto-configured
    -   Use `debug=true` to see configuration report
    -   Override only when necessary
3.  **Organize Code Properly**
    -   Main class in root package
    -   Sub-packages for controllers, services, etc.
    -   Enables proper component scanning
4.  **Use Runners Wisely**
    -   Data initialization
    -   System checks
    -   Don't perform long-running tasks
    -   Use @Order for execution sequence
5.  **Configuration Management**
    -   Use application.properties/yml
    -   Profile-specific configurations
    -   Externalize sensitive data
6.  **Monitoring and Metrics**
    -   Enable Actuator in production
    -   Secure actuator endpoints
    -   Monitor application health

### Common Pitfalls to Avoid

```
❌ Main class in wrong package (component scan issues)
✓ Place main class in root package

❌ Mixing dependency versions manually
✓ Use starter parent for version management

❌ Disabling auto-config unnecessarily
✓ Understand before disabling

❌ Heavy processing in runners
✓ Keep runners lightweight

❌ Exposing all actuator endpoints in production
✓ Secure and limit endpoint exposure
```

----------

## Conclusion

Spring Boot simplifies Java application development through:

-   **Convention over configuration**
-   **Intelligent auto-configuration**
-   **Curated starter dependencies**
-   **Embedded server support**
-   **Production-ready features**

This tutorial covered all core concepts with practical examples. Practice by building small applications and gradually exploring advanced features!
