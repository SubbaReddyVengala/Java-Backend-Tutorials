# Spring MVC Annotations - Complete Tutorial

## Table of Contents

1.  Introduction to Spring MVC
2. Core Annotations Explained
3.  Memory Visualization
4.  Complete CRUD Example
5.  Best Practices]

----------

## Introduction to Spring MVC 

### What is MVC?

**Analogy**: Think of a restaurant:

-   **Model**  (Kitchen): Prepares the data/food
-   **View**  (Menu/Plate): Presents the data to customers
-   **Controller**  (Waiter): Takes requests and coordinates between kitchen and customers

### Spring MVC Flow

```
Client Request → DispatcherServlet → Controller → Service → Repository → Database
                                         ↓
Client Response ← View/JSON ← Controller ←
```

**Memory Tip**: Remember "**D**ogs  **C**an  **S**ometimes  **R**un  **D**aily"

-   **D**ispatcherServlet
-   **C**ontroller
-   **S**ervice
-   **R**epository
-   **D**atabase

----------

## Core Annotations Explained 

### 1. @RestController

**What it does**: Combines  `@Controller`  +  `@ResponseBody`. Tells Spring this class handles REST API requests and returns data (JSON/XML) instead of views.

**Analogy**: Like a food truck that serves takeout only (no dine-in) — it directly gives you the product without presentation/plating.

**Memory Visualization**:

```
@RestController = @Controller + @ResponseBody
    ↓
Automatic JSON/XML conversion
```

**Example**:

java

```java
@RestController  // This class handles REST requests
public class UserController {
    // All methods return data, not views
}
```

----------

### 2. @RequestMapping

**What it does**: Maps HTTP requests to handler methods. Works at class or method level.

**Analogy**: Like a postal address — it tells where to deliver the request.

**Attributes**:

-   `value/path`: URL path
-   `method`: HTTP method (GET, POST, etc.)
-   `produces`: Response type (JSON, XML)
-   `consumes`: Request type

**Memory Tip**: "**R**equest  **M**aps to  **P**ath" =  **R**equest**M**apping defines  **P**ath

**Example**:

java

```java
@RestController
@RequestMapping("/api/users")  // Base path for all methods
public class UserController {
    
    @RequestMapping(method = RequestMethod.GET)
    public List<User> getAll() {
        return userService.findAll();
    }
}
```

----------

### 3. @GetMapping, @PostMapping, @PutMapping, @DeleteMapping

**What they do**: Shortcuts for  `@RequestMapping`  with specific HTTP methods.

**Analogy**: Different types of restaurant orders:

-   **GET**  (@GetMapping): "Show me the menu" (Read/Retrieve)
-   **POST**  (@PostMapping): "Place new order" (Create)
-   **PUT**  (@PutMapping): "Change my entire order" (Update completely)
-   **DELETE**  (@DeleteMapping): "Cancel my order" (Delete)

**Memory Visualization**:

```
HTTP Methods = CRUD Operations
GET    → Read    → @GetMapping
POST   → Create  → @PostMapping
PUT    → Update  → @PutMapping
DELETE → Delete  → @DeleteMapping
```

**Example**:

java

```java
@GetMapping("/all")           // GET /api/users/all
@PostMapping("/create")       // POST /api/users/create
@PutMapping("/update/{id}")   // PUT /api/users/update/5
@DeleteMapping("/delete/{id}") // DELETE /api/users/delete/5
```

----------

### 4. @PathVariable

**What it does**: Extracts values from the URI path.

**Analogy**: Like apartment numbers in an address: "123 Main Street,  **Apt 5B**" — the 5B is the path variable.

**Memory Tip**: "**Path**Variable = Value from URL  **Path**"

**URI Structure**:

```
http://localhost:8080/api/users/123/orders/456
                                  ↑          ↑
                              userId    orderId
```

**Example**:

java

```java
@GetMapping("/users/{id}")
public User getUserById(@PathVariable Long id) {
    // id = 123 from URL /users/123
    return userService.findById(id);
}

// Multiple path variables
@GetMapping("/users/{userId}/orders/{orderId}")
public Order getOrder(@PathVariable Long userId, 
                     @PathVariable Long orderId) {
    return orderService.findOrder(userId, orderId);
}
```

----------

### 5. @RequestParam

**What it does**: Extracts query parameters from the URL.

**Analogy**: Like filtering options on an e-commerce site: "Show me shirts  **?color=blue&size=M**"

**Memory Tip**: "**Request**Param =  **Param**eters in  **Request**"

**URI Structure**:

```
http://localhost:8080/api/users?age=25&city=NewYork
                                 ↑              ↑
                              param1        param2
```

**Attributes**:

-   `required`: Is it mandatory? (default: true)
-   `defaultValue`: Default if not provided

**Example**:

java

```java
@GetMapping("/users")
public List<User> getUsers(
    @RequestParam(required = false) Integer age,
    @RequestParam(defaultValue = "0") int page) {
    
    // URL: /users?age=25&page=2
    return userService.findByAge(age, page);
}
```

**@PathVariable vs @RequestParam**:

```
@PathVariable    → /users/123 (part of path, usually required)
@RequestParam    → /users?id=123 (query param, optional filtering)
```

----------

### 6. @RequestBody

**What it does**: Binds HTTP request body (JSON/XML) to a Java object.

**Analogy**: Like a package delivery — the content inside the package becomes a Java object.

**Memory Tip**: "**Request**Body = Data in  **Body**  of  **Request**"

**How it works**:

```
Client sends JSON  →  @RequestBody  →  Java Object
{                     (Jackson          User user
  "name": "John",     converts)
  "email": "..."
}
```

**Example**:

java

```java
@PostMapping("/users")
public User createUser(@RequestBody User user) {
    // JSON automatically converted to User object
    return userService.save(user);
}

// Request from client:
// POST /api/users
// Body: {"name": "John", "email": "john@example.com"}
```

----------

### 7. @ResponseBody

**What it does**: Converts Java object to HTTP response body (JSON/XML).

**Analogy**: Like gift wrapping — wraps your Java object in JSON format before sending.

**Memory Tip**: "**Response**Body = Object in  **Body**  of  **Response**"

**Note**: Not needed with  `@RestController`  (already included).

**Example**:

java

```java
@Controller  // Regular controller
public class UserController {
    
    @GetMapping("/user")
    @ResponseBody  // Needed to return JSON
    public User getUser() {
        return new User("John", "john@example.com");
    }
}
```

----------

## Memory Visualization 

### Request Flow Diagram

```
┌─────────────────────────────────────────────────────────┐
│  Client Request                                         │
│  GET /api/users/123?include=orders                      │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│  Spring DispatcherServlet                               │
│  "Where should this request go?"                        │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│  @RestController                                        │
│  @RequestMapping("/api/users")                          │
│  ┌───────────────────────────────────────────────────┐ │
│  │  @GetMapping("/{id}")                             │ │
│  │  public User getUser(                             │ │
│  │      @PathVariable Long id,    ← from path        │ │
│  │      @RequestParam String include) ← from query   │ │
│  └───────────────────────────────────────────────────┘ │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│  Service Layer                                          │
│  Business Logic                                         │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│  Repository Layer                                       │
│  Database Access                                        │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│  Response                                               │
│  @ResponseBody (automatic with @RestController)         │
│  User object → JSON                                     │
│  {"id":123, "name":"John", "email":"..."}               │
└─────────────────────────────────────────────────────────┘
```

### Memory Palace Technique

Imagine a  **Library Building**:

**Floor 1 (Reception)**:  `@RestController`  - The receptionist who handles all visitor requests

**Floor 2 (Directory)**:  `@RequestMapping`  - The building directory showing where departments are

**Floor 3 (Departments)**:  `@GetMapping`,  `@PostMapping`,  `@PutMapping`,  `@DeleteMapping`  - Different department operations

**Floor 4 (Mailroom)**:

-   `@PathVariable`  - Letters addressed to specific rooms
-   `@RequestParam`  - Packages with additional instructions
-   `@RequestBody`  - Packages with contents inside
-   `@ResponseBody`  - Outgoing mail

----------

## Complete CRUD Example 

### Project Structure

```
src/main/java/com/example/demo
├── model
│   └── Product.java
├── repository
│   └── ProductRepository.java
├── service
│   └── ProductService.java
└── controller
    └── ProductController.java
```

### 1. Model Layer (Product.java)

java

```java
package com.example.demo.model;

import jakarta.persistence.*;

@Entity
@Table(name = "products")
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
    private Double price;
    private Integer quantity;
    
    // Constructors
    public Product() {}
    
    public Product(String name, String description, Double price, Integer quantity) {
        this.name = name;
        this.description = description;
        this.price = price;
        this.quantity = quantity;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public Double getPrice() { return price; }
    public void setPrice(Double price) { this.price = price; }
    
    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }
}
```

### 2. Repository Layer (ProductRepository.java)

java

```java
package com.example.demo.repository;

import com.example.demo.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Custom query methods
    List<Product> findByNameContaining(String name);
    List<Product> findByPriceBetween(Double minPrice, Double maxPrice);
}
```

### 3. Service Layer (ProductService.java)

java

```java
package com.example.demo.service;

import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    // CREATE
    public Product createProduct(Product product) {
        return productRepository.save(product);
    }
    
    // READ - Get all
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
    
    // READ - Get by ID
    public Optional<Product> getProductById(Long id) {
        return productRepository.findById(id);
    }
    
    // READ - Search by name
    public List<Product> searchByName(String name) {
        return productRepository.findByNameContaining(name);
    }
    
    // READ - Filter by price range
    public List<Product> getProductsByPriceRange(Double minPrice, Double maxPrice) {
        return productRepository.findByPriceBetween(minPrice, maxPrice);
    }
    
    // UPDATE
    public Product updateProduct(Long id, Product productDetails) {
        Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Product not found with id: " + id));
        
        product.setName(productDetails.getName());
        product.setDescription(productDetails.getDescription());
        product.setPrice(productDetails.getPrice());
        product.setQuantity(productDetails.getQuantity());
        
        return productRepository.save(product);
    }
    
    // DELETE
    public void deleteProduct(Long id) {
        Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Product not found with id: " + id));
        productRepository.delete(product);
    }
}
```

### 4. Controller Layer (ProductController.java)

java

```java
package com.example.demo.controller;

import com.example.demo.model.Product;
import com.example.demo.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController  // Combines @Controller + @ResponseBody
@RequestMapping("/api/products")  // Base URL for all endpoints
public class ProductController {
    
    @Autowired
    private ProductService productService;
    
    
    // ============ CREATE ============
    
    /**
     * Create a new product
     * POST /api/products
     * Request Body: {"name":"Laptop", "description":"...", "price":999.99, "quantity":10}
     */
    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody Product product) {
        Product createdProduct = productService.createProduct(product);
        return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
    }
    
    
    // ============ READ ============
    
    /**
     * Get all products
     * GET /api/products
     */
    @GetMapping
    public ResponseEntity<List<Product>> getAllProducts() {
        List<Product> products = productService.getAllProducts();
        return ResponseEntity.ok(products);
    }
    
    /**
     * Get product by ID
     * GET /api/products/5
     */
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        return productService.getProductById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    /**
     * Search products by name
     * GET /api/products/search?name=laptop
     */
    @GetMapping("/search")
    public ResponseEntity<List<Product>> searchProducts(
            @RequestParam String name) {
        List<Product> products = productService.searchByName(name);
        return ResponseEntity.ok(products);
    }
    
    /**
     * Filter products by price range
     * GET /api/products/filter?minPrice=100&maxPrice=1000
     */
    @GetMapping("/filter")
    public ResponseEntity<List<Product>> filterByPrice(
            @RequestParam Double minPrice,
            @RequestParam Double maxPrice) {
        List<Product> products = productService.getProductsByPriceRange(minPrice, maxPrice);
        return ResponseEntity.ok(products);
    }
    
    
    // ============ UPDATE ============
    
    /**
     * Update existing product
     * PUT /api/products/5
     * Request Body: {"name":"Updated Laptop", "description":"...", "price":899.99, "quantity":15}
     */
    @PutMapping("/{id}")
    public ResponseEntity<Product> updateProduct(
            @PathVariable Long id,
            @RequestBody Product productDetails) {
        try {
            Product updatedProduct = productService.updateProduct(id, productDetails);
            return ResponseEntity.ok(updatedProduct);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    
    // ============ DELETE ============
    
    /**
     * Delete product
     * DELETE /api/products/5
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        try {
            productService.deleteProduct(id);
            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

### Testing the API

#### 1. CREATE - Add new product

bash

```bash
POST http://localhost:8080/api/products
Content-Type: application/json

{
  "name": "Laptop",
  "description": "High performance laptop",
  "price": 999.99,
  "quantity": 10
}
```

#### 2. READ - Get all products

bash

```bash
GET http://localhost:8080/api/products
```

#### 3. READ - Get specific product

bash

```bash
GET http://localhost:8080/api/products/1
```

#### 4. READ - Search by name

bash

```bash
GET http://localhost:8080/api/products/search?name=laptop
```

#### 5. READ - Filter by price

bash

```bash
GET http://localhost:8080/api/products/filter?minPrice=500&maxPrice=1500
```

#### 6. UPDATE - Modify product

bash

```bash
PUT http://localhost:8080/api/products/1
Content-Type: application/json

{
  "name": "Updated Laptop",
  "description": "Ultra high performance laptop",
  "price": 1299.99,
  "quantity": 15
}
```

#### 7. DELETE - Remove product

bash

```bash
DELETE http://localhost:8080/api/products/1
```

----------

## Best Practices {#best-practices}

### 1. Use Specific Mapping Annotations

java

```java
// Good ✓
@GetMapping("/users")

// Avoid ✗
@RequestMapping(value = "/users", method = RequestMethod.GET)
```

### 2. Path Variable Naming

java

```java
// Clear naming ✓
@GetMapping("/users/{userId}/orders/{orderId}")
public Order getOrder(@PathVariable Long userId, @PathVariable Long orderId)

// When names differ ✓
@GetMapping("/users/{id}")
public User getUser(@PathVariable("id") Long userId)
```

### 3. Optional Request Parameters

java

```java
// Always provide defaults for optional params ✓
@GetMapping("/products")
public List<Product> getProducts(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size)
```

### 4. Use ResponseEntity for Better Control

java

```java
// Good - Full HTTP control ✓
@GetMapping("/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .map(ResponseEntity::ok)
        .orElse(ResponseEntity.notFound().build());
}
```

### 5. Validate Request Body

java

```java
// Add validation ✓
@PostMapping
public ResponseEntity<Product> create(@Valid @RequestBody Product product) {
    // @Valid triggers validation
}
```

----------

## Quick Reference Cheat Sheet

<img width="832" height="781" alt="image" src="https://github.com/user-attachments/assets/5625c1a0-fa81-4ad7-8f3b-d46b2f34beae" />



----------

## Memory Mnemonics

**R**est**C**ontroller →  **R**eturns  **C**ontent (JSON)

**G**et**P**ost**P**ut**D**elete →  **G**rab  **P**lace  **P**atch  **D**estroy

**Path**Variable →  **Path**  of URL (fixed position)

**Request**Param →  **Request**  extras (flexible queries)

**Request**Body → Data  **In**side request

**Response**Body → Data  **Out**side to client

----------

## Conclusion

Spring MVC annotations simplify REST API development by handling:

-   Request routing (@RequestMapping, @GetMapping, etc.)
-   Data binding (@RequestBody, @PathVariable, @RequestParam)
-   Response formatting (@ResponseBody, @RestController)

Master these annotations and you'll build clean, maintainable REST APIs efficiently!
