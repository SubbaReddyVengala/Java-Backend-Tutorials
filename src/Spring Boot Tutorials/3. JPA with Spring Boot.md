
# JPA with Spring Boot - Complete Tutorial

## Table of Contents

1.  What is JPA
2.  What is ORM
3.  ORM Basics
4.  What is Persistence Layer
5.  Spring Data JPA Introduction
6.  Hibernate Integration with JPA
7.  Entity Classes
8.  JPA Annotations
9.  Repository Interfaces

----------

## What is JPA

**JPA (Java Persistence API)**  is a specification that defines how to manage relational data in Java applications. Think of it as a  **rulebook**  or  **contract**  that describes what methods and behaviors should exist for working with databases.

### Analogy: JPA as a Restaurant Menu

Imagine JPA as a  **standardized menu format**  that all restaurants must follow:

-   The menu (JPA) specifies what information should be present (appetizers, main courses, desserts)
-   Different restaurants (Hibernate, EclipseLink, OpenJPA) can implement their own actual dishes
-   Customers (developers) know what to expect regardless of which restaurant they visit

### Key Points:

-   JPA is  **NOT**  an implementation - it's just a specification
-   JPA is part of Java EE (now Jakarta EE)
-   It provides annotations and APIs to map Java objects to database tables
-   Version history: JPA 1.0 (2006) → JPA 2.0 (2009) → JPA 2.1 (2013) → JPA 2.2 (2017) → Jakarta Persistence 3.0+ (2020+)

### Why JPA?

```
Without JPA:                  With JPA:
┌──────────────┐             ┌──────────────┐
│ Application  │             │ Application  │
└──────┬───────┘             └──────┬───────┘
       │                            │
       │ Raw SQL                    │ Java Objects
       │ JDBC Code                  │ Methods
       ↓                            ↓
┌──────────────┐             ┌──────────────┐
│   Database   │             │     JPA      │
└──────────────┘             └──────┬───────┘
                                    │
                             ┌──────────────┐
                             │   Database   │
                             └──────────────┘
```

----------

## What is ORM

**ORM (Object-Relational Mapping)**  is a programming technique that lets you interact with a database using objects instead of SQL queries.

### Analogy: ORM as a Translator

Think of ORM as a  **universal translator**  between two people who speak different languages:

-   **You**  speak "Object-Oriented Language" (Java objects, classes, methods)
-   **Database**  speaks "Relational Language" (tables, rows, columns, SQL)
-   **ORM**  translates between these two languages automatically

### The Impedance Mismatch Problem

Object-oriented programming and relational databases have fundamental differences:

<img width="826" height="268" alt="image" src="https://github.com/user-attachments/assets/7d5bdabc-78bb-47bd-89c1-b29a38b9faab" />


### Memory Visualization: Without vs With ORM

**Without ORM (Manual JDBC):**

```
Java Application Memory          Database
┌─────────────────────┐         ┌──────────────────┐
│ Student student     │         │ STUDENT TABLE    │
│ - name = "John"    │─┐       │ ┌──┬──────┬────┐ │
│ - age = 20         │ │       │ │ID│NAME  │AGE │ │
└─────────────────────┘ │       │ ├──┼──────┼────┤ │
                        │       │ │1 │John  │20  │ │
 Manual Conversion      │       │ └──┴──────┴────┘ │
 (Write SQL, parse     ─┘       └──────────────────┘
  ResultSet, etc.)
```

**With ORM:**

```
Java Application Memory          Database
┌─────────────────────┐         ┌──────────────────┐
│ Student student     │         │ STUDENT TABLE    │
│ - name = "John"    │◄────────►│ ┌──┬──────┬────┐ │
│ - age = 20         │   ORM    │ │ID│NAME  │AGE │ │
└─────────────────────┘  Magic  │ ├──┼──────┼────┤ │
                                │ │1 │John  │20  │ │
     Automatic Mapping          │ └──┴──────┴────┘ │
                                └──────────────────┘
```

----------

## ORM Basics

### Core Concepts

#### 1.  **Entity**

An entity is a Java class that represents a table in the database.

java

```java
// Java Entity
@Entity
public class Student {
    @Id
    private Long id;
    private String name;
    private int age;
}
```

sql

```sql
-- Corresponding Database Table
CREATE TABLE student (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    age INT
);
```

#### 2.  **Mapping**

ORM creates a mapping between:

-   **Class ↔ Table**
-   **Object ↔ Row**
-   **Field ↔ Column**

#### 3.  **CRUD Operations**

java

```java
// Instead of SQL:
// INSERT INTO student VALUES (1, 'John', 20);
Student student = new Student(1L, "John", 20);
entityManager.persist(student);  // ORM converts to INSERT

// Instead of SQL:
// SELECT * FROM student WHERE id = 1;
Student found = entityManager.find(Student.class, 1L);  // ORM converts to SELECT

// Instead of SQL:
// UPDATE student SET age = 21 WHERE id = 1;
found.setAge(21);
entityManager.merge(found);  // ORM converts to UPDATE

// Instead of SQL:
// DELETE FROM student WHERE id = 1;
entityManager.remove(found);  // ORM converts to DELETE
```

### ORM Memory Visualization: Entity Lifecycle

```
┌─────────────────────────────────────────────────────┐
│             Application Memory (JVM)                │
│                                                     │
│  [New]           [Managed]         [Detached]      │
│    ↓                ↓                  ↓           │
│  Student        Student            Student         │
│  (Transient)   (Persistent)      (Disconnected)    │
│                    ↕                               │
│                    │                               │
│              Persistence                           │
│               Context                              │
│              (Entity Manager)                      │
└────────────────────┬────────────────────────────────┘
                     │ Synchronization
                     ↓
┌─────────────────────────────────────────────────────┐
│                  Database                           │
│  ┌──────────────────────────────────────┐          │
│  │         STUDENT TABLE                │          │
│  │  ID  │  NAME   │  AGE                │          │
│  │  1   │  John   │  20                 │          │
│  └──────────────────────────────────────┘          │
└─────────────────────────────────────────────────────┘
```

----------

## What is Persistence Layer

The  **Persistence Layer**  is the part of your application responsible for storing and retrieving data from a database.

### Analogy: Library System

Think of your application as a library:

-   **Presentation Layer**  = Reception desk (interacts with visitors)
-   **Business Layer**  = Librarians (process requests, apply rules)
-   **Persistence Layer**  = Book storage and cataloging system (stores and retrieves books)
-   **Database**  = Physical storage shelves

### Architecture Layers

```
┌────────────────────────────────────────┐
│      Presentation Layer                │
│  (Controllers, REST APIs, Views)       │
└──────────────┬─────────────────────────┘
               │
┌──────────────▼─────────────────────────┐
│      Business/Service Layer            │
│  (Business Logic, Validations)         │
└──────────────┬─────────────────────────┘
               │
┌──────────────▼─────────────────────────┐
│      Persistence Layer ⬅ JPA/ORM      │
│  (Data Access, Repository)             │
└──────────────┬─────────────────────────┘
               │
┌──────────────▼─────────────────────────┐
│         Database Layer                 │
│  (MySQL, PostgreSQL, Oracle, etc.)     │
└────────────────────────────────────────┘
```

### Responsibilities of Persistence Layer:

1.  **Mapping**  between objects and database tables
2.  **Transaction management**  (ACID properties)
3.  **Caching**  for performance
4.  **Query generation**  from method names or criteria
5.  **Connection pooling**  management

### Example Without Persistence Layer (Raw JDBC):

java

```java
// Lots of boilerplate code!
public Student findById(Long id) {
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    
    try {
        conn = dataSource.getConnection();
        stmt = conn.prepareStatement("SELECT * FROM student WHERE id = ?");
        stmt.setLong(1, id);
        rs = stmt.executeQuery();
        
        if (rs.next()) {
            Student student = new Student();
            student.setId(rs.getLong("id"));
            student.setName(rs.getString("name"));
            student.setAge(rs.getInt("age"));
            return student;
        }
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        // Close resources
        if (rs != null) rs.close();
        if (stmt != null) stmt.close();
        if (conn != null) conn.close();
    }
    return null;
}
```

### Example With Persistence Layer (JPA):

java

```java
// Clean and simple!
@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    // That's it! No code needed.
}

// Usage:
Student student = studentRepository.findById(1L).orElse(null);
```

----------

## Spring Data JPA Introduction

**Spring Data JPA**  is a framework that sits on top of JPA and makes it even easier to implement data access layers.

### Analogy: Amazon vs Building Your Own Store

-   **Plain JPA**  = Building your own e-commerce website from scratch
-   **Spring Data JPA**  = Using Amazon's infrastructure (warehouses, delivery, payment systems)

### The Stack:

```
┌────────────────────────────────────┐
│    Your Application Code           │
│  (Service, Controller layers)      │
└──────────────┬─────────────────────┘
               │
┌──────────────▼─────────────────────┐
│      Spring Data JPA               │
│  (Repository abstractions,         │
│   Query derivation, etc.)          │
└──────────────┬─────────────────────┘
               │
┌──────────────▼─────────────────────┐
│          JPA (Specification)       │
│  (EntityManager, Annotations)      │
└──────────────┬─────────────────────┘
               │
┌──────────────▼─────────────────────┐
│    Hibernate (Implementation)      │
│  (Actual ORM logic)                │
└──────────────┬─────────────────────┘
               │
┌──────────────▼─────────────────────┐
│          JDBC Driver               │
└──────────────┬─────────────────────┘
               │
┌──────────────▼─────────────────────┐
│          Database                  │
└────────────────────────────────────┘
```

### Key Features of Spring Data JPA:

1.  **Repository Abstraction**  - No boilerplate DAO code
2.  **Query Methods**  - Generate queries from method names
3.  **Custom Queries**  - Use JPQL or native SQL when needed
4.  **Pagination & Sorting**  - Built-in support
5.  **Auditing**  - Automatic tracking of created/modified dates

### Example:

java

```java
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Spring Data JPA automatically implements these!
    
    // Find by name
    List<Student> findByName(String name);
    
    // Find by age greater than
    List<Student> findByAgeGreaterThan(int age);
    
    // Find by name and age
    Optional<Student> findByNameAndAge(String name, int age);
    
    // Count students by name
    long countByName(String name);
    
    // Custom query using JPQL
    @Query("SELECT s FROM Student s WHERE s.age BETWEEN :minAge AND :maxAge")
    List<Student> findByAgeRange(@Param("minAge") int min, @Param("maxAge") int max);
}
```

----------

## Hibernate Integration with JPA

**Hibernate**  is the most popular implementation of the JPA specification.

### Analogy: USB Standard vs USB Device

-   **JPA**  = USB standard (defines the interface)
-   **Hibernate**  = Kingston USB drive (implements the standard)
-   You can use any USB drive, but Kingston might have extra features

### JPA Implementations:

```
        JPA Specification
              │
    ┌─────────┼─────────┐
    │         │         │
Hibernate  EclipseLink  OpenJPA
  (Most     (Reference   (Apache)
  Popular)  Implementation)
```

### Why Hibernate?

1.  **Mature**  - Been around since 2001
2.  **Performance**  - Advanced caching strategies
3.  **Features**  - More than JPA requires
4.  **Community**  - Large ecosystem and support
5.  **Spring Boot Default**  - Works out of the box

### Hibernate Architecture:

```
┌─────────────────────────────────────────────┐
│         Your Application                    │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│   Hibernate Session/EntityManager           │
│   (API for CRUD operations)                 │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│   Persistence Context (1st Level Cache)     │
│   (Manages entity instances)                │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│   2nd Level Cache (Optional)                │
│   (Session Factory level caching)           │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│   Transaction Manager                       │
│   (Handles database transactions)           │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│   JDBC Connection Pool                      │
│   (Manages database connections)            │
└──────────────┬──────────────────────────────┘
               │
           Database
```

### Spring Boot Configuration:

**application.properties:**

properties

```properties
# Database connection
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret

# Hibernate properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Hibernate caching
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
```

**Maven Dependency:**

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

----------

## Entity Classes

An  **Entity**  is a lightweight Java class that represents a table in the database.

### Analogy: Blueprint and Building

-   **Entity Class**  = Blueprint for a house
-   **Entity Instance (Object)**  = Actual house built from blueprint
-   **Database Table**  = Neighborhood where houses are stored

### Rules for Entity Classes:

1.  Must be annotated with  `@Entity`
2.  Must have a no-argument constructor
3.  Must have a primary key field annotated with  `@Id`
4.  Should not be final (Hibernate uses proxies)
5.  Fields should not be public (use getters/setters)

### Basic Entity Example:

java

```java
package com.example.model;

import javax.persistence.*;
import java.time.LocalDate;

@Entity  // Marks this class as a JPA entity
@Table(name = "students")  // Optional: specify table name
public class Student {
    
    @Id  // Primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment
    private Long id;
    
    @Column(name = "student_name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "age")
    private Integer age;
    
    @Column(unique = true)
    private String email;
    
    private LocalDate enrollmentDate;
    
    // Default constructor (required by JPA)
    public Student() {
    }
    
    // Constructor with parameters (for convenience)
    public Student(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
        this.enrollmentDate = LocalDate.now();
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Integer getAge() {
        return age;
    }
    
    public void setAge(Integer age) {
        this.age = age;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public LocalDate getEnrollmentDate() {
        return enrollmentDate;
    }
    
    public void setEnrollmentDate(LocalDate enrollmentDate) {
        this.enrollmentDate = enrollmentDate;
    }
    
    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + 
               "', age=" + age + ", email='" + email + "'}";
    }
}
```

### Memory Representation:

```
Java Heap Memory                        Database
┌─────────────────────────┐            ┌──────────────────────────┐
│ Student Object          │            │ STUDENTS Table           │
│ ┌─────────────────────┐ │            │ ┌──────────────────────┐ │
│ │ id = 1              │ │◄──────────►│ │ ID = 1               │ │
│ │ name = "John"       │ │   Mapped   │ │ STUDENT_NAME = "John"│ │
│ │ age = 20            │ │            │ │ AGE = 20             │ │
│ │ email = "j@ex.com"  │ │            │ │ EMAIL = "j@ex.com"   │ │
│ │ enrollmentDate = ...│ │            │ │ ENROLLMENT_DATE = ...│ │
│ └─────────────────────┘ │            │ └──────────────────────┘ │
└─────────────────────────┘            └──────────────────────────┘
```

### Relationships Between Entities:

java

```java
// One-to-Many: One student has many courses
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "student", cascade = CascadeType.ALL)
    private List<Course> courses = new ArrayList<>();
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String courseName;
    
    @ManyToOne
    @JoinColumn(name = "student_id")
    private Student student;
}
```

----------

## JPA Annotations

Annotations are metadata that provide information about the entity to JPA.

### Core Annotations:

#### 1.  **@Entity**

Marks a class as a JPA entity (mapped to a database table).

java

```java
@Entity
public class Product {
    // ...
}
```

#### 2.  **@Table**

Specifies the table name (optional if table name = class name).

java

```java
@Entity
@Table(name = "products", schema = "inventory")
public class Product {
    // ...
}
```

#### 3.  **@Id**

Marks the primary key field.

java

```java
@Id
private Long id;
```

#### 4.  **@GeneratedValue**

Specifies how primary key should be generated.

java

```java
// Auto-increment (database handles it)
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

// Uses a database sequence
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "product_seq")
@SequenceGenerator(name = "product_seq", sequenceName = "product_sequence")
private Long id;

// Uses a table to generate IDs
@GeneratedValue(strategy = GenerationType.TABLE)
private Long id;

// JPA provider chooses the strategy
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

#### 5.  **@Column**

Specifies column properties.

java

```java
@Column(
    name = "product_name",           // Column name in database
    nullable = false,                // NOT NULL constraint
    unique = true,                   // UNIQUE constraint
    length = 200,                    // VARCHAR(200)
    precision = 10,                  // For decimal numbers
    scale = 2,                       // Decimal places
    columnDefinition = "VARCHAR(255) DEFAULT 'Unknown'"
)
private String name;
```

#### 6.  **@Transient**

Marks a field that should NOT be persisted to the database.

java

```java
@Transient
private int temporaryCalculation;  // Not stored in database
```

#### 7.  **@Temporal**

Specifies the temporal type for Date/Calendar fields (for older Date API).

java

```java
@Temporal(TemporalType.DATE)        // Only date (no time)
private Date birthDate;

@Temporal(TemporalType.TIME)        // Only time (no date)
private Date startTime;

@Temporal(TemporalType.TIMESTAMP)   // Both date and time
private Date createdAt;

// Modern approach with Java 8+:
private LocalDate birthDate;        // No @Temporal needed
private LocalTime startTime;
private LocalDateTime createdAt;
```

#### 8.  **@Enumerated**

Maps enum types to database.

java

```java
public enum Status {
    ACTIVE, INACTIVE, PENDING
}

@Entity
public class User {
    @Enumerated(EnumType.STRING)    // Store as "ACTIVE", "INACTIVE"
    private Status status;
    
    // OR
    
    @Enumerated(EnumType.ORDINAL)   // Store as 0, 1, 2 (not recommended)
    private Status status;
}
```

#### 9.  **@Lob**

For Large Objects (Binary Large Object or Character Large Object).

java

```java
@Lob
private byte[] profilePicture;  // BLOB in database

@Lob
private String description;     // CLOB in database (for very long text)
```

### Relationship Annotations:

#### 10.  **@OneToOne**
## 🔹 Definition

A **`@OneToOne`** relationship means:

> Each record in one entity **is associated with exactly one record** in another entity.

Example:

-   One **User** has one **Profile**.
    
-   One **Profile** belongs to one **User**.
## 🔹 Entity Setup

### 🧩 `User` Entity — **Owning Side**
``` java
@Entity
public class User {

    @Id
    private Long id;

    private String name;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private Profile profile;

    // getters and setters
}

```
### 💬 Explanation

-   **`@OneToOne`** → Defines a one-to-one mapping.
    
-   **`@JoinColumn`** → Specifies the **foreign key column** (`profile_id`) in the `user` table that references the primary key of the `profile` table.
    
-   **`cascade = CascadeType.ALL`** → Any persist/update/remove operation on `User` cascades to its `Profile`.
    
-   The **owning side** of the relationship (controls the foreign key) is the `User` entity.

 🧩 `Profile` Entity — **Inverse Side**
``` java
@Entity
public class Profile {

    @Id
    private Long id;

    private String bio;

    @OneToOne(mappedBy = "profile")
    private User user;

    // getters and setters
}
```
### 💬 Explanation

-   **`mappedBy = "profile"`** → Refers to the field in `User` that owns the relationship.
    
-   This makes `Profile` the **inverse side** — it does not have a foreign key column.
One-to-one relationship between entities.

java

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private Profile profile;
}

@Entity
public class Profile {
    @Id
    private Long id;
    
    @OneToOne(mappedBy = "profile")
    private User user;
}
```

🧠 Database Visualization

```
USER Table                 PROFILE Table
┌──────┬────────────┐     ┌──────┬─────────┐
│ ID   │ PROFILE_ID │────►│ ID   │ BIO     │
├──────┼────────────┤     ├──────┼─────────┤
│ 1    │ 101        │     │ 101  │ "..."   │
└──────┴────────────┘     └──────┴─────────┘
```
### ➡️ Meaning:

-   In the `USER` table, `PROFILE_ID` is a **foreign key** referencing `PROFILE(ID)`.
    
-   The relationship is **unidirectional from the database perspective**, but **bidirectional in JPA** because both entities reference each other
## 🔹 Example Usage
``` java
User  user  =  new  User();
user.setId(1L);
user.setName("Subba"); 
Profile  profile  =  new  Profile();
profile.setId(101L);
profile.setBio("Java Backend Developer"); // Link both sides user.setProfile(profile);
profile.setUser(user); // Save user (profile will be saved too) userRepository.save(user);`
```
#### 11.  **@OneToMany & @ManyToOne**
## 🔹 Relationship Summary

**One Department → Many Employees**  
**Many Employees → One Department**

This is the **most common relationship** in database design.

----------

## 🧩 Entities

### 🏢 `Department` Entity — _Parent / Inverse Side_

``` java
@Entity
public class Department {

    @Id
    private Long id;

    private String name;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Employee> employees = new ArrayList<>();

    // getters and setters
}

```
### 💬 Explanation:

-   **`@OneToMany`** → One department has multiple employees.
    
-   **`mappedBy = "department"`** → The `Employee` entity owns the relationship (has the foreign key).
    
-   **`cascade = CascadeType.ALL`** → When you save or delete a department, all employees in that list will be persisted/removed automatically.
    
-   **`orphanRemoval = true`** → If an employee is removed from the list, it is also deleted from the DB.
    

----------

### 👨‍💻 `Employee` Entity — _Child / Owning Side_

``` java
@Entity
public class Employee {

    @Id
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")  // FK column in employee table
    private Department department;

    // getters and setters
}

```

### 💬 Explanation:

-   **`@ManyToOne`** → Many employees belong to one department.
    
-   **`@JoinColumn(name = "department_id")`** → Creates a foreign key column in the `employee` table.
    
-   **`fetch = FetchType.LAZY`** → Department details will be loaded only when accessed (not immediately).
One-to-many and many-to-one relationships.

java

```java
@Entity
public class Department {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, 
               orphanRemoval = true)
    private List<Employee> employees = new ArrayList<>();
}

@Entity
public class Employee {
    @Id
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}
```

**Memory Visualization:**

```
DEPARTMENT Table           EMPLOYEE Table
┌──────┬───────┐          ┌──────┬───────────────┬─────┐
│ ID   │ NAME  │          │ ID   │ NAME          │DEPT │
├──────┼───────┤          ├──────┼───────────────┼─────┤
│ 1    │ IT    │◄─────────│ 101  │ John          │  1  │
└──────┴───────┘    ┌─────│ 102  │ Jane          │  1  │
                    │     │ 103  │ Bob           │  1  │
                    └─────┴──────┴───────────────┴─────┘
```
⚙️ Example Usage
``` java
Department dept = new Department();
dept.setId(1L);
dept.setName("IT");

Employee e1 = new Employee();
e1.setId(101L);
e1.setName("John");
e1.setDepartment(dept);

Employee e2 = new Employee();
e2.setId(102L);
e2.setName("Jane");
e2.setDepartment(dept);

dept.getEmployees().add(e1);
dept.getEmployees().add(e2);

// Save department -> Employees saved automatically (cascade)
departmentRepository.save(dept);

```
#### 12.  **@ManyToMany**
## 🔹 Relationship Overview

> A **Many-to-Many** relationship means **multiple records** in one entity can be associated with **multiple records** in another entity.

Example:

-   A **Student** can enroll in **many Courses**.
    
-   A **Course** can have **many Students**.
    

----------

## 🧩 Entities

### 🎓 `Student` Entity — _Owning Side_
``` java
@Entity
public class Student {

    @Id
    private Long id;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "student_course",  // Join table name
        joinColumns = @JoinColumn(name = "student_id"),  // FK to Student
        inverseJoinColumns = @JoinColumn(name = "course_id") // FK to Course
    )
    private Set<Course> courses = new HashSet<>();

    // getters and setters
}
```
### 💬 Explanation

-   **`@ManyToMany`** → Defines the many-to-many relationship.
    
-   **`@JoinTable`** → Specifies the **join table** that connects both entities.
    
-   **`joinColumns`** → Column representing the current entity (`student_id`).
    
-   **`inverseJoinColumns`** → Column representing the other entity (`course_id`).
    
-   **Owning side** = `Student` → Because it defines the `@JoinTable`.
    

----------

### 📘 `Course` Entity — _Inverse Side_
``` java
@Entity
public class Course {

    @Id
    private Long id;

    private String title;

    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();

    // getters and setters
}

```
### 💬 Explanation

-   **`mappedBy = "courses"`** → Indicates that `Student` owns the relationship.
    
-   This side just mirrors the relationship; it doesn’t define the join table.

Many-to-many relationship (requires join table).

java

```java
@Entity
public class Student {
    @Id
    private Long id;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();
}

@Entity
public class Course {
    @Id
    private Long id;
    
    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}
```
⚙️ Example Usage
``` java
Student s1 = new Student();
s1.setId(1L);
s1.setName("Subba");

Course c1 = new Course();
c1.setId(101L);
c1.setTitle("Java");

Course c2 = new Course();
c2.setId(102L);
c2.setTitle("Spring Boot");

// Link both sides
s1.getCourses().add(c1);
s1.getCourses().add(c2);
c1.getStudents().add(s1);
c2.getStudents().add(s1);

// Save
studentRepository.save(s1);

```
**Memory Visualization:**

```
STUDENT Table          STUDENT_COURSE           COURSE Table
┌──────┬──────┐       ┌────────────┬──────────┐ ┌──────┬──────┐
│ ID   │ NAME │       │ STUDENT_ID │COURSE_ID │ │ ID   │ NAME │
├──────┼──────┤       ├────────────┼──────────┤ ├──────┼──────┤
│ 1    │ John │◄──────│ 1          │ 101      ├►│ 101  │ Math │
│ 2    │ Jane │◄──┐   │ 1          │ 102      │ │ 102  │ CS   │
└──────┴──────┘   │   │ 2          │ 101      │ └──────┴──────┘
                  └───│ 2          │ 102      │
                      └────────────┴──────────┘
```

### Cascade Types:

java

```java
@OneToMany(cascade = CascadeType.ALL)  // Apply all operations
@OneToMany(cascade = CascadeType.PERSIST)  // Only for save
@OneToMany(cascade = CascadeType.MERGE)    // Only for update
@OneToMany(cascade = CascadeType.REMOVE)   // Only for delete
@OneToMany(cascade = CascadeType.REFRESH)  // Only for refresh
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})  // Multiple
```

### Fetch Types:

java

```java
@ManyToOne(fetch = FetchType.EAGER)   // Load immediately with parent
@ManyToOne(fetch = FetchType.LAZY)    // Load only when accessed
```

**EAGER vs LAZY:**

```
EAGER Fetching:                  LAZY Fetching:
┌──────────────┐                ┌──────────────┐
│   Query 1    │                │   Query 1    │
│              │                │              │
│  SELECT *    │                │  SELECT *    │
│  FROM employee│                │  FROM employee│
│  JOIN dept   │                │  (no JOIN)   │
└──────────────┘                └──────────────┘
Loads everything                
at once                         ┌──────────────┐
                                │   Query 2    │
                                │ (only when   │
                                │  accessing   │
                                │  department) │
                                │  SELECT *    │
                                │  FROM dept   │
                                └──────────────┘
```

----------

## Repository Interfaces

Repositories provide an abstraction for data access, eliminating boilerplate code.

### Analogy: Remote Control vs Manual Control

-   **Without Repository**  = Manually adjusting TV settings (brightness, volume, channel)
-   **With Repository**  = Using a remote control (press one button to do everything)

### Repository Hierarchy:

```
           Repository<T, ID>
                  │
                  │
        ┌─────────┴─────────┐
        │                   │
 CrudRepository<T, ID>   PagingAndSortingRepository<T, ID>
        │                   │
        └─────────┬─────────┘
                  │
          JpaRepository<T, ID>
```

### 1.  **Repository Interface**

Base interface (marker interface).

java

```java
public interface StudentRepository extends Repository<Student, Long> {
    // Define only methods you need
    Optional<Student> findById(Long id);
    Student save(Student student);
}
```

### 2.  **CrudRepository Interface**

Provides CRUD operations.

java

```java
public interface StudentRepository extends CrudRepository<Student, Long> {
    // Inherited methods:
    // save(S entity)
    // saveAll(Iterable<S> entities)
    // findById(ID id)
    // existsById(ID id)
    // findAll()
    // findAllById(Iterable<ID> ids)
    // count()
    // deleteById(ID id)
    // delete(S entity)
    // deleteAll()
}
```

### 3.  **PagingAndSortingRepository Interface**

Adds pagination and sorting capabilities.

java

```java
public interface StudentRepository extends PagingAndSortingRepository<Student, Long> {
    // Inherited methods from CrudRepository + these:
    // findAll(Sort sort)
    // findAll(Pageable pageable)
}

// Usage:
Page<Student> page = studentRepository.findAll(
    PageRequest.of(0, 10, Sort.by("name").ascending())
);
```

### 4.  **JpaRepository Interface**  (Most Commonly Used)

Extends PagingAndSortingRepository and adds JPA-specific methods.

java

```java
public interface StudentRepository extends JpaRepository<Student, Long> {
    // All CRUD, Paging, Sorting methods PLUS:
    // flush()
    // saveAndFlush(S entity)
    // deleteInBatch(Iterable<S> entities)
    // deleteAllInBatch()
    // getOne(ID id)  // Returns a reference proxy
}
```

### Complete Repository Example:

java

```java
package com.example.repository;

import com.example.model.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Repository  // Optional annotation (Spring auto-detects repositories)
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // ========== Query Method Keywords ==========
    
    // Find by single property
    List<Student> findByName(String name);
    
    // Find by multiple properties (AND)
    Optional<Student> findByNameAndAge(String name, Integer age);
    
    // Find by multiple properties (OR)
    List<Student> findByNameOrEmail(String name, String email);
    
    // Greater than, Less than
    List<Student> findByAgeGreaterThan(Integer age);
    List<Student> findByAgeLessThanEqual(Integer age);
    
    // Between
    List<Student> findByAgeBetween(Integer minAge, Integer maxAge);
    
    // Like (pattern matching)
    List<Student> findByNameContaining(String keyword);  // %keyword%
    List<Student> findByNameStartingWith(String prefix); // prefix%
    List<Student> findByNameEndingWith(String suffix);   // %suffix
    
    // Is Null, Is Not Null
    List<Student> findByEmailIsNull();
    List<Student> findByEmailIsNotNull();
    
    // In (multiple values)
    List<Student> findByAgeIn(List<Integer> ages);
    
    // Order By
    List<Student> findByAgeOrderByNameAsc(Integer age);
    List<Student> findByAgeOrderByNameDesc(Integer age);
    
    // Count, Delete, Exists
    long countByAge(Integer age);
    
    @Transactional
    void deleteByAge(Integer age);
    
    boolean existsByEmail(String email);
    
    // First, Top (limit results)
    Optional<Student> findFirstByOrderByAgeDesc();
    List<Student> findTop3ByOrderByAgeDesc();
    
    // Distinct
    List<Student> findDistinctByAge(Integer age);
    
    
    // ========== Custom JPQL Queries ==========
    
    // JPQL Query (works with entity names, not table names)
    @Query("SELECT s FROM Student s WHERE s.age > :age")
    List<Student> findStudentsOlderThan(@Param("age") Integer age);
    
    // JPQL with multiple parameters
    @Query("SELECT s FROM Student s WHERE s.name LIKE %:keyword% AND s.age BETWEEN :minAge AND :maxAge")
    List<Student> searchStudents(
        @Param("keyword") String keyword,
        @Param("minAge") Integer minAge,
        @Param("maxAge") Integer maxAge
    );
    
    // JPQL for specific fields (DTO projection)
    @Query("SELECT s.name, s.email FROM Student s WHERE s.age > :age")
    List<Object[]> findNameAndEmailByAge(@Param("age") Integer age);
    
    
    // ========== Native SQL Queries ==========
    
    // Native SQL (works with actual table/column names)
    @Query(value = "SELECT * FROM students WHERE age > :age", nativeQuery = true)
    List<Student> findStudentsUsingNativeQuery(@Param("age") Integer age);
    
    // Native SQL with complex joins
    @Query(value = """
        SELECT s.* FROM students s 
        INNER JOIN courses c ON s.id = c.student_id 
        WHERE c.course_name = :courseName
        """, nativeQuery = true)
    List<Student> findStudentsByCourse(@Param("courseName") String courseName);
    
    
    // ========== Modifying Queries ==========
    
    @Modifying
    @Transactional
    @Query("UPDATE Student s SET s.age = :newAge WHERE s.id = :id")
    int updateStudentAge(@Param("id") Long id, @Param("newAge") Integer newAge);
    
    @Modifying
    @Transactional
    @Query("DELETE FROM Student s WHERE s.age < :age")
    int deleteStudentsYoungerThan(@Param("age") Integer age);
}
```

### Query Method Keywords Reference:

<img width="811" height="813" alt="image" src="https://github.com/user-attachments/assets/16b6c7ed-1a99-4430-85ac-b0749d940e32" />
<img width="816" height="296" alt="image" src="https://github.com/user-attachments/assets/1fde8ca1-fb71-4045-8893-771a186e4ae2" />




----------

## Complete Working Example

Let's build a complete Spring Boot application with JPA.

### Project Structure:

```
my-jpa-app/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           ├── MyJpaApplication.java
│   │   │           ├── model/
│   │   │           │   └── Student.java
│   │   │           ├── repository/
│   │   │           │   └── StudentRepository.java
│   │   │           ├── service/
│   │   │           │   └── StudentService.java
│   │   │           └── controller/
│   │   │               └── StudentController.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
└── pom.xml
```

### 1.  **pom.xml**  (Maven Dependencies)

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>my-jpa-app</artifactId>
    <version>1.0.0</version>
    <name>my-jpa-app</name>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starter Data JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- Spring Boot Starter Web (for REST APIs) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- MySQL Driver -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- H2 Database (for testing/development) -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok (optional, reduces boilerplate) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Spring Boot Starter Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### 2.  **application.properties**

properties

```properties
# Application Name
spring.application.name=my-jpa-app

# Server Port
server.port=8080

# ========== Database Configuration ==========

# For H2 In-Memory Database (Development/Testing)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# For MySQL Database (Production)
# spring.datasource.url=jdbc:mysql://localhost:3306/student_db
# spring.datasource.username=root
# spring.datasource.password=yourpassword
# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ========== JPA/Hibernate Configuration ==========

# Hibernate DDL mode (create, create-drop, update, validate, none)
# create: Drop and create tables on startup
# create-drop: Drop tables on shutdown
# update: Update schema if needed
# validate: Only validate schema
# none: Do nothing
spring.jpa.hibernate.ddl-auto=update

# Show SQL in console
spring.jpa.show-sql=true

# Format SQL (makes it readable)
spring.jpa.properties.hibernate.format_sql=true

# Show SQL parameters
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Hibernate dialect (auto-detected, but can be specified)
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# Naming strategy (how Java names map to database names)
# physical-strategy: snake_case (studentName -> student_name)
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# ========== Connection Pool Configuration ==========
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
```

### 3.  **Student.java**  (Entity)

java

```java
package com.example.model;

import jakarta.persistence.*;
import java.time.LocalDate;
import java.util.Objects;

@Entity
@Table(name = "students")
public class Student {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "email", unique = true)
    private String email;
    
    @Column(name = "age")
    private Integer age;
    
    @Column(name = "enrollment_date")
    private LocalDate enrollmentDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private StudentStatus status;
    
    // Constructors
    public Student() {
        this.enrollmentDate = LocalDate.now();
        this.status = StudentStatus.ACTIVE;
    }
    
    public Student(String name, String email, Integer age) {
        this();
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public Integer getAge() {
        return age;
    }
    
    public void setAge(Integer age) {
        this.age = age;
    }
    
    public LocalDate getEnrollmentDate() {
        return enrollmentDate;
    }
    
    public void setEnrollmentDate(LocalDate enrollmentDate) {
        this.enrollmentDate = enrollmentDate;
    }
    
    public StudentStatus getStatus() {
        return status;
    }
    
    public void setStatus(StudentStatus status) {
        this.status = status;
    }
    
    // equals and hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return Objects.equals(id, student.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    // toString
    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                ", enrollmentDate=" + enrollmentDate +
                ", status=" + status +
                '}';
    }
    
    // Enum for Student Status
    public enum StudentStatus {
        ACTIVE, INACTIVE, GRADUATED, SUSPENDED
    }
}
```

### 4.  **StudentRepository.java**

java

```java
package com.example.repository;

import com.example.model.Student;
import com.example.model.Student.StudentStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Find by email
    Optional<Student> findByEmail(String email);
    
    // Find by name (case-insensitive)
    List<Student> findByNameIgnoreCase(String name);
    
    // Find by age range
    List<Student> findByAgeBetween(Integer minAge, Integer maxAge);
    
    // Find by status
    List<Student> findByStatus(StudentStatus status);
    
    // Find by name containing keyword
    List<Student> findByNameContainingIgnoreCase(String keyword);
    
    // Custom JPQL query
    @Query("SELECT s FROM Student s WHERE s.age > :age ORDER BY s.name ASC")
    List<Student> findStudentsOlderThan(@Param("age") Integer age);
    
    // Count by status
    long countByStatus(StudentStatus status);
    
    // Check if email exists
    boolean existsByEmail(String email);
}
```

### 5.  **StudentService.java**

java

```java
package com.example.service;

import com.example.model.Student;
import com.example.model.Student.StudentStatus;
import com.example.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class StudentService {
    
    private final StudentRepository studentRepository;
    
    @Autowired
    public StudentService(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }
    
    // Create or Update
    public Student saveStudent(Student student) {
        return studentRepository.save(student);
    }
    
    // Read - Find by ID
    public Optional<Student> findById(Long id) {
        return studentRepository.findById(id);
    }
    
    // Read - Find all
    public List<Student> findAllStudents() {
        return studentRepository.findAll();
    }
    
    // Read - Find by email
    public Optional<Student> findByEmail(String email) {
        return studentRepository.findByEmail(email);
    }
    
    // Read - Search by name
    public List<Student> searchByName(String keyword) {
        return studentRepository.findByNameContainingIgnoreCase(keyword);
    }
    
    // Read - Find by age range
    public List<Student> findByAgeRange(Integer minAge, Integer maxAge) {
        return studentRepository.findByAgeBetween(minAge, maxAge);
    }
    
    // Read - Find active students
    public List<Student> findActiveStudents() {
        return studentRepository.findByStatus(StudentStatus.ACTIVE);
    }
    
    // Update
    public Student updateStudent(Long id, Student updatedStudent) {
        return studentRepository.findById(id)
                .map(student -> {
                    student.setName(updatedStudent.getName());
                    student.setEmail(updatedStudent.getEmail());
                    student.setAge(updatedStudent.getAge());
                    student.setStatus(updatedStudent.getStatus());
                    return studentRepository.save(student);
                })
                .orElseThrow(() -> new RuntimeException("Student not found with id: " + id));
    }
    
    // Delete
    public void deleteStudent(Long id) {
        studentRepository.deleteById(id);
    }
    
    // Check if email exists
    public boolean isEmailTaken(String email) {
        return studentRepository.existsByEmail(email);
    }
    
    // Get total count
    public long getTotalStudentCount() {
        return studentRepository.count();
    }
    
    // Get count by status
    public long getCountByStatus(StudentStatus status) {
        return studentRepository.countByStatus(status);
    }
}
```

### 6.  **StudentController.java**  (REST API)

java

```java
package com.example.controller;

import com.example.model.Student;
import com.example.model.Student.StudentStatus;
import com.example.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/students")
public class StudentController {
    
    private final StudentService studentService;
    
    @Autowired
    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }
    
    // CREATE - Add new student
    @PostMapping
    public ResponseEntity<Student> createStudent(@RequestBody Student student) {
        Student saved = studentService.saveStudent(student);
        return new ResponseEntity<>(saved, HttpStatus.CREATED);
    }
    
    // READ - Get all students
    @GetMapping
    public ResponseEntity<List<Student>> getAllStudents() {
        List<Student> students = studentService.findAllStudents();
        return ResponseEntity.ok(students);
    }
    
    // READ - Get student by ID
    @GetMapping("/{id}")
    public ResponseEntity<Student> getStudentById(@PathVariable Long id) {
        return studentService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    // READ - Search by name
    @GetMapping("/search")
    public ResponseEntity<List<Student>> searchStudents(@RequestParam String keyword) {
        List<Student> students = studentService.searchByName(keyword);
        return ResponseEntity.ok(students);
    }
    
    // READ - Get active students
    @GetMapping("/active")
    public ResponseEntity<List<Student>> getActiveStudents() {
        List<Student> students = studentService.findActiveStudents();
        return ResponseEntity.ok(students);
    }
    
    // READ - Get by age range
    @GetMapping("/age-range")
    public ResponseEntity<List<Student>> getByAgeRange(
            @RequestParam Integer minAge,
            @RequestParam Integer maxAge) {
        List<Student> students = studentService.findByAgeRange(minAge, maxAge);
        return ResponseEntity.ok(students);
    }
    
    // UPDATE - Update student
    @PutMapping("/{id}")
    public ResponseEntity<Student> updateStudent(
            @PathVariable Long id,
            @RequestBody Student student) {
        try {
            Student updated = studentService.updateStudent(id, student);
            return ResponseEntity.ok(updated);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    // DELETE - Delete student
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return ResponseEntity.noContent().build();
    }
    
    // GET - Check if email exists
    @GetMapping("/exists")
    public ResponseEntity<Boolean> checkEmailExists(@RequestParam String email) {
        boolean exists = studentService.isEmailTaken(email);
        return ResponseEntity.ok(exists);
    }
    
    // GET - Get total count
    @GetMapping("/count")
    public ResponseEntity<Long> getTotalCount() {
        long count = studentService.getTotalStudentCount();
        return ResponseEntity.ok(count);
    }
}
```

### 7.  **MyJpaApplication.java**  (Main Application)

java

```java
package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyJpaApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(MyJpaApplication.java, args);
        System.out.println("Application started successfully!");
        System.out.println("H2 Console: http://localhost:8080/h2-console");
        System.out.println("API Base URL: http://localhost:8080/api/students");
    }
}
```

----------

## Testing the Application

### Using cURL or Postman:

bash

```bash
# 1. CREATE - Add new student
curl -X POST http://localhost:8080/api/students \
  -H "Content-Type: application/json" \
  -d '{"name":"John Doe","email":"john@example.com","age":20}'

# 2. GET - Get all students
curl http://localhost:8080/api/students

# 3. GET - Get student by ID
curl http://localhost:8080/api/students/1

# 4. GET - Search by name
curl "http://localhost:8080/api/students/search?keyword=john"

# 5. GET - Get active students
curl http://localhost:8080/api/students/active

# 6. GET - Get by age range
curl "http://localhost:8080/api/students/age-range?minAge=18&maxAge=25"

# 7. UPDATE - Update student
curl -X PUT http://localhost:8080/api/students/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"John Updated","email":"john@example.com","age":21,"status":"ACTIVE"}'

# 8. DELETE - Delete student
curl -X DELETE http://localhost:8080/api/students/1

# 9. GET - Check if email exists
curl "http://localhost:8080/api/students/exists?email=john@example.com"

# 10. GET - Get total count
curl http://localhost:8080/api/students/count
```

----------

## Summary & Key Takeaways

### JPA Flow Visualization:

```
┌──────────────────────────────────────────────────────────┐
│                    Your Code                             │
│  studentRepository.save(student);                        │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│              Spring Data JPA                             │
│  (Implements repository methods automatically)           │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│                JPA Specification                         │
│  (Defines what should happen)                            │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│             Hibernate (ORM)                              │
│  (Translates Java objects to SQL)                        │
└────────────────────┬─────────────────────────────────────┘
                     │
                SQL Query
                     │
┌────────────────────▼─────────────────────────────────────┐
│                 Database                                 │
│  INSERT INTO students VALUES (...)                       │
└──────────────────────────────────────────────────────────┘
```

### Remember:

1.  **JPA**  = Specification (rulebook)
2.  **Hibernate**  = Implementation (actual tool)
3.  **Spring Data JPA**  = Convenience layer (makes JPA easier)
4.  **Entity**  = Java class representing database table
5.  **Repository**  = Interface for database operations (no code needed!)

### Best Practices:

-   Use  `@Transactional`  for methods that modify data
-   Use  `FetchType.LAZY`  for relationships to avoid performance issues
-   Always define  `equals()`  and  `hashCode()`  for entities
-   Use DTOs for API responses (don't expose entities directly)
-   Handle exceptions properly (entity not found, constraint violations)
-   Use connection pooling (HikariCP is default in Spring Boot)
-   Enable SQL logging during development, disable in production

## Key Concepts Summary

### 1. **Repository Hierarchy**

```
Repository (Marker Interface)
    ↓
CrudRepository (Basic CRUD)
    ↓
PagingAndSortingRepository (+ Pagination & Sorting)
    ↓
JpaRepository (+ JPA specific methods)
```

### 2. **When to Use Each Repository**



|  Repository    | Use Case              |
|  ----------    |---------              |
|CrudRepository  |Simple CRUD operations |
| PagingAndSortingRepository  |Need pagination/sorting |
| JpaRepository |   **Best choice** - Full JPA features  |

### 3. **Query Method Naming Convention**

```
findBy + Property + Condition + Connector + Property + Condition + OrderBy + Property + Direction

Example:
findByNameContainingAndAgeGreaterThanOrderByCreatedDateDesc
  │     │          │      │            │           │      │
  │     │          │      │            │           │      └─ Direction
  │     │          │      │            │           └─ Sort Property
  │     │          │      │            └─ OrderBy Keyword
  │     │          │      └─ Second Condition
  │     │          └─ Connector (And/Or)
  │     └─ First Condition
  └─ Action (find/read/query/get/count)
```

### 4. **Transaction Best Practices**

java

```java
// Always use @Transactional for:
// 1. Methods that modify data
// 2. Methods with multiple database operations
// 3. Methods that should rollback together

@Transactional  // Default: readOnly=false, rollbackFor=RuntimeException
public void createOrder(Order order) {
    // Multiple operations - all or nothing
}

@Transactional(readOnly = true)  // Performance optimization
public List<Order> getOrders() {
    // Read-only operations
}
```

### 5. **Performance Tips**

java

```java
// ❌ BAD: N+1 Query Problem
List<User> users = userRepository.findAll();
for (User user : users) {
    user.getOrders().size();  // Separate query for each user!
}

// ✅ GOOD: Fetch Join
@Query("SELECT u FROM User u LEFT JOIN FETCH u.orders")
List<User> findAllWithOrders();

// ✅ GOOD: Batch operations
userRepository.deleteAllInBatch(users);  // Single SQL statement

// ✅ GOOD: Pagination for large datasets
Page<User> page = userRepository.findAll(PageRequest.of(0, 20));
```

### 6. **Common Pitfalls to Avoid**

java

```java
// ❌ Don't forget @Transactional on modifying queries
@Modifying
@Query("UPDATE User u SET u.name = :name")
int updateName(@Param("name") String name);  // Will fail!

// ✅ Always add @Transactional
@Modifying
@Transactional
@Query("UPDATE User u SET u.name = :name")
int updateName(@Param("name") String name);

// ❌ Don't use findAll() for large tables
List<User> allUsers = userRepository.findAll();  // Memory issue!

// ✅ Use pagination
Page<User> page = userRepository.findAll(PageRequest.of(0, 100));

// ❌ Don't access lazy collections outside transaction
@Transactional
public User getUser(Long id) {
    return userRepository.findById(id).orElse(null);
}
// Later: user.getOrders() → LazyInitializationException!

// ✅ Initialize inside transaction or use EAGER fetch
@Transactional
public User getUserWithOrders(Long id) {
    User user = userRepository.findById(id).orElse(null);
    user.getOrders().size();  // Initialize here
    return user;
}
```

----------

## Memory and Performance Visualizations

### 1. **Lazy vs Eager Loading**

```
LAZY Loading (Default for @OneToMany, @ManyToMany):
┌──────────────────────────────┐
│ Initial Query                │
│ SELECT * FROM users WHERE... │
└──────────────┬───────────────┘
               │
               ▼
┌──────────────────────────────┐
│ User Object Loaded           │
│ orders = ProxyCollection     │  ← Not loaded yet
└──────────────┬───────────────┘
               │
               │ Access: user.getOrders()
               ▼
┌──────────────────────────────┐
│ Second Query Executed        │
│ SELECT * FROM orders         │
│ WHERE user_id = ?            │
└──────────────────────────────┘

EAGER Loading:
┌──────────────────────────────┐
│ Single Query with JOIN       │
│ SELECT u.*, o.*              │
│ FROM users u                 │
│ LEFT JOIN orders o ON...     │
└──────────────┬───────────────┘
               │
               ▼
┌──────────────────────────────┐
│ User + Orders Both Loaded    │
└──────────────────────────────┘
```

### 2. **Connection Pool Management**

```
Application Threads          Connection Pool           Database
┌────────┐                  ┌──────────────┐         ┌─────────┐
│Thread 1│─────Request─────►│ Conn 1 (use) │────────►│         │
├────────┤                  ├──────────────┤         │  MySQL  │
│Thread 2│─────Request─────►│ Conn 2 (use) │────────►│         │
├────────┤                  ├──────────────┤         │         │
│Thread 3│─────Waiting─────►│ Conn 3 (use) │────────►│         │
├────────┤                  ├──────────────┤         └─────────┘
│Thread 4│─────Waiting─────►│ Conn 4 (avl) │
└────────┘                  ├──────────────┤
                            │ Conn 5 (avl) │
                            └──────────────┘
                            Max Pool: 10
                            Active: 3
                            Idle: 2
```

### 3. **Pagination Memory Impact**

```
Without Pagination:
Database: 1,000,000 rows
         │
         │ SELECT * FROM users
         ▼
Application Memory: 1,000,000 objects loaded 💥 OutOfMemoryError!

With Pagination:
Database: 1,000,000 rows
         │
         │ SELECT * FROM users LIMIT 20 OFFSET 0
         ▼
Application Memory: 20 objects loaded ✅ Efficient!
         │
         │ User navigates to page 2
         │ SELECT * FROM users LIMIT 20 OFFSET 20
         ▼
Application Memory: 20 objects loaded ✅ Still efficient!
```

----------

``` java
// Spring generates implementation automatically!
List<User> findByName(String name);

List<User> findByEmail(String email);

List<User> findByAgeGreaterThan(Integer age);
```

