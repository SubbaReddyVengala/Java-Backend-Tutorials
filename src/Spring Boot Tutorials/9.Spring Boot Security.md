# Spring Boot Security: Complete Learning Guide

## Table of Contents

1.  Importance of Security in Applications
2.  Authentication vs Authorization
3.  Basic Authentication
4.  Custom Security Configuration
5.  Database Security
6.  Security with Encryption
7.  JWT Introduction
8.  JWT Authentication
9.  OAuth Introduction

----------

## 1. Importance of Security in Applications 

### 🎯 Why Security Matters

**Analogy:**  Think of your application as a house. Would you leave your front door wide open with all your valuables visible? Of course not! Similarly, applications need protection.

### Real-World Consequences of Poor Security

```
Without Security:
├── Data Breaches → Customer trust lost
├── Financial Loss → Lawsuits, fines
├── Reputation Damage → Business closure
└── Legal Issues → GDPR, compliance violations
```

### Key Security Principles

1.  **Confidentiality**  - Only authorized users access data
2.  **Integrity**  - Data remains unaltered
3.  **Availability**  - System remains accessible
4.  **Non-repudiation**  - Actions cannot be denied

**Memory Tip:**  Remember  **CIA-N**  (Confidentiality, Integrity, Availability, Non-repudiation)

----------

## 2. Authentication vs Authorization 

### 🔑 Authentication: "Who are you?"

**Analogy:**  Showing your ID card at a building entrance. You prove your identity.

```
Authentication Process:
User → Provides Credentials → System Verifies → Identity Confirmed
```

**Example:**

java

```java
// User proves identity
Username: john@example.com
Password: secret123
→ System checks: "Are you really John?"
```

### 🚪 Authorization: "What can you do?"

**Analogy:**  After entering the building (authenticated), your access card only opens certain doors. You have specific permissions.

```
Authorization Process:
Authenticated User → Requests Resource → System Checks Permissions → Access Granted/Denied
```

**Example:**

java

```java
// User has identity (authenticated)
// But can they access admin panel? (authorization)
User: John (Role: USER)
Request: /admin/delete-users
→ System checks: "Does John have ADMIN role?"
→ Result: Access Denied!
```

### Visual Comparison

```
┌─────────────────┐      ┌──────────────────┐
│ Authentication  │      │  Authorization   │
├─────────────────┤      ├──────────────────┤
│ Login Process   │      │ Permission Check │
│ Verify Identity │      │ Role-Based Access│
│ Credentials     │      │ Resources        │
│ "Who are you?"  │      │ "What can you do?│
└─────────────────┘      └──────────────────┘
```

**Memory Technique:**

-   **AuthentiCATION**  = Verification (ends in -CATION like verification)
-   **AuthoriZATION**  = Permission (Z for "Zone" access)

----------

## 3. Basic Authentication 

### 🔓 What is Basic Authentication?

**Analogy:**  Like showing your ID card every time you enter a building - simple but repetitive.

Basic Auth sends username:password  (Base64 encoded) in HTTP header with  **every request**.

### How It Works

```
Client Request:
GET /api/users HTTP/1.1
Authorization: Basic am9objpzZWNyZXQxMjM=
                      ↑
                Base64(john:secret123)

Server Response:
1. Decode header
2. Verify credentials
3. Grant/Deny access
```

### Spring Boot Implementation

#### Step 1: Add Dependency

xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

#### Step 2: Configuration (Auto-configured)

**Default behavior:**  Spring Security automatically secures all endpoints!

properties

```properties
# application.properties
spring.security.user.name=admin
spring.security.user.password=admin123
```

#### Step 3: Create Controller

java

```java
@RestController
@RequestMapping("/api")
public class HelloController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, Authenticated User!";
    }
    
    @GetMapping("/public")
    public String publicEndpoint() {
        return "This is public";
    }
}
```

#### Step 4: Custom Configuration

java

```java
@Configuration
@EnableWebSecurity
public class BasicSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public").permitAll()
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults());
        
        return http.build();
    }
    
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
            .username("john")
            .password("{noop}password123") // {noop} = no encoding
            .roles("USER")
            .build();
            
        UserDetails admin = User.builder()
            .username("admin")
            .password("{noop}admin123")
            .roles("ADMIN", "USER")
            .build();
            
        return new InMemoryUserDetailsManager(user, admin);
    }
}
```

### Testing Basic Auth

bash

```bash
# Using curl
curl -u john:password123 http://localhost:8080/api/hello

# Using Postman
# Authorization Tab → Type: Basic Auth
# Username: john
# Password: password123
```

### Pros and Cons

```
✅ Pros:
- Simple to implement
- Stateless
- Supported everywhere

❌ Cons:
- Credentials in every request
- Vulnerable without HTTPS
- No logout mechanism
- Password visible in Base64
```

**Security Note:**  Always use HTTPS with Basic Auth!

----------

## 4. Custom Security Configuration 

### 🎨 Building Custom Security

**Analogy:**  Default security is like a standard lock. Custom security is like designing your own security system with cameras, motion sensors, and specific access rules.

### Architecture

```
Request → Security Filter Chain → Authentication → Authorization → Resource
           ↓
    [Custom Filters]
    [Custom Auth Logic]
    [Custom Access Rules]
```

### Custom UserDetailsService Implementation

java

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) 
            throws UsernameNotFoundException {
        
        // Load user from database
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                new UsernameNotFoundException("User not found: " + username));
        
        // Convert to Spring Security UserDetails
        return org.springframework.security.core.userdetails.User
            .builder()
            .username(user.getUsername())
            .password(user.getPassword())
            .roles(user.getRoles().toArray(new String[0]))
            .accountExpired(user.isAccountExpired())
            .accountLocked(user.isAccountLocked())
            .credentialsExpired(user.isCredentialsExpired())
            .disabled(user.isDisabled())
            .build();
    }
}
```

### Custom Authentication Provider

java

```java
@Component
public class CustomAuthenticationProvider implements AuthenticationProvider {
    
    @Autowired
    private CustomUserDetailsService userDetailsService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Override
    public Authentication authenticate(Authentication authentication) 
            throws AuthenticationException {
        
        String username = authentication.getName();
        String password = authentication.getCredentials().toString();
        
        // Load user
        UserDetails user = userDetailsService.loadUserByUsername(username);
        
        // Verify password
        if (passwordEncoder.matches(password, user.getPassword())) {
            return new UsernamePasswordAuthenticationToken(
                user, password, user.getAuthorities()
            );
        }
        
        throw new BadCredentialsException("Invalid credentials");
    }
    
    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class
            .isAssignableFrom(authentication);
    }
}
```

### Role-Based Access Control

java

```java
@Configuration
public class CustomSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                // Public endpoints
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/register").permitAll()
                
                // USER role required
                .requestMatchers("/api/user/**").hasRole("USER")
                
                // ADMIN role required
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                
                // Multiple roles
                .requestMatchers("/api/reports/**")
                    .hasAnyRole("ADMIN", "MANAGER")
                
                // Specific authorities
                .requestMatchers("/api/delete/**")
                    .hasAuthority("DELETE_PRIVILEGE")
                
                // Everything else requires authentication
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable()); // Disable for API
        
        return http.build();
    }
}
```

### Method-Level Security

java

```java
@Configuration
@EnableMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
    // Configuration
}

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // Only ADMIN can access
    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return productService.save(product);
    }
    
    // Owner or ADMIN can access
    @PreAuthorize("hasRole('ADMIN') or #username == authentication.name")
    @GetMapping("/{username}/orders")
    public List<Order> getUserOrders(@PathVariable String username) {
        return orderService.findByUsername(username);
    }
    
    // Custom SpEL expression
    @PreAuthorize("@securityService.canAccessProduct(#id, authentication)")
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
}
```

### Custom Security Service

java

```java
@Service
public class SecurityService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public boolean canAccessProduct(Long productId, Authentication auth) {
        UserDetails user = (UserDetails) auth.getPrincipal();
        Product product = productRepository.findById(productId).orElse(null);
        
        if (product == null) return false;
        
        // Admin can access everything
        if (user.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))) {
            return true;
        }
        
        // User can only access their own products
        return product.getOwner().equals(user.getUsername());
    }
}
```

----------

## 5. Database Security 

### 🗄️ Storing Credentials Securely

**Analogy:**  Never write passwords on sticky notes! Store them in a safe with a combination lock that even you don't know (one-way encryption).

### Entity Design

java

```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String password; // Will store encrypted password
    
    @Column(nullable = false)
    private String email;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", 
        joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    private Set<String> roles = new HashSet<>();
    
    private boolean accountNonExpired = true;
    private boolean accountNonLocked = true;
    private boolean credentialsNonExpired = true;
    private boolean enabled = true;
    
    // Getters and setters
}
```

### Repository

java

```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    boolean existsByUsername(String username);
}
```

### Password Encoder Configuration

java

```java
@Configuration
public class PasswordConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // BCrypt is the recommended algorithm
        return new BCryptPasswordEncoder(12); // 12 rounds of hashing
    }
}
```

### User Registration Service

java

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public User registerUser(UserRegistrationDto dto) {
        // Check if username exists
        if (userRepository.existsByUsername(dto.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        
        // Create new user
        User user = new User();
        user.setUsername(dto.getUsername());
        user.setEmail(dto.getEmail());
        
        // Encrypt password before saving
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        
        // Set default role
        user.setRoles(Set.of("USER"));
        
        return userRepository.save(user);
    }
    
    public boolean changePassword(String username, 
                                  String oldPassword, 
                                  String newPassword) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        // Verify old password
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new RuntimeException("Invalid old password");
        }
        
        // Set new password
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
        
        return true;
    }
}
```

### Database UserDetailsService

java

```java
@Service
public class DatabaseUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) 
            throws UsernameNotFoundException {
        
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                new UsernameNotFoundException("User not found: " + username));
        
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPassword(), // Already encrypted
            user.isEnabled(),
            user.isAccountNonExpired(),
            user.isCredentialsNonExpired(),
            user.isAccountNonLocked(),
            getAuthorities(user.getRoles())
        );
    }
    
    private Collection<? extends GrantedAuthority> getAuthorities(Set<String> roles) {
        return roles.stream()
            .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
            .collect(Collectors.toList());
    }
}
```

### Complete Security Configuration

java

```java
@Configuration
@EnableWebSecurity
public class DatabaseSecurityConfig {
    
    @Autowired
    private DatabaseUserDetailsService userDetailsService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/register", "/api/login").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable());
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder);
        return provider;
    }
}
```

### Password Storage Visualization

```
Plain Password: "mySecret123"
        ↓
BCrypt Encoder (12 rounds)
        ↓
Database: "$2a$12$KIXqT8YS3C6j9FZ.ZdxQXe7kVwH..."
        ↑
    61 characters
    Includes: algorithm, cost, salt, hash

Login Attempt: "mySecret123"
        ↓
BCrypt matches() → Compares
        ↓
✓ Match → Authenticated
```

----------

## 6. Security with Encryption 

### 🔐 Understanding Encryption

**Analogy:**

-   **Hashing**  = Shredding a document - cannot be reconstructed
-   **Encryption**  = Locking document in safe - can be unlocked with key

### Hashing vs Encryption

```
┌─────────────────┐          ┌──────────────────┐
│    HASHING      │          │   ENCRYPTION     │
├─────────────────┤          ├──────────────────┤
│ One-way         │          │ Two-way          │
│ Cannot decrypt  │          │ Can decrypt      │
│ For passwords   │          │ For data         │
│ BCrypt, SHA-256 │          │ AES, RSA         │
└─────────────────┘          └──────────────────┘
```

### Password Hashing (BCrypt)

java

```java
@Component
public class PasswordHashingDemo {
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public void demonstrateHashing() {
        String plainPassword = "myPassword123";
        
        // Hash password
        String hashedPassword = passwordEncoder.encode(plainPassword);
        System.out.println("Hashed: " + hashedPassword);
        // Output: $2a$12$Klj2k3lK...
        
        // Same password, different hash each time (due to salt)
        String hash2 = passwordEncoder.encode(plainPassword);
        System.out.println("Hash2: " + hash2);
        // Output: $2a$12$Xp9sk1kL... (Different!)
        
        // Verify password
        boolean matches = passwordEncoder.matches(plainPassword, hashedPassword);
        System.out.println("Matches: " + matches); // true
    }
}
```

### BCrypt Explained

```
BCrypt Structure:
$2a$12$KIXqT8YS3C6j9FZ.ZdxQXe7kVwH1234567890ABCDEF
 │  │  │                                              │
 │  │  └── Salt (random)              Hash (password hashed with salt)
 │  └────── Cost factor (2^12 = 4096 iterations)
 └───────── Algorithm version (2a = BCrypt)

Why BCrypt?
1. Slow by design (protects against brute force)
2. Automatic salt generation
3. Configurable cost factor
4. Industry standard
```

### Data Encryption (AES)

java

```java
@Component
public class EncryptionService {
    
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    @Value("${encryption.secret.key}")
    private String secretKey;
    
    private SecretKey getKey() {
        byte[] decodedKey = Base64.getDecoder().decode(secretKey);
        return new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
    }
    
    public String encrypt(String plainText) throws Exception {
        // Generate IV (Initialization Vector)
        byte[] iv = new byte[GCM_IV_LENGTH];
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        
        // Initialize cipher
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(
            GCM_TAG_LENGTH * 8, iv
        );
        cipher.init(Cipher.ENCRYPT_MODE, getKey(), parameterSpec);
        
        // Encrypt
        byte[] encryptedData = cipher.doFinal(plainText.getBytes());
        
        // Combine IV + encrypted data
        byte[] combined = new byte[iv.length + encryptedData.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encryptedData, 0, combined, iv.length, 
                        encryptedData.length);
        
        return Base64.getEncoder().encodeToString(combined);
    }
    
    public String decrypt(String encryptedText) throws Exception {
        byte[] decoded = Base64.getDecoder().decode(encryptedText);
        
        // Extract IV
        byte[] iv = new byte[GCM_IV_LENGTH];
        System.arraycopy(decoded, 0, iv, 0, iv.length);
        
        // Extract encrypted data
        byte[] encryptedData = new byte[decoded.length - GCM_IV_LENGTH];
        System.arraycopy(decoded, GCM_IV_LENGTH, encryptedData, 0, 
                        encryptedData.length);
        
        // Initialize cipher
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(
            GCM_TAG_LENGTH * 8, iv
        );
        cipher.init(Cipher.DECRYPT_MODE, getKey(), parameterSpec);
        
        // Decrypt
        byte[] decryptedData = cipher.doFinal(encryptedData);
        return new String(decryptedData);
    }
}
```

### Encrypting Sensitive Database Fields

java

```java
@Entity
public class CreditCard {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Convert(converter = CreditCardNumberConverter.class)
    private String cardNumber; // Will be encrypted
    
    @Convert(converter = StringEncryptionConverter.class)
    private String cvv; // Will be encrypted
    
    private String cardHolderName; // Plain text
}

@Component
public class CreditCardNumberConverter 
        implements AttributeConverter<String, String> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        try {
            return encryptionService.encrypt(attribute);
        } catch (Exception e) {
            throw new RuntimeException("Encryption failed", e);
        }
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        try {
            return encryptionService.decrypt(dbData);
        } catch (Exception e) {
            throw new RuntimeException("Decryption failed", e);
        }
    }
}
```

### Configuration

properties

```properties
# application.properties

# Generate with: 
# KeyGenerator keyGen = KeyGenerator.getInstance("AES");
# keyGen.init(256);
# String base64Key = Base64.getEncoder()
#   .encodeToString(keyGen.generateKey().getEncoded());
encryption.secret.key=YourBase64EncodedAES256KeyHere==

# Store in environment variable in production
# encryption.secret.key=${ENCRYPTION_KEY}
```

### Best Practices

java

```java
@Configuration
public class EncryptionConfig {
    
    // ✓ DO: Use strong algorithms
    // AES-256-GCM (encryption)
    // BCrypt, Argon2 (passwords)
    
    // ✗ DON'T: Use weak algorithms
    // DES, MD5, SHA1
    
    // ✓ DO: Store keys securely
    // - Environment variables
    // - Key management services (AWS KMS, Azure Key Vault)
    // - Hardware Security Modules (HSM)
    
    // ✗ DON'T: Hardcode keys in code
    
    // ✓ DO: Rotate keys regularly
    
    // ✓ DO: Use HTTPS for data in transit
}
```

----------

## 7. JWT Introduction
### 🎫 What is JWT?

**Analogy:**  JWT is like a concert wristband. Once you show your ID at entrance (authenticate), you get a wristband (JWT). This wristband grants you access to different areas without re-checking your ID.

### JWT Structure

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkw.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
│────────── HEADER ──────────│──────── PAYLOAD ───────│───────── SIGNATURE ──────────│
```

### Decoded JWT

json

```json
// HEADER
{
  "alg": "HS256",
  "typ": "JWT"
}

// PAYLOAD
{
  "sub": "john@example.com",
  "name": "John Doe",
  "roles": ["USER", "ADMIN"],
  "iat": 1516239022,
  "exp": 1516242622
}

// SIGNATURE
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### JWT Flow Visualization

```
1. LOGIN
   Client → Username/Password → Server
   
2. AUTHENTICATE
   Server → Verify Credentials → Database
   
3. GENERATE JWT
   Server → Create JWT (header + payload + signature)
   
4. RETURN TOKEN
   Server → JWT Token → Client
   
5. STORE TOKEN
   Client → Saves JWT (memory/storage)
   
6. SUBSEQUENT REQUESTS
   Client → Request + JWT in header → Server
   
7. VALIDATE TOKEN
   Server → Verify signature & expiry
   
8. GRANT ACCESS
   Server → Response → Client
```

### JWT vs Session Comparison

```
┌──────────────────────┐     ┌──────────────────────┐
│   SESSION-BASED      │     │      JWT-BASED       │
├──────────────────────┤     ├──────────────────────┤
│ State on Server      │     │ Stateless            │
│ Session Store needed │     │ No storage needed    │
│ Server memory usage  │     │ Scalable             │
│ Cannot share servers │     │ Works with any server│
│ Easy to revoke       │     │ Hard to revoke       │
└──────────────────────┘     └──────────────────────┘
```

### JWT Advantages

```
✅ Stateless
   - Server doesn't store sessions
   - Easy to scale horizontally

✅ Self-contained
   - All info in token
   - No database lookup needed

✅ Cross-domain
   - Works across different domains
   - Perfect for microservices

✅ Mobile-friendly
   - Easy to store in apps
   - No cookies needed
```

### JWT Disadvantages

```
❌ Cannot revoke easily
   - Token valid until expiry
   - Need blacklist mechanism

❌ Size
   - Larger than session ID
   - Sent with every request

❌ Security if stolen
   - Valid until expiry
   - Need short expiry times

❌ Payload visible
   - Base64 encoded, not encrypted
   - Don't store sensitive data
```

### JWT Claims Explained

java

```java
// Standard Claims (Registered)
{
    "iss": "issuer",           // Who created the token
    "sub": "subject",          // User identifier
    "aud": "audience",         // Who can use this token
    "exp": 1234567890,        // Expiration time
    "nbf": 1234567890,        // Not before time
    "iat": 1234567890,        // Issued at time
    "jti": "unique-id"        // JWT ID
}

// Public Claims (Custom)
{
    "roles": ["USER", "ADMIN"],
    "permissions": ["READ", "WRITE"],
    "email": "user@example.com"
}

// Private Claims (Your app-specific)
{
    "organization_id": 12345,
    "subscription_level": "premium",
    "features": ["feature1", "feature2"]
}
```

### Security Considerations

```
🔒 Best Practices:
1. Use HTTPS always
2. Short expiry time (15 min access, 7 days refresh)
3. Strong secret key (256-bit minimum)
4. Validate signature always
5. Check expiry time
6. Don't store sensitive data in payload
7. Use refresh tokens
8. Implement token blacklist for logout
```

----------

## 8. JWT Authentication 

### 🔧 Implementing JWT in Spring Boot

### Step 1: Add Dependencies

xml

```xml
<dependencies>
    <!-- Spring Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <!-- JWT Library -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

### Step 2: JWT Utility Class

java

```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration; // in milliseconds
    
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }
    
    // Generate JWT Token
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        
        // Add custom claims
        claims.put("roles", userDetails.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toList()));
        
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }
    
    // Extract username from token
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    // Extract expiration date
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    // Extract any claim
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }
    
    // Check if token is expired
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    // Validate token
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) 
                && !isTokenExpired(token));
    }
    
    // Extract roles from token
    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        return (List<String>) claims.get("roles");
    }
}
```

### Step 3: JWT Authentication Filter

java

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {
        
        // Extract JWT from Authorization header
        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String username;
        
        // Check if header contains Bearer token
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // Extract token (remove "Bearer " prefix)
        jwt = authHeader.substring(7);
        
        try {
            // Extract username from token
            username = jwtUtil.extractUsername(jwt);
            
            // If username exists and user is not authenticated yet
            if (username != null && 
                SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Load user details
                UserDetails userDetails = 
                    userDetailsService.loadUserByUsername(username);
                
                // Validate token
                if (jwtUtil.validateToken(jwt, userDetails)) {
                    // Create authentication object
                    UsernamePasswordAuthenticationToken authToken = 
                        new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities()
                        );
                    
                    // Set details
                    authToken.setDetails(
                        new WebAuthenticationDetailsSource()
                            .buildDetails(request)
                    );
                    
                    // Set authentication in context
                    SecurityContextHolder.getContext()
                        .setAuthentication(authToken);
                }
            }
        } catch (Exception e) {
            // Log error
            logger.error("Cannot set user authentication: {}", e.getMessage());
        }
        
        // Continue filter chain
        filterChain.doFilter(request, response);
    }
}
```

### Step 4: Authentication Request/Response DTOs

java

```java
// Login Request
@Data
public class LoginRequest {
    @NotBlank
    private String username;
    
    @NotBlank
    private String password;
}

// Login Response
@Data
@AllArgsConstructor
public class LoginResponse {
    private String token;
    private String type = "Bearer";
    private String username;
    private List<String> roles;
    
    public LoginResponse(String token, String username, List<String> roles) {
        this.token = token;
        this.username = username;
        this.roles = roles;
    }
}

// Refresh Token Request
@Data
public class RefreshTokenRequest {
    @NotBlank
    private String refreshToken;
}
```

### Step 5: Authentication Controller

java

```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/login")
    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest request) {
        try {
            // Authenticate user
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    request.getUsername(),
                    request.getPassword()
                )
            );
            
            // Set authentication in context
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            // Load user details
            UserDetails userDetails = 
                userDetailsService.loadUserByUsername(request.getUsername());
            
            // Generate JWT
            String jwt = jwtUtil.generateToken(userDetails);
            
            // Extract roles
            List<String> roles = userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());
            
            // Return response
            return ResponseEntity.ok(
                new LoginResponse(jwt, userDetails.getUsername(), roles)
            );
            
        } catch (AuthenticationException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body("Invalid username or password");
        }
    }
    
    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody UserRegistrationDto dto) {
        try {
            User user = userService.registerUser(dto);
            return ResponseEntity.ok("User registered successfully");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
    
    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request) {
        // For JWT, logout is handled client-side by removing token
        // Server-side: Add token to blacklist (optional)
        
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String jwt = authHeader.substring(7);
            // Add to blacklist
            // tokenBlacklistService.blacklistToken(jwt);
        }
        
        return ResponseEntity.ok("Logged out successfully");
    }
}
```

### Step 6: Security Configuration

java

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class JwtSecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthFilter, 
                UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

### Step 7: Configuration Properties

properties

```properties
# application.properties

# JWT Configuration
jwt.secret=YourBase64EncodedSecretKeyMinimum256BitsLongForHS256Algorithm
jwt.expiration=86400000
# 86400000 ms = 24 hours
# For production: use 900000 (15 minutes) for access token

# Generate secret key:
# import io.jsonwebtoken.SignatureAlgorithm;
# import io.jsonwebtoken.security.Keys;
# Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);
# String base64Key = Encoders.BASE64.encode(key.getEncoded());
```

### Step 8: Testing JWT Authentication

bash

```bash
# 1. Register User
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "john",
    "email": "john@example.com",
    "password": "password123"
  }'

# 2. Login
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "john",
    "password": "password123"
  }'

# Response:
# {
#   "token": "eyJhbGciOiJIUzI1NiJ9...",
#   "type": "Bearer",
#   "username": "john",
#   "roles": ["ROLE_USER"]
# }

# 3. Access Protected Endpoint
curl -X GET http://localhost:8080/api/users/profile \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9..."
```

### Refresh Token Implementation

java

```java
@Component
public class RefreshTokenService {
    
    @Autowired
    private RefreshTokenRepository refreshTokenRepository;
    
    @Value("${jwt.refresh.expiration}")
    private Long refreshExpiration; // 7 days
    
    public RefreshToken createRefreshToken(String username) {
        RefreshToken refreshToken = new RefreshToken();
        refreshToken.setUsername(username);
        refreshToken.setToken(UUID.randomUUID().toString());
        refreshToken.setExpiryDate(
            Instant.now().plusMillis(refreshExpiration)
        );
        
        return refreshTokenRepository.save(refreshToken);
    }
    
    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }
    
    public RefreshToken verifyExpiration(RefreshToken token) {
        if (token.getExpiryDate().compareTo(Instant.now()) < 0) {
            refreshTokenRepository.delete(token);
            throw new TokenRefreshException(
                "Refresh token expired. Please login again."
            );
        }
        return token;
    }
    
    public void deleteByUsername(String username) {
        refreshTokenRepository.deleteByUsername(username);
    }
}

@Entity
@Table(name = "refresh_tokens")
@Data
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String token;
    
    @Column(nullable = false)
    private String username;
    
    @Column(nullable = false)
    private Instant expiryDate;
}
```

### Enhanced Auth Controller with Refresh Token

java

```java
@PostMapping("/refresh")
public ResponseEntity<?> refreshToken(@Valid @RequestBody RefreshTokenRequest request) {
    String requestRefreshToken = request.getRefreshToken();
    
    return refreshTokenService.findByToken(requestRefreshToken)
        .map(refreshTokenService::verifyExpiration)
        .map(RefreshToken::getUsername)
        .map(username -> {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            String newAccessToken = jwtUtil.generateToken(userDetails);
            
            return ResponseEntity.ok(new LoginResponse(
                newAccessToken,
                username,
                userDetails.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toList())
            ));
        })
        .orElseThrow(() -> 
            new TokenRefreshException("Refresh token not found"));
}
```

### Token Blacklist for Logout

java

```java
@Service
public class TokenBlacklistService {
    
    // In-memory cache (use Redis in production)
    private final Set<String> blacklist = ConcurrentHashMap.newKeySet();
    
    @Autowired
    private JwtUtil jwtUtil;
    
    public void blacklistToken(String token) {
        blacklist.add(token);
        
        // Schedule removal after token expiry
        Date expiration = jwtUtil.extractExpiration(token);
        long delay = expiration.getTime() - System.currentTimeMillis();
        
        if (delay > 0) {
            scheduleTokenRemoval(token, delay);
        }
    }
    
    public boolean isBlacklisted(String token) {
        return blacklist.contains(token);
    }
    
    private void scheduleTokenRemoval(String token, long delay) {
        new Thread(() -> {
            try {
                Thread.sleep(delay);
                blacklist.remove(token);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}

// Update JWT Filter to check blacklist
if (jwtUtil.validateToken(jwt, userDetails) && 
    !tokenBlacklistService.isBlacklisted(jwt)) {
    // Authenticate user
}
```

### JWT Flow Diagram

```
┌──────────┐                          ┌──────────┐
│  Client  │                          │  Server  │
└────┬─────┘                          └────┬─────┘
     │                                     │
     │ 1. POST /login                      │
     │    {username, password}             │
     ├────────────────────────────────────>│
     │                                     │
     │                          2. Validate credentials
     │                             with database
     │                                     │
     │                          3. Generate JWT
     │                             + Refresh Token
     │                                     │
     │ 4. Return tokens                    │
     │<────────────────────────────────────┤
     │                                     │
     │ 5. Store tokens                     │
     │    (memory/storage)                 │
     │                                     │
     │ 6. GET /api/resource                │
     │    Authorization: Bearer <JWT>      │
     ├────────────────────────────────────>│
     │                                     │
     │                          7. Validate JWT
     │                             - Verify signature
     │                             - Check expiry
     │                             - Extract user info
     │                                     │
     │ 8. Return resource                  │
     │<────────────────────────────────────┤
     │                                     │
     │ 9. Token expired                    │
     │    POST /refresh                    │
     │    {refreshToken}                   │
     ├────────────────────────────────────>│
     │                                     │
     │                          10. Validate refresh token
     │                              Generate new JWT
     │                                     │
     │ 11. Return new JWT                  │
     │<────────────────────────────────────┤
     │                                     │
```

----------

## 9. OAuth 2.0 Introduction 

### 🔐 What is OAuth 2.0?

**Analogy:**  OAuth is like valet parking. You give the valet a special key (token) that can only start the car and drive it to the parking spot, but cannot open the trunk or glove compartment. The valet (third-party app) has limited access to your car (resources).

### OAuth 2.0 Core Concepts

```
┌─────────────────────────────────────────────────────┐
│                    OAuth 2.0 Roles                  │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Resource Owner (User)                              │
│       │                                             │
│       │ Owns the protected resources                │
│       │                                             │
│  Client (Application)                               │
│       │                                             │
│       │ Wants to access resources                   │
│       │                                             │
│  Authorization Server                               │
│       │                                             │
│       │ Issues tokens after authentication          │
│       │                                             │
│  Resource Server (API)                              │
│       │                                             │
│       └─ Hosts the protected resources              │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### OAuth 2.0 vs JWT vs Basic Auth

```
┌────────────────┬──────────────┬──────────────┬─────────────┐
│    Feature     │  Basic Auth  │     JWT      │   OAuth 2.0 │
├────────────────┼──────────────┼──────────────┼─────────────┤
│ Use Case       │ Simple apps  │ APIs, SPAs   │ Third-party │
│ Credentials    │ Every request│ Token once   │ Delegated   │
│ Complexity     │ Low          │ Medium       │ High        │
│ Security       │ Basic        │ Good         │ Excellent   │
│ Revocation     │ N/A          │ Difficult    │ Easy        │
│ Scope Control  │ No           │ Limited      │ Yes         │
└────────────────┴──────────────┴──────────────┴─────────────┘
```

### OAuth 2.0 Grant Types

#### 1. Authorization Code Flow (Most Secure)

**Use Case:**  Web applications with backend server

```
┌──────┐                                      ┌─────────────┐
│ User │                                      │  Client App │
└──┬───┘                                      └──────┬──────┘
   │                                                 │
   │ 1. Click "Login with Google"                   │
   │<───────────────────────────────────────────────┤
   │                                                 │
   │ 2. Redirect to Authorization Server             │
   ├────────────────────────────────────────────────>│
   │    https://auth.server.com/authorize?           │
   │    client_id=ABC&redirect_uri=...&              │
   │    response_type=code&scope=read               │
   │                                                 │
┌──▼──────────────────┐                             │
│ Authorization Server│                             │
└──┬──────────────────┘                             │
   │                                                 │
   │ 3. Show login page                              │
   │ 4. User authenticates                           │
   │ 5. Show consent screen                          │
   │ 6. User grants permission                       │
   │                                                 │
   │ 7. Redirect with Authorization Code             │
   ├────────────────────────────────────────────────>│
   │    https://client.com/callback?code=XYZ        │
   │                                                 │
   │                  8. Exchange code for token     │
   │                     POST /token                 │
   │                     code=XYZ                    │
   │                     client_id=ABC               │
   │                     client_secret=SECRET        │
   │<────────────────────────────────────────────────┤
   │                                                 │
   │ 9. Return Access Token                          │
   ├────────────────────────────────────────────────>│
   │    {                                            │
   │      "access_token": "...",                     │
   │      "token_type": "Bearer",                    │
   │      "expires_in": 3600,                        │
   │      "refresh_token": "..."                     │
   │    }                                            │
   │                                                 │
   │                  10. Access protected resource  │
   │                      GET /api/user              │
   │                      Authorization: Bearer ...  │
   │<────────────────────────────────────────────────┤
```

#### 2. Client Credentials Flow

**Use Case:**  Machine-to-machine communication, microservices

```
┌──────────────┐                        ┌─────────────────────┐
│ Client (API) │                        │ Authorization Server│
└──────┬───────┘                        └──────────┬──────────┘
       │                                           │
       │ 1. Request token with client credentials  │
       │    POST /oauth/token                      │
       │    grant_type=client_credentials          │
       │    client_id=ABC                          │
       │    client_secret=SECRET                   │
       ├──────────────────────────────────────────>│
       │                                           │
       │                                2. Validate client
       │                                           │
       │ 3. Return access token                    │
       │<──────────────────────────────────────────┤
       │    {                                      │
       │      "access_token": "...",               │
       │      "token_type": "Bearer",              │
       │      "expires_in": 3600                   │
       │    }                                      │
       │                                           │
```

#### 3. Implicit Flow (Deprecated - Don't Use)

**Note:**  Replaced by Authorization Code Flow + PKCE for SPAs

#### 4. Resource Owner Password Credentials (Legacy)

**Use Case:**  Highly trusted applications only (your own apps)

```
User → Provides credentials → Client App → Sends to Auth Server → Returns token
```

### OAuth 2.0 Scopes

**Analogy:**  Scopes are like permission slips. When you authorize an app, you specify what it can access.

java

```java
// Different scopes for different access levels
"read:user"       // Read user profile
"write:user"      // Modify user profile
"read:email"      // Read email address
"read:repos"      // Read repositories (GitHub)
"delete:repos"    // Delete repositories
"admin:org"       // Admin access to organization
```

### Spring Boot OAuth 2.0 Implementation

#### Step 1: Add Dependencies

xml

```xml
<dependencies>
    <!-- Spring Security OAuth2 Client -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    
    <!-- For Resource Server -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
</dependencies>
```

#### Step 2: OAuth 2.0 Client Configuration

properties

```properties
# application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          # Google OAuth
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - email
              - profile
          
          # GitHub OAuth
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            scope:
              - user:email
              - read:user
          
          # Custom OAuth Provider
          custom-provider:
            client-id: ${CUSTOM_CLIENT_ID}
            client-secret: ${CUSTOM_CLIENT_SECRET}
            client-name: Custom Provider
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope:
              - read
              - write
        
        provider:
          custom-provider:
            authorization-uri: https://provider.com/oauth/authorize
            token-uri: https://provider.com/oauth/token
            user-info-uri: https://provider.com/oauth/userinfo
            user-name-attribute: id
```

#### Step 3: OAuth Security Configuration

java

```java
@Configuration
@EnableWebSecurity
public class OAuth2SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login", "/error").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .loginPage("/login")
                .defaultSuccessUrl("/dashboard", true)
                .failureUrl("/login?error=true")
                .userInfoEndpoint(userInfo -> userInfo
                    .userService(customOAuth2UserService())
                )
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/")
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID")
            );
        
        return http.build();
    }
    
    @Bean
    public OAuth2UserService<OAuth2UserRequest, OAuth2User> customOAuth2UserService() {
        return new CustomOAuth2UserService();
    }
}
```

#### Step 4: Custom OAuth2 User Service

java

```java
@Service
public class CustomOAuth2UserService 
        extends DefaultOAuth2UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) 
            throws OAuth2AuthenticationException {
        
        // Get user info from OAuth provider
        OAuth2User oauth2User = super.loadUser(userRequest);
        
        // Process and save user
        String registrationId = userRequest.getClientRegistration()
            .getRegistrationId();
        
        String email = oauth2User.getAttribute("email");
        String name = oauth2User.getAttribute("name");
        
        // Find or create user in database
        User user = userRepository.findByEmail(email)
            .orElseGet(() -> {
                User newUser = new User();
                newUser.setEmail(email);
                newUser.setUsername(email);
                newUser.setName(name);
                newUser.setProvider(registrationId);
                newUser.setRoles(Set.of("USER"));
                return userRepository.save(newUser);
            });
        
        // Return custom OAuth2User implementation
        return new CustomOAuth2User(oauth2User, user);
    }
}

public class CustomOAuth2User implements OAuth2User {
    
    private OAuth2User oauth2User;
    private User user;
    
    public CustomOAuth2User(OAuth2User oauth2User, User user) {
        this.oauth2User = oauth2User;
        this.user = user;
    }
    
    @Override
    public Map<String, Object> getAttributes() {
        return oauth2User.getAttributes();
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getRoles().stream()
            .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
            .collect(Collectors.toList());
    }
    
    @Override
    public String getName() {
        return user.getUsername();
    }
    
    public User getUser() {
        return user;
    }
}
```

#### Step 5: Login Controller

java

```java
@Controller
public class LoginController {
    
    @GetMapping("/login")
    public String login() {
        return "login";
    }
    
    @GetMapping("/dashboard")
    public String dashboard(Model model, @AuthenticationPrincipal OAuth2User principal) {
        if (principal instanceof CustomOAuth2User) {
            CustomOAuth2User customUser = (CustomOAuth2User) principal;
            model.addAttribute("user", customUser.getUser());
        }
        return "dashboard";
    }
}
```

#### Step 6: Login Page (Thymeleaf)

html

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Login</title>
</head>
<body>
    <h1>Login</h1>
    
    <div th:if="${param.error}">
        <p style="color: red;">Login failed. Please try again.</p>
    </div>
    
    <div>
        <h3>Login with:</h3>
        
        <!-- Google Login -->
        <a href="/oauth2/authorization/google">
            <button>Login with Google</button>
        </a>
        
        <!-- GitHub Login -->
        <a href="/oauth2/authorization/github">
            <button>Login with GitHub</button>
        </a>
        
        <!-- Custom Provider -->
        <a href="/oauth2/authorization/custom-provider">
            <button>Login with Custom Provider</button>
        </a>
    </div>
</body>
</html>
```

### OAuth 2.0 Resource Server (Protecting APIs)

java

```java
@Configuration
@EnableWebSecurity
public class ResourceServerConfig {
    
    @Bean
    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) 
            throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/admin/**")
                    .hasAuthority("SCOPE_admin")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            );
        
        return http.build();
    }
    
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = 
            new JwtGrantedAuthoritiesConverter();
        
        // Extract scopes from JWT
        grantedAuthoritiesConverter.setAuthoritiesClaimName("scope");
        grantedAuthoritiesConverter.setAuthorityPrefix("SCOPE_");
        
        JwtAuthenticationConverter jwtAuthenticationConverter = 
            new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(
            grantedAuthoritiesConverter
        );
        
        return jwtAuthenticationConverter;
    }
    
    @Bean
    public JwtDecoder jwtDecoder() {
        // Configure JWT decoder with issuer URI
        return JwtDecoders.fromIssuerLocation(
            "https://authorization-server.com"
        );
    }
}
```

### Protected API Controller

java

```java
@RestController
@RequestMapping("/api")
public class ProtectedApiController {
    
    @GetMapping("/user/profile")
    public ResponseEntity<?> getUserProfile(
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        String email = jwt.getClaim("email");
        List<String> scopes = jwt.getClaim("scope");
        
        Map<String, Object> profile = new HashMap<>();
        profile.put("userId", userId);
        profile.put("email", email);
        profile.put("scopes", scopes);
        
        return ResponseEntity.ok(profile);
    }
    
    @PreAuthorize("hasAuthority('SCOPE_write')")
    @PostMapping("/user/update")
    public ResponseEntity<?> updateUser(@RequestBody UserUpdateDto dto) {
        // Only accessible with 'write' scope
        return ResponseEntity.ok("User updated");
    }
    
    @PreAuthorize("hasAuthority('SCOPE_admin')")
    @DeleteMapping("/admin/user/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        // Only accessible with 'admin' scope
        return ResponseEntity.ok("User deleted");
    }
}
```

### OAuth 2.0 Best Practices

java

```java
/**
 * Security Best Practices for OAuth 2.0
 */

// ✅ DO: Use Authorization Code Flow with PKCE
// - Most secure for public clients (SPAs, mobile apps)
// - Prevents authorization code interception

// ✅ DO: Use short-lived access tokens (15 minutes)
// - Limits exposure if token is stolen

// ✅ DO: Use refresh tokens for long-lived access
// - Allows token rotation without re-authentication

// ✅ DO: Store tokens securely
// - Never in localStorage for sensitive apps
// - Use httpOnly cookies or memory storage
// - Encrypt tokens in mobile apps

// ✅ DO: Validate redirect URIs strictly
// - Prevent open redirect vulnerabilities

// ✅ DO: Use state parameter
// - Prevents CSRF attacks

// ✅ DO: Request minimal scopes
// - Principle of least privilege

// ❌ DON'T: Use Implicit Flow
// - Deprecated and insecure

// ❌ DON'T: Store client secrets in frontend
// - Always in backend/environment variables

// ❌ DON'T: Expose access tokens in URLs
// - Use headers only

// ❌ DON'T: Share tokens between applications
// - Each app should have its own credentials
```

### OAuth 2.0 Testing

bash

```bash
# Test Authorization Code Flow

# Step 1: Get Authorization Code
# Open in browser:
https://authorization-server.com/oauth/authorize?
  response_type=code&
  client_id=YOUR_CLIENT_ID&
  redirect_uri=http://localhost:8080/callback&
  scope=read+write&
  state=random_string_for_csrf_protection

# Step 2: Exchange code for token
curl -X POST https://authorization-server.com/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=authorization_code" \
  -d "code=AUTHORIZATION_CODE" \
  -d "client_id=YOUR_CLIENT_ID" \
  -d "client_secret=YOUR_CLIENT_SECRET" \
  -d "redirect_uri=http://localhost:8080/callback"

# Response:
# {
#   "access_token": "eyJhbGc...",
#   "token_type": "Bearer",
#   "expires_in": 3600,
#   "refresh_token": "def502...",
#   "scope": "read write"
# }

# Step 3: Use access token
curl -X GET http://localhost:8080/api/user/profile \
  -H "Authorization: Bearer eyJhbGc..."

# Step 4: Refresh token when expired
curl -X POST https://authorization-server.com/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=def502..." \
  -d "client_id=YOUR_CLIENT_ID" \
  -d "client_secret=YOUR_CLIENT_SECRET"
```

----------

## 10. Complete Security Implementation Example

### 🎯 Full Stack Security Example

Let's build a complete application with all security features:

#### Project Structure

```
spring-security-app/
├── src/main/java/com/example/security/
│   ├── config/
│   │   ├── SecurityConfig.java
│   │   ├── JwtConfig.java
│   │   └── PasswordConfig.java
│   ├── controller/
│   │   ├── AuthController.java
│   │   ├── UserController.java
│   │   └── AdminController.java
│   ├── dto/
│   │   ├── LoginRequest.java
│   │   ├── LoginResponse.java
│   │   └── RegisterRequest.java
│   ├── entity/
│   │   ├── User.java
│   │   └── Role.java
│   ├── filter/
│   │   └── JwtAuthenticationFilter.java
│   ├── repository/
│   │   └── UserRepository.java
│   ├── service/
│   │   ├── UserService.java
│   │   ├── JwtService.java
│   │   └── CustomUserDetailsService.java
│   └── SecurityApplication.java
├── src/main/resources/
│   ├── application.properties
│   └── data.sql
└── pom.xml
```

#### Complete User Entity with Security

java

```java
@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false, length = 50)
    private String username;
    
    @Column(nullable = false)
    private String password;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(length = 100)
    private String fullName;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id")
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "role")
    private Set<RoleEnum> roles = new HashSet<>();
    
    private boolean enabled = true;
    private boolean accountNonExpired = true;
    private boolean accountNonLocked = true;
    private boolean credentialsNonExpired = true;
    
    @CreationTimestamp
    @Column(updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    private LocalDateTime lastLoginAt;
    
    @Column(name = "failed_login_attempts")
    private int failedLoginAttempts = 0;
    
    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;
}

@Getter
public enum RoleEnum {
    USER("ROLE_USER"),
    ADMIN("ROLE_ADMIN"),
    MODERATOR("ROLE_MODERATOR");
    
    private final String authority;
    
    RoleEnum(String authority) {
        this.authority = authority;
    }
}
```

#### Advanced User Service with Account Locking

java

```java
@Service
@Transactional
public class UserService {
    
    private static final int MAX_FAILED_ATTEMPTS = 5;
    private static final long LOCK_TIME_DURATION = 15 * 60 * 1000; // 15 minutes
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public User registerUser(RegisterRequest request) {
        // Validate username
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        
        // Validate email
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("Email already registered");
        }
        
        // Create user
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setFullName(request.getFullName());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setRoles(Set.of(RoleEnum.USER));
        
        return userRepository.save(user);
    }
    
    public void increaseFailedAttempts(User user) {
        int newFailAttempts = user.getFailedLoginAttempts() + 1;
        user.setFailedLoginAttempts(newFailAttempts);
        
        if (newFailAttempts >= MAX_FAILED_ATTEMPTS) {
            user.setAccountNonLocked(false);
            user.setLockedUntil(
                LocalDateTime.now().plusSeconds(LOCK_TIME_DURATION / 1000)
            );
        }
        
        userRepository.save(user);
    }
    
    public void resetFailedAttempts(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        user.setFailedLoginAttempts(0);
        user.setAccountNonLocked(true);
        user.setLockedUntil(null);
        user.setLastLoginAt(LocalDateTime.now());
        
        userRepository.save(user);
    }
    
    public boolean unlockWhenTimeExpired(User user) {
        if (user.getLockedUntil() != null && 
            LocalDateTime.now().isAfter(user.getLockedUntil())) {
            
            user.setAccountNonLocked(true);
            user.setFailedLoginAttempts(0);
            user.setLockedUntil(null);
            userRepository.save(user);
            
            return true;
        }
        return false;
    }
    
    public User changePassword(Long userId, String oldPassword, String newPassword) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        // Verify old password
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new RuntimeException("Current password is incorrect");
        }
        
        // Validate new password
        if (oldPassword.equals(newPassword)) {
            throw new RuntimeException("New password must be different");
        }
        
        // Update password
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setCredentialsNonExpired(true);
        
        return userRepository.save(user);
    }
}
```

#### Enhanced Authentication with Account Locking

java

```java
@Service
public class CustomAuthenticationProvider implements AuthenticationProvider {
    
    @Autowired
    private CustomUserDetailsService userDetailsService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public Authentication authenticate(Authentication authentication) 
            throws AuthenticationException {
        
        String username = authentication.getName();
        String password = authentication.getCredentials().toString();
        
        // Load user
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                new BadCredentialsException("Invalid credentials"));
        
        // Check if account is locked
        if (!user.isAccountNonLocked()) {
            // Try to unlock if time has passed
            if (!userService.unlockWhenTimeExpired(user)) {
                throw new LockedException(
                    "Account is locked. Try again later."
                );
            }
        }
        
        // Verify password
        if (passwordEncoder.matches(password, user.getPassword())) {
            // Reset failed attempts on successful login
            userService.resetFailedAttempts(username);
            
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            return new UsernamePasswordAuthenticationToken(
                userDetails,
                password,
                userDetails.getAuthorities()
            );
        } else {
            // Increase failed attempts
            userService.increaseFailedAttempts(user);
            
            throw new BadCredentialsException("Invalid credentials");
        }
    }
    
    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class
            .isAssignableFrom(authentication);
    }
}
```

#### Comprehensive Security Configuration

java

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Autowired
    private CustomAuthenticationProvider authProvider;
    
    @Autowired
    private AuthenticationEntryPoint authEntryPoint;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .cors(Customizer.withDefaults())
            .authorizeHttpRequests(auth -> auth
                // Public endpoints
                .requestMatchers(
                    "/api/auth/**",
                    "/api/public/**",
                    "/swagger-ui/**",
                    "/v3/api-docs/**"
                ).permitAll()
                
                // User endpoints
                .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                
                // Admin endpoints
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                
                // Any other request
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authenticationProvider(authProvider)
            .addFilterBefore(jwtAuthFilter, 
                UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(authEntryPoint)
            );
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
```

#### Custom Authentication Entry Point

java

```java
@Component
public class CustomAuthenticationEntryPoint 
        implements AuthenticationEntryPoint {
    
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException) 
            throws IOException, ServletException {
        
        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        
        Map<String, Object> data = new HashMap<>();
        data.put("timestamp", LocalDateTime.now().toString());
        data.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        data.put("error", "Unauthorized");
        data.put("message", authException.getMessage());
        data.put("path", request.getRequestURI());
        
        ObjectMapper mapper = new ObjectMapper();
        response.getOutputStream().println(
            mapper.writeValueAsString(data)
        );
    }
}
```

#### Admin Controller with Audit Logging

java

```java
@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AuditService auditService;
    
    @GetMapping("/users")
    public ResponseEntity<List<UserDto>> getAllUsers() {
        List<User> users = userRepository.findAll();
        
        auditService.log("ADMIN_VIEW_ALL_USERS", 
            SecurityContextHolder.getContext()
                .getAuthentication().getName());
        
        return ResponseEntity.ok(
            users.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList())
        );
    }
    
    @PutMapping("/users/{id}/roles")
    public ResponseEntity<?> updateUserRoles(
            @PathVariable Long id,
            @RequestBody Set<RoleEnum> roles) {
        
        User user = userRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        user.setRoles(roles);
        userRepository.save(user);
        
        auditService.log("ADMIN_UPDATE_USER_ROLES", 
            "Updated roles for user: " + user.getUsername());
        
        return ResponseEntity.ok("Roles updated successfully");
    }
    
    @PostMapping("/users/{id}/unlock")
    public ResponseEntity<?> unlockUser(@PathVariable Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        user.setAccountNonLocked(true);
        user.setFailedLoginAttempts(0);
        user.setLockedUntil(null);
        userRepository.save(user);
        
        auditService.log("ADMIN_UNLOCK_USER", 
            "Unlocked user: " + user.getUsername());
        
        return ResponseEntity.ok("User unlocked successfully");
    }
    
    private UserDto convertToDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        dto.setFullName(user.getFullName());
        dto.setRoles(user.getRoles());
        dto.setEnabled(user.isEnabled());
        dto.setAccountNonLocked(user.isAccountNonLocked());
        dto.setLastLoginAt(user.getLastLoginAt());
        return dto;
    }
}
```

----------

## 11. Security Checklist and Best Practices

### 🔒 Production Security Checklist

```
✅ Authentication & Authorization
   ☐ Strong password policy (min 8 chars, complexity)
```
