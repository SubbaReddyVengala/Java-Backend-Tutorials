# Database Transactions & Spring Data JPA - Complete Tutorial

## 1. What is a Transaction in Database?

### Definition

A **transaction** is a logical unit of work that contains one or more database operations. It's an all-or-nothing proposition - either all operations succeed, or none of them do.
A **transaction** is a **single logical unit of work** that performs one or more database operations (INSERT, UPDATE, DELETE, SELECT).

ğŸ‘‰ A transaction ensures **data consistency** and **integrity** â€” either **all operations succeed (COMMIT)** or **none take effect (ROLLBACK)**.


### The Restaurant Analogy ğŸ½ï¸

Think of a transaction like ordering a combo meal at a restaurant:

-   You order a burger, fries, and a drink
-   Either you get ALL three items (commit), or you get NONE (rollback)
-   You don't want to pay for a combo and receive only the burger!
 
âš™ï¸ Example:
``` sql
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

COMMIT;

```
If any query fails (e.g., insufficient balance), the system will:
``` sql
ROLLBACK;
```
â†’ No changes are saved in the database.
### ğŸ’­ Visualization:

Think of a **bank transfer** as a â€œsealed packetâ€ â€”  
both debit and credit actions are wrapped together.  
Either the whole packet is delivered (commit) or discarded (rollback).
## âš™ï¸ 2. Transaction Management in Spring Boot

Spring provides powerful **declarative transaction management** using the `@Transactional` annotation.


### ACID Properties

Transactions must follow ACID principles:

#### **A - Atomicity**

-   **What**: All operations complete successfully, or none do
-   **Memory Visualization**: Think of an atom - indivisible!

```
Transaction Start
â”œâ”€ Operation 1: Deduct $100 from Account A âœ“
â”œâ”€ Operation 2: Add $100 to Account B âœ— (FAILS)
â””â”€ Result: ROLLBACK both operations
```

#### **C - Consistency**

-   **What**: Database moves from one valid state to another
-   **Analogy**: Like a balanced checkbook - total money before = total money after

```
Before Transaction: Account A ($1000) + Account B ($500) = $1500
After Transaction:  Account A ($900) + Account B ($600) = $1500 âœ“
```

#### **I - Isolation**

-   **What**: Concurrent transactions don't interfere with each other
-   **Analogy**: Like separate checkout lanes at a store - each customer's transaction is independent

```
Transaction 1: Reading Account Balance
Transaction 2: Updating Account Balance
(They don't see each other's intermediate states)
```

#### **D - Durability**

-   **What**: Once committed, changes are permanent (even if system crashes)
-   **Memory Visualization**: Written in permanent ink, not pencil!

### Transaction States

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Active  â”‚ â† Transaction is executing
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚
     â”œâ”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   â”‚ Partially     â”‚ â† Some operations done
     â”‚   â”‚ Committed     â”‚
     â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚           â”‚
     â”‚           â†“
     â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”œâ”€â†’ â”‚  Committed    â”‚ â† Success! Changes saved
     â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Failed    â”‚ â† Error occurred
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Aborted   â”‚ â† Rolled back, no changes
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
âœ… Example:
``` java
@Service
public class PaymentService {

    @Autowired
    private AccountRepository accountRepository;

    @Transactional
    public void transferMoney(Long fromId, Long toId, Double amount) {
        Account from = accountRepository.findById(fromId).get();
        Account to = accountRepository.findById(toId).get();

        from.setBalance(from.getBalance() - amount);
        to.setBalance(to.getBalance() + amount);

        accountRepository.save(from);
        accountRepository.save(to);
    }
}

```
### ğŸ§  How It Works Internally

Spring creates a **proxy** around the method.  
When `transferMoney()` starts â†’ opens a transaction.  
If all goes well â†’ **commit**.  
If exception â†’ **rollback**.

âš¡ Important Parameters
```java
@Transactional(
    propagation = Propagation.REQUIRED, 
    isolation = Isolation.READ_COMMITTED,
    rollbackFor = Exception.class
)

```

### Basic Transaction Example

java

```java
// Without Transaction - DANGEROUS!
public void transferMoney(Long fromId, Long toId, Double amount) {
    Account from = accountRepo.findById(fromId);
    Account to = accountRepo.findById(toId);
    
    from.setBalance(from.getBalance() - amount); // What if crash happens here?
    accountRepo.save(from);
    // âš ï¸ CRASH HERE = Money deducted but not added!
    to.setBalance(to.getBalance() + amount);
    accountRepo.save(to);
}

// With Transaction - SAFE!
@Transactional
public void transferMoney(Long fromId, Long toId, Double amount) {
    Account from = accountRepo.findById(fromId);
    Account to = accountRepo.findById(toId);
    
    from.setBalance(from.getBalance() - amount);
    accountRepo.save(from);
    // If crash happens anywhere, ENTIRE transaction rolls back
    to.setBalance(to.getBalance() + amount);
    accountRepo.save(to);
    // Both operations succeed together, or both fail together
}
```

----------

## 2. Transaction Management in Spring

### Declarative Transaction Management

Spring uses the `@Transactional` annotation for declarative transactions.

#### Key Attributes

java

```java
@Transactional(
    propagation = Propagation.REQUIRED,  // Transaction propagation behavior
    isolation = Isolation.DEFAULT,       // Isolation level
    timeout = 30,                        // Timeout in seconds
    readOnly = false,                    // Read-only optimization
    rollbackFor = Exception.class        // Which exceptions trigger rollback
)
public void complexOperation() {
    // Your code here
}
```

### Transaction Propagation

**Analogy**: Like phone call handling rules in a company

java

```java
// REQUIRED (Default) - "Join existing call or start new one"
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // If transaction exists, use it
    // If not, create new one
}

// REQUIRES_NEW - "Always start a new call, put current on hold"
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // Always creates new transaction
    // Suspends current transaction if exists
}

// MANDATORY - "Must join existing call, can't start new"
@Transactional(propagation = Propagation.MANDATORY)
public void methodC() {
    // Throws exception if no transaction exists
}

// NESTED - "Conference call within main call"
@Transactional(propagation = Propagation.NESTED)
public void methodD() {
    // Creates nested transaction (savepoint)
    // Can rollback independently
}
```

### Memory Visualization of Propagation

```
Service Layer Call Stack:

REQUIRED:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transaction T1           â”‚
â”‚  â”œâ”€ methodA()           â”‚
â”‚  â”‚   â”œâ”€ DB Operation 1  â”‚
â”‚  â”‚   â””â”€ methodB()       â”‚ â† Joins T1
â”‚  â”‚       â””â”€ DB Op 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

REQUIRES_NEW:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transaction T1           â”‚
â”‚  â”œâ”€ methodA()           â”‚
â”‚  â”‚   â””â”€ DB Operation 1  â”‚
â”‚  â””â”€ [T1 SUSPENDED]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transaction T2 (NEW)     â”‚
â”‚  â””â”€ methodB()           â”‚
â”‚      â””â”€ DB Operation 2   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Isolation Levels

**Analogy**: Privacy levels in a library study room

java

```java
// READ_UNCOMMITTED - "Glass walls, see everything"
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
// Can read uncommitted changes from other transactions
// Fastest but least safe (dirty reads possible)

// READ_COMMITTED - "Opaque walls, see only final results"
@Transactional(isolation = Isolation.READ_COMMITTED)
// Can only read committed data
// Prevents dirty reads

// REPEATABLE_READ - "Locked room, same view throughout"
@Transactional(isolation = Isolation.REPEATABLE_READ)
// Data read once stays same throughout transaction
// Prevents dirty reads and non-repeatable reads

// SERIALIZABLE - "Private vault, one at a time"
@Transactional(isolation = Isolation.SERIALIZABLE)
// Complete isolation, transactions execute serially
// Slowest but safest
```

### Practical Example

java

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Transactional(
        rollbackFor = Exception.class,
        timeout = 30
    )
    public Order placeOrder(OrderDTO orderDTO) {
        // Step 1: Create order
        Order order = new Order();
        order.setCustomerId(orderDTO.getCustomerId());
        order.setStatus("PENDING");
        order = orderRepo.save(order);
        
        // Step 2: Reserve inventory
        inventoryService.reserveItems(orderDTO.getItems());
        
        // Step 3: Process payment
        paymentService.processPayment(orderDTO.getPaymentInfo());
        
        // Step 4: Confirm order
        order.setStatus("CONFIRMED");
        return orderRepo.save(order);
        
        // If ANY step fails, ALL steps rollback!
    }
    
    // Read-only transaction for better performance
    @Transactional(readOnly = true)
    public List<Order> getOrderHistory(Long customerId) {
        return orderRepo.findByCustomerId(customerId);
    }
}
```

----------

## 3. Pagination Using Data JPA Methods

### Why Pagination?

**Problem**: Loading 1 million records crashes your application!

**Solution**: Load data in "pages" (chunks)

**Analogy**: Reading a book chapter by chapter instead of all at once

### Memory Visualization

```
Database (1,000,000 records)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Without Pagination:         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Load ALL 1M records   â”‚  â”‚ â†’ ğŸ’¥ OutOfMemory!
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

With Pagination:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Page 0: Records 0-19    âœ“   â”‚
â”‚ Page 1: Records 20-39   âœ“   â”‚
â”‚ Page 2: Records 40-59   âœ“   â”‚
â”‚ ...                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Load only 20 at a time!
```

### Basic Pagination

java

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // JpaRepository provides pagination methods automatically
}

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    public Page<User> getUsers(int pageNumber, int pageSize) {
        // PageRequest creates pagination parameters
        Pageable pageable = PageRequest.of(pageNumber, pageSize);
        
        return userRepo.findAll(pageable);
        // Returns Page object with:
        // - Content (actual records)
        // - Total pages
        // - Total elements
        // - Current page info
    }
}
```

### Page Object Structure

java

```java
Page<User> userPage = getUsers(0, 10);

// Page contents visualization:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Page<User>                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Content: [                     â”‚
â”‚   User(id=1, name="Alice"),   â”‚
â”‚   User(id=2, name="Bob"),     â”‚
â”‚   ...                          â”‚
â”‚   User(id=10, name="Jane")    â”‚
â”‚ ]                              â”‚
â”‚                                â”‚
â”‚ Metadata:                      â”‚
â”‚ - Total Elements: 1000         â”‚
â”‚ - Total Pages: 100             â”‚
â”‚ - Current Page: 0              â”‚
â”‚ - Page Size: 10                â”‚
â”‚ - Has Next: true               â”‚
â”‚ - Has Previous: false          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Custom Pagination Queries

java

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Method query with pagination
    Page<Product> findByCategory(String category, Pageable pageable);
    
    // Multiple conditions with pagination
    Page<Product> findByPriceBetween(
        Double minPrice, 
        Double maxPrice, 
        Pageable pageable
    );
    
    // Custom JPQL query with pagination
    @Query("SELECT p FROM Product p WHERE p.inStock = true")
    Page<Product> findAvailableProducts(Pageable pageable);
    
    // Native SQL with pagination
    @Query(
        value = "SELECT * FROM products WHERE rating > :rating",
        nativeQuery = true
    )
    Page<Product> findHighRatedProducts(
        @Param("rating") Double rating,
        Pageable pageable
    );
}
```

### Pagination in REST Controller

java

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @Autowired
    private ProductRepository productRepo;
    
    @GetMapping
    public ResponseEntity<Page<Product>> getProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Product> products = productRepo.findAll(pageable);
        return ResponseEntity.ok(products);
    }
    
    // Response structure:
    // {
    //   "content": [ /* product objects */ ],
    //   "pageable": {
    //     "pageNumber": 0,
    //     "pageSize": 10
    //   },
    //   "totalPages": 50,
    //   "totalElements": 500,
    //   "last": false,
    //   "first": true
    // }
}
```

----------

## 4. Sorting Using Data JPA Methods

### Basic Sorting

**Analogy**: Organizing books on a shelf by title, author, or date

java

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepo;
    
    // Sort by single field
    public List<Product> getProductsSortedByName() {
        Sort sort = Sort.by("name");
        return productRepo.findAll(sort);
    }
    
    // Sort in descending order
    public List<Product> getProductsByPriceDesc() {
        Sort sort = Sort.by(Sort.Direction.DESC, "price");
        return productRepo.findAll(sort);
    }
    
    // Sort by multiple fields
    public List<Product> getProductsMultiSort() {
        Sort sort = Sort.by("category")              // First by category
                       .and(Sort.by("price").descending()); // Then by price DESC
        return productRepo.findAll(sort);
    }
}
```

### Memory Visualization of Sorting

```
Original Data:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Product(name="Zebra")    â”‚
â”‚ Product(name="Apple")    â”‚
â”‚ Product(name="Mango")    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After Sort.by("name"):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Product(name="Apple")    â”‚
â”‚ Product(name="Mango")    â”‚
â”‚ Product(name="Zebra")    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Multi-field Sort (category, price DESC):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Product(cat="Electronics", $500) â”‚
â”‚ Product(cat="Electronics", $300) â”‚
â”‚ Product(cat="Food", $50)        â”‚
â”‚ Product(cat="Food", $20)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pagination + Sorting Combined

java

```java
public Page<Product> getProductsPaginated(
    int page, 
    int size, 
    String sortBy,
    String direction
) {
    // Create Sort object
    Sort sort = direction.equalsIgnoreCase("DESC") 
        ? Sort.by(sortBy).descending()
        : Sort.by(sortBy).ascending();
    
    // Create Pageable with sorting
    Pageable pageable = PageRequest.of(page, size, sort);
    
    return productRepo.findAll(pageable);
}

// Usage:
// Page 0, 10 items, sorted by price ascending
getProductsPaginated(0, 10, "price", "ASC");
```

### Repository Method Sorting

java

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Method name sorting
    List<Order> findByCustomerIdOrderByOrderDateDesc(Long customerId);
    
    // With pagination and method-name sorting
    Page<Order> findByStatusOrderByOrderDateDesc(
        String status, 
        Pageable pageable
    );
    
    // Dynamic sorting with Pageable
    Page<Order> findByCustomerId(Long customerId, Pageable pageable);
    // Can sort dynamically when calling:
    // findByCustomerId(1L, PageRequest.of(0, 10, Sort.by("total").descending()))
}
```

### Advanced Sorting Example

java

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @GetMapping
    public ResponseEntity<Page<Order>> getOrders(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "orderDate") String sortBy,
        @RequestParam(defaultValue = "DESC") String direction
    ) {
        // Build Sort dynamically
        Sort.Direction sortDirection = direction.equalsIgnoreCase("DESC") 
            ? Sort.Direction.DESC 
            : Sort.Direction.ASC;
        
        Sort sort = Sort.by(sortDirection, sortBy);
        
        // Pagination with sorting
        Pageable pageable = PageRequest.of(page, size, sort);
        
        Page<Order> orders = orderRepo.findAll(pageable);
        
        return ResponseEntity.ok(orders);
    }
}
```

----------

## 5. Async Data JPA

### ğŸ§  Concept:

In normal JPA, all repository calls are **blocking** 
the thread waits until query finishes.

**Asynchronous JPA** lets the method run in a **separate thread**,  
so your main thread can continue processing.

### ğŸ§© Setup:

Enable async in your Spring Boot app:
``` java
@SpringBootApplication
@EnableAsync
public class MyApp {}
```
âœ… Repository:
``` java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {

    @Async
    CompletableFuture<List<Employee>> findByDepartment(String department);
}
```
âœ… Service:
``` java
@Autowired
private EmployeeRepository repo;

public void getEmployeesAsync() {
    CompletableFuture<List<Employee>> future = repo.findByDepartment("IT");

    future.thenAccept(list -> {
        list.forEach(System.out::println);
    });
}
```
### ğŸ’­ Visualization:

Think of **Async JPA** like placing a **food order** â€”  
you give the order and continue your work.  
When the food (query result) is ready, itâ€™s delivered to you.

## ğŸ›°ï¸ 6. Asynchronous Calls with JPA (Real-Time Flow)

### Scenario:

A **reporting service** needs to fetch data from multiple tables simultaneously.

``` java
@Async
public CompletableFuture<List<Employee>> getEmployees() {
    return CompletableFuture.completedFuture(repo.findAll());
}

@Async
public CompletableFuture<List<Department>> getDepartments() {
    return CompletableFuture.completedFuture(departmentRepo.findAll());
}

public void generateReport() {
    CompletableFuture<List<Employee>> empFuture = getEmployees();
    CompletableFuture<List<Department>> deptFuture = getDepartments();

    CompletableFuture.allOf(empFuture, deptFuture).join();

    System.out.println("Both queries completed!");
}

```
## Why Asynchronous Operations?

**Synchronous Problem**:

```
User Request â†’ Processing (10 seconds) â†’ Response
              [User waits... ğŸ˜´]
```

**Asynchronous Solution**:

```
User Request â†’ Task submitted â†’ Immediate Response âœ“
                    â†“
               Background Processing (10 seconds)
                    â†“
               Complete! (User notified)
```
### ğŸ’­ Visualization:

Imagine two workers â€” one fetching Employees, another Departments â€”  
both work in parallel and meet once done.  
Thatâ€™s **Async + JPA parallelism**.

ğŸ§  Memory Visualization (For Revision)
``` java 
Database Transaction â†’ Sealed Envelope  
Transaction Mgmt â†’ Bank Manager ensuring correct transfer  
Pagination â†’ Reading one book page at a time  
Sorting â†’ Alphabetically arranging files  
Async JPA â†’ Ordering pizza (you donâ€™t wait)  
Async Calls â†’ Two chefs cooking at once

```
### Enabling Async Support

java

```java
@Configuration
@EnableAsync  // Enable async processing
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);      // Minimum threads
        executor.setMaxPoolSize(10);      // Maximum threads
        executor.setQueueCapacity(100);   // Queue size
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

### Memory Visualization of Thread Pool

```
Thread Pool (5 core, 10 max):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Active Threads:                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”        â”‚
â”‚ â”‚ T1  â”‚ â”‚ T2  â”‚ â”‚ T3  â”‚        â”‚
â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜        â”‚
â”‚   â†“       â†“       â†“            â”‚
â”‚ Task1  Task2  Task3            â”‚
â”‚                                 â”‚
â”‚ Queue (waiting tasks):          â”‚
â”‚ [Task4, Task5, Task6...]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Basic Async Repository Methods

java

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Async method returning CompletableFuture
    @Async
    CompletableFuture<List<User>> findByLastName(String lastName);
    
    // Async with additional parameters
    @Async
    CompletableFuture<User> findByEmail(String email);
}
```

### Async Service Layer

java

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    // Simple async method
    @Async
    public CompletableFuture<List<User>> findUsersByLastName(String lastName) {
        System.out.println("Executing on thread: " + 
            Thread.currentThread().getName());
        
        List<User> users = userRepo.findByLastNameContaining(lastName);
        return CompletableFuture.completedFuture(users);
    }
    
    // Async method with processing
    @Async("taskExecutor")  // Use specific executor
    public CompletableFuture<UserStatistics> calculateUserStats(Long userId) {
        // Simulate heavy processing
        User user = userRepo.findById(userId).orElseThrow();
        
        // Complex calculations
        UserStatistics stats = performComplexCalculations(user);
        
        return CompletableFuture.completedFuture(stats);
    }
    
    // Async void method (fire and forget)
    @Async
    public void sendWelcomeEmail(Long userId) {
        User user = userRepo.findById(userId).orElseThrow();
        // Send email asynchronously
        emailService.send(user.getEmail(), "Welcome!");
        // No return value needed
    }
}
```

----------

## 6. Asynchronous Calls with JPA

### Parallel Async Queries

java

```java
@Service
public class ReportService {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @Autowired
    private CustomerRepository customerRepo;
    
    @Autowired
    private ProductRepository productRepo;
    
    // Execute multiple queries in parallel
    public DashboardReport generateDashboard() throws Exception {
        
        // Start all async operations
        CompletableFuture<Long> orderCountFuture = 
            getOrderCount();
        
        CompletableFuture<Long> customerCountFuture = 
            getCustomerCount();
        
        CompletableFuture<List<Product>> topProductsFuture = 
            getTopProducts();
        
        // Wait for all to complete
        CompletableFuture.allOf(
            orderCountFuture,
            customerCountFuture,
            topProductsFuture
        ).join();
        
        // Combine results
        DashboardReport report = new DashboardReport();
        report.setTotalOrders(orderCountFuture.get());
        report.setTotalCustomers(customerCountFuture.get());
        report.setTopProducts(topProductsFuture.get());
        
        return report;
    }
    
    @Async
    public CompletableFuture<Long> getOrderCount() {
        return CompletableFuture.completedFuture(orderRepo.count());
    }
    
    @Async
    public CompletableFuture<Long> getCustomerCount() {
        return CompletableFuture.completedFuture(customerRepo.count());
    }
    
    @Async
    public CompletableFuture<List<Product>> getTopProducts() {
        Pageable top10 = PageRequest.of(0, 10, 
            Sort.by("salesCount").descending());
        return CompletableFuture.completedFuture(
            productRepo.findAll(top10).getContent()
        );
    }
}
```

### Timing Comparison Visualization

```
Synchronous (Sequential):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Query 1: Orders    [3s]         â”‚
â”‚ Query 2: Customers [2s]         â”‚
â”‚ Query 3: Products  [4s]         â”‚
â”‚ Total Time: 9 seconds           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Asynchronous (Parallel):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Query 1: Orders    [3s]  â”€â”€â”    â”‚
â”‚ Query 2: Customers [2s]  â”€â”€â”¤    â”‚
â”‚ Query 3: Products  [4s]  â”€â”€â”˜    â”‚
â”‚ Total Time: 4 seconds (max)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Async with Exception Handling

java

```java
@Service
public class DataProcessingService {
    
    @Async
    public CompletableFuture<ProcessResult> processLargeDataset(Long datasetId) {
        try {
            // Simulate processing
            Dataset dataset = datasetRepo.findById(datasetId).orElseThrow();
            
            // Heavy processing
            ProcessResult result = performProcessing(dataset);
            
            return CompletableFuture.completedFuture(result);
            
        } catch (Exception e) {
            // Return exceptional future
            CompletableFuture<ProcessResult> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
    }
    
    // Using it with error handling
    public void processWithCallback(Long datasetId) {
        processLargeDataset(datasetId)
            .thenAccept(result -> {
                System.out.println("Processing completed: " + result);
            })
            .exceptionally(ex -> {
                System.err.println("Processing failed: " + ex.getMessage());
                return null;
            });
    }
}
```

### Async Chain Operations

java

```java
@Service
public class OrderProcessingService {
    
    @Async
    public CompletableFuture<Order> createOrder(OrderDTO dto) {
        Order order = new Order();
        // ... set order details
        order = orderRepo.save(order);
        return CompletableFuture.completedFuture(order);
    }
    
    @Async
    public CompletableFuture<Payment> processPayment(Order order) {
        Payment payment = paymentService.process(order);
        return CompletableFuture.completedFuture(payment);
    }
    
    @Async
    public CompletableFuture<Shipment> createShipment(Order order) {
        Shipment shipment = shipmentService.create(order);
        return CompletableFuture.completedFuture(shipment);
    }
    
    // Chain async operations
    public CompletableFuture<OrderCompletionResult> placeOrder(OrderDTO dto) {
        return createOrder(dto)
            .thenCompose(order -> 
                processPayment(order)
                    .thenCombine(
                        createShipment(order),
                        (payment, shipment) -> new OrderCompletionResult(
                            order, payment, shipment
                        )
                    )
            );
    }
}
```

### Flow Visualization

```
Async Chain Flow:

createOrder()
    â†“
Order Created
    â†“
    â”œâ”€â”€â†’ processPayment() â”€â”€â”
    â”‚                       â”‚
    â””â”€â”€â†’ createShipment() â”€â”€â”¤
                            â”‚
                            â†“
                    Combine Results
                            â†“
              OrderCompletionResult
```

### Best Practices

java

```java
// âœ… DO: Proper async method
@Async
public CompletableFuture<List<User>> findUsers() {
    List<User> users = userRepo.findAll();
    return CompletableFuture.completedFuture(users);
}

// âŒ DON'T: Calling async method from same class
@Service
public class UserService {
    public void someMethod() {
        // This will NOT be async!
        this.findUsers();
    }
}

// âœ… DO: Inject and call from another bean
@Service
public class UserService {
    @Autowired
    private UserAsyncService asyncService;
    
    public void someMethod() {
        // This WILL be async!
        asyncService.findUsers();
    }
}

// âœ… DO: Configure proper thread pool
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> {
            System.err.println("Async exception: " + ex.getMessage());
        };
    }
}
```

----------

## Summary Table
<img width="817" height="208" alt="image" src="https://github.com/user-attachments/assets/d24fdfec-f6cb-4c2b-816a-ccfa8b2d326c" />

## Performance Tips

1.  **Use `@Transactional(readOnly = true)`** for read operations
2.  **Always paginate** large result sets
3.  **Use async** for independent, time-consuming operations
4.  **Combine pagination + sorting** in REST APIs
5.  **Configure proper thread pools** for async operations

----------

_Happy Learning! ğŸš€_
