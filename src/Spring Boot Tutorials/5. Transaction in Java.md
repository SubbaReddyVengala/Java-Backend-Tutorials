# Database Transactions & Spring Data JPA - Complete Tutorial

## 1. What is a Transaction in Database?

### Definition

A **transaction** is a logical unit of work that contains one or more database operations. It's an all-or-nothing proposition - either all operations succeed, or none of them do.
A **transaction** is a **single logical unit of work** that performs one or more database operations (INSERT, UPDATE, DELETE, SELECT).

👉 A transaction ensures **data consistency** and **integrity** — either **all operations succeed (COMMIT)** or **none take effect (ROLLBACK)**.


### The Restaurant Analogy 🍽️

Think of a transaction like ordering a combo meal at a restaurant:

-   You order a burger, fries, and a drink
-   Either you get ALL three items (commit), or you get NONE (rollback)
-   You don't want to pay for a combo and receive only the burger!
 
⚙️ Example:
``` sql
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

COMMIT;

```
If any query fails (e.g., insufficient balance), the system will:
``` sql
ROLLBACK;
```
→ No changes are saved in the database.
### 💭 Visualization:

Think of a **bank transfer** as a “sealed packet” —  
both debit and credit actions are wrapped together.  
Either the whole packet is delivered (commit) or discarded (rollback).
## ⚙️ 2. Transaction Management in Spring Boot

Spring provides powerful **declarative transaction management** using the `@Transactional` annotation.


### ACID Properties

Transactions must follow ACID principles:

#### **A - Atomicity**

-   **What**: All operations complete successfully, or none do
-   **Memory Visualization**: Think of an atom - indivisible!

```
Transaction Start
├─ Operation 1: Deduct $100 from Account A ✓
├─ Operation 2: Add $100 to Account B ✗ (FAILS)
└─ Result: ROLLBACK both operations
```

#### **C - Consistency**

-   **What**: Database moves from one valid state to another
-   **Analogy**: Like a balanced checkbook - total money before = total money after

```
Before Transaction: Account A ($1000) + Account B ($500) = $1500
After Transaction:  Account A ($900) + Account B ($600) = $1500 ✓
```

#### **I - Isolation**

-   **What**: Concurrent transactions don't interfere with each other
-   **Analogy**: Like separate checkout lanes at a store - each customer's transaction is independent

```
Transaction 1: Reading Account Balance
Transaction 2: Updating Account Balance
(They don't see each other's intermediate states)
```

#### **D - Durability**

-   **What**: Once committed, changes are permanent (even if system crashes)
-   **Memory Visualization**: Written in permanent ink, not pencil!

### Transaction States

```
┌─────────┐
│ Active  │ ← Transaction is executing
└────┬────┘
     │
     ├─→ ┌───────────────┐
     │   │ Partially     │ ← Some operations done
     │   │ Committed     │
     │   └───────┬───────┘
     │           │
     │           ↓
     │   ┌───────────────┐
     ├─→ │  Committed    │ ← Success! Changes saved
     │   └───────────────┘
     │
     ↓
┌────────────┐
│  Failed    │ ← Error occurred
└─────┬──────┘
      │
      ↓
┌────────────┐
│  Aborted   │ ← Rolled back, no changes
└────────────┘
```
✅ Example:
``` java
@Service
public class PaymentService {

    @Autowired
    private AccountRepository accountRepository;

    @Transactional
    public void transferMoney(Long fromId, Long toId, Double amount) {
        Account from = accountRepository.findById(fromId).get();
        Account to = accountRepository.findById(toId).get();

        from.setBalance(from.getBalance() - amount);
        to.setBalance(to.getBalance() + amount);

        accountRepository.save(from);
        accountRepository.save(to);
    }
}

```
### 🧠 How It Works Internally

Spring creates a **proxy** around the method.  
When `transferMoney()` starts → opens a transaction.  
If all goes well → **commit**.  
If exception → **rollback**.

⚡ Important Parameters
```java
@Transactional(
    propagation = Propagation.REQUIRED, 
    isolation = Isolation.READ_COMMITTED,
    rollbackFor = Exception.class
)

```

### Basic Transaction Example

java

```java
// Without Transaction - DANGEROUS!
public void transferMoney(Long fromId, Long toId, Double amount) {
    Account from = accountRepo.findById(fromId);
    Account to = accountRepo.findById(toId);
    
    from.setBalance(from.getBalance() - amount); // What if crash happens here?
    accountRepo.save(from);
    // ⚠️ CRASH HERE = Money deducted but not added!
    to.setBalance(to.getBalance() + amount);
    accountRepo.save(to);
}

// With Transaction - SAFE!
@Transactional
public void transferMoney(Long fromId, Long toId, Double amount) {
    Account from = accountRepo.findById(fromId);
    Account to = accountRepo.findById(toId);
    
    from.setBalance(from.getBalance() - amount);
    accountRepo.save(from);
    // If crash happens anywhere, ENTIRE transaction rolls back
    to.setBalance(to.getBalance() + amount);
    accountRepo.save(to);
    // Both operations succeed together, or both fail together
}
```

----------

## 2. Transaction Management in Spring

### Declarative Transaction Management

Spring uses the `@Transactional` annotation for declarative transactions.

#### Key Attributes

java

```java
@Transactional(
    propagation = Propagation.REQUIRED,  // Transaction propagation behavior
    isolation = Isolation.DEFAULT,       // Isolation level
    timeout = 30,                        // Timeout in seconds
    readOnly = false,                    // Read-only optimization
    rollbackFor = Exception.class        // Which exceptions trigger rollback
)
public void complexOperation() {
    // Your code here
}
```

### Transaction Propagation

**Analogy**: Like phone call handling rules in a company

java

```java
// REQUIRED (Default) - "Join existing call or start new one"
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // If transaction exists, use it
    // If not, create new one
}

// REQUIRES_NEW - "Always start a new call, put current on hold"
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // Always creates new transaction
    // Suspends current transaction if exists
}

// MANDATORY - "Must join existing call, can't start new"
@Transactional(propagation = Propagation.MANDATORY)
public void methodC() {
    // Throws exception if no transaction exists
}

// NESTED - "Conference call within main call"
@Transactional(propagation = Propagation.NESTED)
public void methodD() {
    // Creates nested transaction (savepoint)
    // Can rollback independently
}
```

### Memory Visualization of Propagation

```
Service Layer Call Stack:

REQUIRED:
┌──────────────────────────┐
│ Transaction T1           │
│  ├─ methodA()           │
│  │   ├─ DB Operation 1  │
│  │   └─ methodB()       │ ← Joins T1
│  │       └─ DB Op 2     │
└──────────────────────────┘

REQUIRES_NEW:
┌──────────────────────────┐
│ Transaction T1           │
│  ├─ methodA()           │
│  │   └─ DB Operation 1  │
│  └─ [T1 SUSPENDED]      │
└──────────────────────────┘
        ↓
┌──────────────────────────┐
│ Transaction T2 (NEW)     │
│  └─ methodB()           │
│      └─ DB Operation 2   │
└──────────────────────────┘
```

### Isolation Levels

**Analogy**: Privacy levels in a library study room

java

```java
// READ_UNCOMMITTED - "Glass walls, see everything"
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
// Can read uncommitted changes from other transactions
// Fastest but least safe (dirty reads possible)

// READ_COMMITTED - "Opaque walls, see only final results"
@Transactional(isolation = Isolation.READ_COMMITTED)
// Can only read committed data
// Prevents dirty reads

// REPEATABLE_READ - "Locked room, same view throughout"
@Transactional(isolation = Isolation.REPEATABLE_READ)
// Data read once stays same throughout transaction
// Prevents dirty reads and non-repeatable reads

// SERIALIZABLE - "Private vault, one at a time"
@Transactional(isolation = Isolation.SERIALIZABLE)
// Complete isolation, transactions execute serially
// Slowest but safest
```

### Practical Example

java

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Transactional(
        rollbackFor = Exception.class,
        timeout = 30
    )
    public Order placeOrder(OrderDTO orderDTO) {
        // Step 1: Create order
        Order order = new Order();
        order.setCustomerId(orderDTO.getCustomerId());
        order.setStatus("PENDING");
        order = orderRepo.save(order);
        
        // Step 2: Reserve inventory
        inventoryService.reserveItems(orderDTO.getItems());
        
        // Step 3: Process payment
        paymentService.processPayment(orderDTO.getPaymentInfo());
        
        // Step 4: Confirm order
        order.setStatus("CONFIRMED");
        return orderRepo.save(order);
        
        // If ANY step fails, ALL steps rollback!
    }
    
    // Read-only transaction for better performance
    @Transactional(readOnly = true)
    public List<Order> getOrderHistory(Long customerId) {
        return orderRepo.findByCustomerId(customerId);
    }
}
```

----------

## 3. Pagination Using Data JPA Methods

### Why Pagination?

**Problem**: Loading 1 million records crashes your application!

**Solution**: Load data in "pages" (chunks)

**Analogy**: Reading a book chapter by chapter instead of all at once

### Memory Visualization

```
Database (1,000,000 records)
┌─────────────────────────────┐
│ Without Pagination:         │
│ ┌───────────────────────┐  │
│ │ Load ALL 1M records   │  │ → 💥 OutOfMemory!
│ └───────────────────────┘  │
└─────────────────────────────┘

With Pagination:
┌─────────────────────────────┐
│ Page 0: Records 0-19    ✓   │
│ Page 1: Records 20-39   ✓   │
│ Page 2: Records 40-59   ✓   │
│ ...                         │
└─────────────────────────────┘
    ↓
Load only 20 at a time!
```

### Basic Pagination

java

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // JpaRepository provides pagination methods automatically
}

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    public Page<User> getUsers(int pageNumber, int pageSize) {
        // PageRequest creates pagination parameters
        Pageable pageable = PageRequest.of(pageNumber, pageSize);
        
        return userRepo.findAll(pageable);
        // Returns Page object with:
        // - Content (actual records)
        // - Total pages
        // - Total elements
        // - Current page info
    }
}
```

### Page Object Structure

java

```java
Page<User> userPage = getUsers(0, 10);

// Page contents visualization:
┌────────────────────────────────┐
│ Page<User>                     │
├────────────────────────────────┤
│ Content: [                     │
│   User(id=1, name="Alice"),   │
│   User(id=2, name="Bob"),     │
│   ...                          │
│   User(id=10, name="Jane")    │
│ ]                              │
│                                │
│ Metadata:                      │
│ - Total Elements: 1000         │
│ - Total Pages: 100             │
│ - Current Page: 0              │
│ - Page Size: 10                │
│ - Has Next: true               │
│ - Has Previous: false          │
└────────────────────────────────┘
```

### Custom Pagination Queries

java

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Method query with pagination
    Page<Product> findByCategory(String category, Pageable pageable);
    
    // Multiple conditions with pagination
    Page<Product> findByPriceBetween(
        Double minPrice, 
        Double maxPrice, 
        Pageable pageable
    );
    
    // Custom JPQL query with pagination
    @Query("SELECT p FROM Product p WHERE p.inStock = true")
    Page<Product> findAvailableProducts(Pageable pageable);
    
    // Native SQL with pagination
    @Query(
        value = "SELECT * FROM products WHERE rating > :rating",
        nativeQuery = true
    )
    Page<Product> findHighRatedProducts(
        @Param("rating") Double rating,
        Pageable pageable
    );
}
```

### Pagination in REST Controller

java

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @Autowired
    private ProductRepository productRepo;
    
    @GetMapping
    public ResponseEntity<Page<Product>> getProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Product> products = productRepo.findAll(pageable);
        return ResponseEntity.ok(products);
    }
    
    // Response structure:
    // {
    //   "content": [ /* product objects */ ],
    //   "pageable": {
    //     "pageNumber": 0,
    //     "pageSize": 10
    //   },
    //   "totalPages": 50,
    //   "totalElements": 500,
    //   "last": false,
    //   "first": true
    // }
}
```

----------

## 4. Sorting Using Data JPA Methods

### Basic Sorting

**Analogy**: Organizing books on a shelf by title, author, or date

java

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepo;
    
    // Sort by single field
    public List<Product> getProductsSortedByName() {
        Sort sort = Sort.by("name");
        return productRepo.findAll(sort);
    }
    
    // Sort in descending order
    public List<Product> getProductsByPriceDesc() {
        Sort sort = Sort.by(Sort.Direction.DESC, "price");
        return productRepo.findAll(sort);
    }
    
    // Sort by multiple fields
    public List<Product> getProductsMultiSort() {
        Sort sort = Sort.by("category")              // First by category
                       .and(Sort.by("price").descending()); // Then by price DESC
        return productRepo.findAll(sort);
    }
}
```

### Memory Visualization of Sorting

```
Original Data:
┌──────────────────────────┐
│ Product(name="Zebra")    │
│ Product(name="Apple")    │
│ Product(name="Mango")    │
└──────────────────────────┘

After Sort.by("name"):
┌──────────────────────────┐
│ Product(name="Apple")    │
│ Product(name="Mango")    │
│ Product(name="Zebra")    │
└──────────────────────────┘

Multi-field Sort (category, price DESC):
┌────────────────────────────────┐
│ Product(cat="Electronics", $500) │
│ Product(cat="Electronics", $300) │
│ Product(cat="Food", $50)        │
│ Product(cat="Food", $20)        │
└────────────────────────────────┘
```

### Pagination + Sorting Combined

java

```java
public Page<Product> getProductsPaginated(
    int page, 
    int size, 
    String sortBy,
    String direction
) {
    // Create Sort object
    Sort sort = direction.equalsIgnoreCase("DESC") 
        ? Sort.by(sortBy).descending()
        : Sort.by(sortBy).ascending();
    
    // Create Pageable with sorting
    Pageable pageable = PageRequest.of(page, size, sort);
    
    return productRepo.findAll(pageable);
}

// Usage:
// Page 0, 10 items, sorted by price ascending
getProductsPaginated(0, 10, "price", "ASC");
```

### Repository Method Sorting

java

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Method name sorting
    List<Order> findByCustomerIdOrderByOrderDateDesc(Long customerId);
    
    // With pagination and method-name sorting
    Page<Order> findByStatusOrderByOrderDateDesc(
        String status, 
        Pageable pageable
    );
    
    // Dynamic sorting with Pageable
    Page<Order> findByCustomerId(Long customerId, Pageable pageable);
    // Can sort dynamically when calling:
    // findByCustomerId(1L, PageRequest.of(0, 10, Sort.by("total").descending()))
}
```

### Advanced Sorting Example

java

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @GetMapping
    public ResponseEntity<Page<Order>> getOrders(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "orderDate") String sortBy,
        @RequestParam(defaultValue = "DESC") String direction
    ) {
        // Build Sort dynamically
        Sort.Direction sortDirection = direction.equalsIgnoreCase("DESC") 
            ? Sort.Direction.DESC 
            : Sort.Direction.ASC;
        
        Sort sort = Sort.by(sortDirection, sortBy);
        
        // Pagination with sorting
        Pageable pageable = PageRequest.of(page, size, sort);
        
        Page<Order> orders = orderRepo.findAll(pageable);
        
        return ResponseEntity.ok(orders);
    }
}
```

----------

## 5. Async Data JPA

### 🧠 Concept:

In normal JPA, all repository calls are **blocking** 
the thread waits until query finishes.

**Asynchronous JPA** lets the method run in a **separate thread**,  
so your main thread can continue processing.

### 🧩 Setup:

Enable async in your Spring Boot app:
``` java
@SpringBootApplication
@EnableAsync
public class MyApp {}
```
✅ Repository:
``` java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {

    @Async
    CompletableFuture<List<Employee>> findByDepartment(String department);
}
```
✅ Service:
``` java
@Autowired
private EmployeeRepository repo;

public void getEmployeesAsync() {
    CompletableFuture<List<Employee>> future = repo.findByDepartment("IT");

    future.thenAccept(list -> {
        list.forEach(System.out::println);
    });
}
```
### 💭 Visualization:

Think of **Async JPA** like placing a **food order** —  
you give the order and continue your work.  
When the food (query result) is ready, it’s delivered to you.

## 🛰️ 6. Asynchronous Calls with JPA (Real-Time Flow)

### Scenario:

A **reporting service** needs to fetch data from multiple tables simultaneously.

``` java
@Async
public CompletableFuture<List<Employee>> getEmployees() {
    return CompletableFuture.completedFuture(repo.findAll());
}

@Async
public CompletableFuture<List<Department>> getDepartments() {
    return CompletableFuture.completedFuture(departmentRepo.findAll());
}

public void generateReport() {
    CompletableFuture<List<Employee>> empFuture = getEmployees();
    CompletableFuture<List<Department>> deptFuture = getDepartments();

    CompletableFuture.allOf(empFuture, deptFuture).join();

    System.out.println("Both queries completed!");
}

```
## Why Asynchronous Operations?

**Synchronous Problem**:

```
User Request → Processing (10 seconds) → Response
              [User waits... 😴]
```

**Asynchronous Solution**:

```
User Request → Task submitted → Immediate Response ✓
                    ↓
               Background Processing (10 seconds)
                    ↓
               Complete! (User notified)
```
### 💭 Visualization:

Imagine two workers — one fetching Employees, another Departments —  
both work in parallel and meet once done.  
That’s **Async + JPA parallelism**.

🧠 Memory Visualization (For Revision)
``` java 
Database Transaction → Sealed Envelope  
Transaction Mgmt → Bank Manager ensuring correct transfer  
Pagination → Reading one book page at a time  
Sorting → Alphabetically arranging files  
Async JPA → Ordering pizza (you don’t wait)  
Async Calls → Two chefs cooking at once

```
### Enabling Async Support

java

```java
@Configuration
@EnableAsync  // Enable async processing
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);      // Minimum threads
        executor.setMaxPoolSize(10);      // Maximum threads
        executor.setQueueCapacity(100);   // Queue size
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

### Memory Visualization of Thread Pool

```
Thread Pool (5 core, 10 max):
┌─────────────────────────────────┐
│ Active Threads:                 │
│ ┌─────┐ ┌─────┐ ┌─────┐        │
│ │ T1  │ │ T2  │ │ T3  │        │
│ └─────┘ └─────┘ └─────┘        │
│   ↓       ↓       ↓            │
│ Task1  Task2  Task3            │
│                                 │
│ Queue (waiting tasks):          │
│ [Task4, Task5, Task6...]        │
└─────────────────────────────────┘
```

### Basic Async Repository Methods

java

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Async method returning CompletableFuture
    @Async
    CompletableFuture<List<User>> findByLastName(String lastName);
    
    // Async with additional parameters
    @Async
    CompletableFuture<User> findByEmail(String email);
}
```

### Async Service Layer

java

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    // Simple async method
    @Async
    public CompletableFuture<List<User>> findUsersByLastName(String lastName) {
        System.out.println("Executing on thread: " + 
            Thread.currentThread().getName());
        
        List<User> users = userRepo.findByLastNameContaining(lastName);
        return CompletableFuture.completedFuture(users);
    }
    
    // Async method with processing
    @Async("taskExecutor")  // Use specific executor
    public CompletableFuture<UserStatistics> calculateUserStats(Long userId) {
        // Simulate heavy processing
        User user = userRepo.findById(userId).orElseThrow();
        
        // Complex calculations
        UserStatistics stats = performComplexCalculations(user);
        
        return CompletableFuture.completedFuture(stats);
    }
    
    // Async void method (fire and forget)
    @Async
    public void sendWelcomeEmail(Long userId) {
        User user = userRepo.findById(userId).orElseThrow();
        // Send email asynchronously
        emailService.send(user.getEmail(), "Welcome!");
        // No return value needed
    }
}
```

----------

## 6. Asynchronous Calls with JPA

### Parallel Async Queries

java

```java
@Service
public class ReportService {
    
    @Autowired
    private OrderRepository orderRepo;
    
    @Autowired
    private CustomerRepository customerRepo;
    
    @Autowired
    private ProductRepository productRepo;
    
    // Execute multiple queries in parallel
    public DashboardReport generateDashboard() throws Exception {
        
        // Start all async operations
        CompletableFuture<Long> orderCountFuture = 
            getOrderCount();
        
        CompletableFuture<Long> customerCountFuture = 
            getCustomerCount();
        
        CompletableFuture<List<Product>> topProductsFuture = 
            getTopProducts();
        
        // Wait for all to complete
        CompletableFuture.allOf(
            orderCountFuture,
            customerCountFuture,
            topProductsFuture
        ).join();
        
        // Combine results
        DashboardReport report = new DashboardReport();
        report.setTotalOrders(orderCountFuture.get());
        report.setTotalCustomers(customerCountFuture.get());
        report.setTopProducts(topProductsFuture.get());
        
        return report;
    }
    
    @Async
    public CompletableFuture<Long> getOrderCount() {
        return CompletableFuture.completedFuture(orderRepo.count());
    }
    
    @Async
    public CompletableFuture<Long> getCustomerCount() {
        return CompletableFuture.completedFuture(customerRepo.count());
    }
    
    @Async
    public CompletableFuture<List<Product>> getTopProducts() {
        Pageable top10 = PageRequest.of(0, 10, 
            Sort.by("salesCount").descending());
        return CompletableFuture.completedFuture(
            productRepo.findAll(top10).getContent()
        );
    }
}
```

### Timing Comparison Visualization

```
Synchronous (Sequential):
┌─────────────────────────────────┐
│ Query 1: Orders    [3s]         │
│ Query 2: Customers [2s]         │
│ Query 3: Products  [4s]         │
│ Total Time: 9 seconds           │
└─────────────────────────────────┘

Asynchronous (Parallel):
┌─────────────────────────────────┐
│ Query 1: Orders    [3s]  ──┐    │
│ Query 2: Customers [2s]  ──┤    │
│ Query 3: Products  [4s]  ──┘    │
│ Total Time: 4 seconds (max)     │
└─────────────────────────────────┘
```

### Async with Exception Handling

java

```java
@Service
public class DataProcessingService {
    
    @Async
    public CompletableFuture<ProcessResult> processLargeDataset(Long datasetId) {
        try {
            // Simulate processing
            Dataset dataset = datasetRepo.findById(datasetId).orElseThrow();
            
            // Heavy processing
            ProcessResult result = performProcessing(dataset);
            
            return CompletableFuture.completedFuture(result);
            
        } catch (Exception e) {
            // Return exceptional future
            CompletableFuture<ProcessResult> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
    }
    
    // Using it with error handling
    public void processWithCallback(Long datasetId) {
        processLargeDataset(datasetId)
            .thenAccept(result -> {
                System.out.println("Processing completed: " + result);
            })
            .exceptionally(ex -> {
                System.err.println("Processing failed: " + ex.getMessage());
                return null;
            });
    }
}
```

### Async Chain Operations

java

```java
@Service
public class OrderProcessingService {
    
    @Async
    public CompletableFuture<Order> createOrder(OrderDTO dto) {
        Order order = new Order();
        // ... set order details
        order = orderRepo.save(order);
        return CompletableFuture.completedFuture(order);
    }
    
    @Async
    public CompletableFuture<Payment> processPayment(Order order) {
        Payment payment = paymentService.process(order);
        return CompletableFuture.completedFuture(payment);
    }
    
    @Async
    public CompletableFuture<Shipment> createShipment(Order order) {
        Shipment shipment = shipmentService.create(order);
        return CompletableFuture.completedFuture(shipment);
    }
    
    // Chain async operations
    public CompletableFuture<OrderCompletionResult> placeOrder(OrderDTO dto) {
        return createOrder(dto)
            .thenCompose(order -> 
                processPayment(order)
                    .thenCombine(
                        createShipment(order),
                        (payment, shipment) -> new OrderCompletionResult(
                            order, payment, shipment
                        )
                    )
            );
    }
}
```

### Flow Visualization

```
Async Chain Flow:

createOrder()
    ↓
Order Created
    ↓
    ├──→ processPayment() ──┐
    │                       │
    └──→ createShipment() ──┤
                            │
                            ↓
                    Combine Results
                            ↓
              OrderCompletionResult
```

### Best Practices

java

```java
// ✅ DO: Proper async method
@Async
public CompletableFuture<List<User>> findUsers() {
    List<User> users = userRepo.findAll();
    return CompletableFuture.completedFuture(users);
}

// ❌ DON'T: Calling async method from same class
@Service
public class UserService {
    public void someMethod() {
        // This will NOT be async!
        this.findUsers();
    }
}

// ✅ DO: Inject and call from another bean
@Service
public class UserService {
    @Autowired
    private UserAsyncService asyncService;
    
    public void someMethod() {
        // This WILL be async!
        asyncService.findUsers();
    }
}

// ✅ DO: Configure proper thread pool
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> {
            System.err.println("Async exception: " + ex.getMessage());
        };
    }
}
```

----------

## Summary Table
<img width="817" height="208" alt="image" src="https://github.com/user-attachments/assets/d24fdfec-f6cb-4c2b-816a-ccfa8b2d326c" />

## Performance Tips

1.  **Use `@Transactional(readOnly = true)`** for read operations
2.  **Always paginate** large result sets
3.  **Use async** for independent, time-consuming operations
4.  **Combine pagination + sorting** in REST APIs
5.  **Configure proper thread pools** for async operations

----------

_Happy Learning! 🚀_
