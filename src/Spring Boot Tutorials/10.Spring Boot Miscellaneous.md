# Spring Boot Advanced Features: Complete Tutorial Guide

## Table of Contents

1.  Spring Boot DevTools
2.  Profiles in Spring Boot
3.  Actuator in Spring Boot
4.  Spring Boot Admin Server & Clients
5.  Asynchronous Programming with @Async
6.  Logging in Spring Boot

----------

## 1. Spring Boot DevTools

### üéØ Concept & Analogy

**Analogy**: Think of DevTools as a  **"live reload button"**  for your development environment. Just like how modern IDEs auto-save your work, DevTools automatically restarts your application when you make changes.

**Memory Visualization**:

```
Without DevTools:          With DevTools:
Code Change                Code Change
    ‚Üì                          ‚Üì
Stop Server               Auto Detect
    ‚Üì                          ‚Üì
Rebuild                    Quick Restart
    ‚Üì                          ‚Üì
Start Server              Ready! (2-3 sec)
    ‚Üì
Wait (30+ sec)
```

### üìö Theory

Spring Boot DevTools provides developer-friendly features:

-   **Automatic Restart**: Restarts application when classpath changes
-   **Live Reload**: Browser auto-refresh (with browser extension)
-   **Property Defaults**: Disables template caching in development
-   **Remote Development**: Debug applications running remotely

**How it works**: DevTools uses two classloaders:

-   **Base classloader**: Loads third-party JARs (doesn't change)
-   **Restart classloader**: Loads your application code (restarts on change)

### üíª Implementation

**Step 1: Add Dependency**

xml

```xml
<!-- Maven -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

gradle

```gradle
// Gradle
developmentOnly 'org.springframework.boot:spring-boot-devtools'
```

**Step 2: Configuration (application.properties)**

properties

```properties
# Enable/Disable DevTools
spring.devtools.restart.enabled=true

# Additional paths to watch
spring.devtools.restart.additional-paths=src/main/resources

# Exclude paths from restart
spring.devtools.restart.exclude=static/**,public/**

# Enable live reload
spring.devtools.livereload.enabled=true
```

**Step 3: Example Controller**

java

```java
@RestController
@RequestMapping("/api")
public class DevToolsDemo {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello from DevTools! Change me and see auto-restart!";
    }
}
```

### üîë Key Points to Remember

-   DevTools is  **automatically disabled**  in production
-   Works only when running from IDE or  `java -jar`
-   Restart is faster than full application startup
-   Not included in packaged artifacts by default

----------

## 2. Profiles in Spring Boot

### üéØ Concept & Analogy

**Analogy**: Profiles are like  **wardrobe changes for different occasions**. You wear different clothes for work, gym, and parties. Similarly, your application needs different configurations for development, testing, and production.

**Memory Visualization**:

```
Application
    ‚Üì
Environment Detection
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   DEV     ‚îÇ   TEST    ‚îÇ    PROD    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ H2 DB     ‚îÇ MySQL     ‚îÇ PostgreSQL ‚îÇ
‚îÇ Debug ON  ‚îÇ Debug ON  ‚îÇ Debug OFF  ‚îÇ
‚îÇ Port 8080 ‚îÇ Port 8081 ‚îÇ Port 80    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üìö Theory

Profiles provide a way to segregate application configuration and make it available only in certain environments.

**Profile Activation Priority**:

1.  Command line arguments
2.  Environment variables
3.  application.properties
4.  Default profile

### üíª Implementation

**Step 1: Create Profile-Specific Properties Files**

```
src/main/resources/
‚îú‚îÄ‚îÄ application.properties          # Common properties
‚îú‚îÄ‚îÄ application-dev.properties      # Development
‚îú‚îÄ‚îÄ application-test.properties     # Testing
‚îî‚îÄ‚îÄ application-prod.properties     # Production
```

**application.properties**  (Common)

properties

```properties
# Common configuration
app.name=MySpringBootApp
app.version=1.0.0

# Active profile
spring.profiles.active=dev
```

**application-dev.properties**

properties

```properties
# Development Database
spring.datasource.url=jdbc:h2:mem:devdb
spring.datasource.username=sa
spring.datasource.password=

# Logging
logging.level.root=DEBUG
logging.level.com.myapp=TRACE

# Server
server.port=8080
```

**application-prod.properties**

properties

```properties
# Production Database
spring.datasource.url=jdbc:postgresql://prod-server:5432/proddb
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}

# Logging
logging.level.root=WARN
logging.level.com.myapp=INFO

# Server
server.port=80
```

**Step 2: Profile-Specific Beans**

java

```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setMaximumPoolSize(10);
        // Configure production datasource
        return dataSource;
    }
}
```

**Step 3: Using Profiles in Code**

java

```java
@Service
public class EmailService {
    
    @Value("${spring.profiles.active}")
    private String activeProfile;
    
    public void sendEmail(String to, String message) {
        if ("dev".equals(activeProfile)) {
            System.out.println("DEV MODE: Email to " + to + ": " + message);
        } else {
            // Actually send email in production
            actualEmailSender.send(to, message);
        }
    }
}
```

**Step 4: Profile Activation Methods**

**Method 1: In application.properties**

properties

```properties
spring.profiles.active=dev
```

**Method 2: Command Line**

bash

```bash
java -jar myapp.jar --spring.profiles.active=prod
```

**Method 3: Environment Variable**

bash

```bash
export SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar
```

**Method 4: IDE Configuration (IntelliJ)**

```
Run ‚Üí Edit Configurations ‚Üí VM Options:
-Dspring.profiles.active=dev
```

**Step 5: Multiple Profiles**

properties

```properties
# Activate multiple profiles
spring.profiles.active=dev,debug,mock-services
```

### üîë Key Points to Remember

-   Properties in specific profiles override common properties
-   Multiple profiles can be active simultaneously
-   Use  `@Profile`  annotation for conditional bean creation
-   Environment variables take precedence over property files

----------

## 3. Actuator in Spring Boot

### üéØ Concept & Analogy

**Analogy**: Actuator is like the  **dashboard in your car**. It shows vital statistics: speed (performance), fuel (memory), engine temperature (health), and allows you to diagnose problems without opening the hood.

**Memory Visualization**:

```
Your Application
        ‚Üì
    Actuator
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üìä Metrics   ‚îÇ  ‚ù§Ô∏è Health     ‚îÇ
‚îÇ  üìù Logs      ‚îÇ  üîß Info       ‚îÇ
‚îÇ  üåê Mappings  ‚îÇ  üíæ Memory     ‚îÇ
‚îÇ  üîç Trace     ‚îÇ  üìà Prometheus ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üìö Theory

Spring Boot Actuator provides production-ready features to help monitor and manage your application:

**Key Endpoints**:

-   `/health`  - Application health status
-   `/info`  - Application information
-   `/metrics`  - Application metrics
-   `/env`  - Environment properties
-   `/loggers`  - Logger configuration
-   `/httptrace`  - HTTP trace information
-   `/threaddump`  - Thread dump
-   `/heapdump`  - Heap dump

**Security Consideration**: Actuator endpoints expose sensitive information. Always secure them in production!

### üíª Implementation

**Step 1: Add Dependency**

xml

```xml
<!-- Maven -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Step 2: Configuration**

properties

```properties
# Actuator Configuration (application.properties)

# Expose all endpoints (ONLY FOR DEV!)
management.endpoints.web.exposure.include=*

# Expose specific endpoints (PRODUCTION)
management.endpoints.web.exposure.include=health,info,metrics

# Base path for actuator
management.endpoints.web.base-path=/actuator

# Health endpoint details
management.endpoint.health.show-details=always

# Info endpoint
info.app.name=My Spring Boot Application
info.app.description=Advanced Spring Boot Tutorial
info.app.version=1.0.0
info.team.name=Development Team

# Enable specific endpoints
management.endpoint.shutdown.enabled=true
```

**Step 3: Custom Health Indicator**

java

```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        // Check custom health condition
        boolean isHealthy = checkExternalService();
        
        if (isHealthy) {
            return Health.up()
                .withDetail("service", "External API")
                .withDetail("status", "Available")
                .withDetail("responseTime", "120ms")
                .build();
        } else {
            return Health.down()
                .withDetail("service", "External API")
                .withDetail("status", "Unavailable")
                .withDetail("error", "Connection timeout")
                .build();
        }
    }
    
    private boolean checkExternalService() {
        // Your health check logic
        return true;
    }
}
```

**Step 4: Custom Info Contributor**

java

```java
@Component
public class CustomInfoContributor implements InfoContributor {
    
    @Override
    public void contribute(Info.Builder builder) {
        Map<String, Object> details = new HashMap<>();
        details.put("activeUsers", 1250);
        details.put("lastDeployment", LocalDateTime.now().minusDays(2));
        details.put("environment", "production");
        
        builder.withDetail("custom", details);
    }
}
```

**Step 5: Custom Metrics**

java

```java
@Service
public class OrderService {
    
    private final MeterRegistry meterRegistry;
    private final Counter orderCounter;
    
    public OrderService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.orderCounter = Counter.builder("orders.created")
            .description("Total orders created")
            .tag("type", "online")
            .register(meterRegistry);
    }
    
    public void createOrder(Order order) {
        // Business logic
        orderCounter.increment();
        
        // Record timing
        Timer.Sample sample = Timer.start(meterRegistry);
        processOrder(order);
        sample.stop(Timer.builder("order.processing.time")
            .register(meterRegistry));
    }
    
    private void processOrder(Order order) {
        // Process order
    }
}
```

**Step 6: Securing Actuator Endpoints**

java

```java
@Configuration
public class ActuatorSecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) 
            throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/actuator/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic();
        return http.build();
    }
}
```

**Step 7: Testing Endpoints**

bash

```bash
# Health check
curl http://localhost:8080/actuator/health

# Application info
curl http://localhost:8080/actuator/info

# All metrics
curl http://localhost:8080/actuator/metrics

# Specific metric
curl http://localhost:8080/actuator/metrics/jvm.memory.used

# Thread dump
curl http://localhost:8080/actuator/threaddump
```

### üîë Key Points to Remember

-   Never expose all endpoints in production
-   Always secure actuator endpoints
-   Use custom health indicators for critical dependencies
-   Integrate with monitoring tools (Prometheus, Grafana)
-   Health checks are crucial for container orchestration (Kubernetes)

----------

## 4. Spring Boot Admin Server & Clients

### üéØ Concept & Analogy

**Analogy**: Spring Boot Admin is like a  **smart home control panel**  that monitors all your IoT devices. Instead of checking each device individually, you have one central dashboard showing the status of everything.

**Memory Visualization**:

```
     Admin Server (Control Panel)
            ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì       ‚Üì       ‚Üì
Client 1  Client 2  Client 3
(App A)   (App B)   (App C)
    ‚Üì       ‚Üì       ‚Üì
Actuator Actuator Actuator
[Metrics][Metrics][Metrics]
```

### üìö Theory

Spring Boot Admin provides a web-based UI for managing and monitoring Spring Boot applications. It's built on top of Spring Boot Actuator.

**Features**:

-   Visual dashboard for multiple applications
-   Real-time monitoring
-   Health status with notifications
-   JVM and memory metrics
-   Log file viewing
-   Environment and configuration viewing
-   HTTP trace requests

### üíª Implementation

### Admin Server Setup

**Step 1: Create Admin Server Project**

xml

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Admin Server -->
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-server</artifactId>
        <version>3.1.8</version>
    </dependency>
    
    <!-- Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Security (Optional but recommended) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

**Step 2: Enable Admin Server**

java

```java
@SpringBootApplication
@EnableAdminServer
public class AdminServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AdminServerApplication.class, args);
    }
}
```

**Step 3: Admin Server Configuration**

properties

```properties
# application.properties
server.port=9090
spring.application.name=Admin-Server

# Security (if using Spring Security)
spring.security.user.name=admin
spring.security.user.password=admin123

# Notification settings
spring.boot.admin.notify.mail.enabled=false
```

**Step 4: Admin Server Security Configuration**

java

```java
@Configuration
public class SecurityConfig {
    
    private final AdminServerProperties adminServer;
    
    public SecurityConfig(AdminServerProperties adminServer) {
        this.adminServer = adminServer;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) 
            throws Exception {
        SavedRequestAwareAuthenticationSuccessHandler successHandler = 
            new SavedRequestAwareAuthenticationSuccessHandler();
        successHandler.setTargetUrlParameter("redirectTo");
        successHandler.setDefaultTargetUrl(
            adminServer.path("/"));
        
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(
                    adminServer.path("/assets/**"),
                    adminServer.path("/login")
                ).permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage(adminServer.path("/login"))
                .successHandler(successHandler)
            )
            .logout(logout -> logout
                .logoutUrl(adminServer.path("/logout"))
            )
            .csrf(csrf -> csrf
                .disable()
            );
        
        return http.build();
    }
}
```

### Client Application Setup

**Step 5: Add Client Dependencies**

xml

```xml
<!-- pom.xml for Client Application -->
<dependencies>
    <!-- Admin Client -->
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-client</artifactId>
        <version>3.1.8</version>
    </dependency>
    
    <!-- Actuator (Required) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**Step 6: Client Configuration**

properties

```properties
# application.properties (Client App)
server.port=8080
spring.application.name=My-Microservice

# Admin Server URL
spring.boot.admin.client.url=http://localhost:9090
spring.boot.admin.client.username=admin
spring.boot.admin.client.password=admin123

# Application metadata
spring.boot.admin.client.instance.metadata.user.name=client-app
spring.boot.admin.client.instance.metadata.user.password=secret

# Actuator endpoints
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

# Application info
info.app.name=My Microservice
info.app.version=1.0.0
```

**Step 7: Client Application**

java

```java
@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}

@RestController
@RequestMapping("/api")
class DemoController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello from Client Application!";
    }
    
    @GetMapping("/status")
    public Map<String, Object> status() {
        Map<String, Object> status = new HashMap<>();
        status.put("status", "running");
        status.put("timestamp", LocalDateTime.now());
        status.put("uptime", "2 hours");
        return status;
    }
}
```

**Step 8: Multiple Clients Registration**

java

```java
// Client 1 - Service A (Port 8081)
// Client 2 - Service B (Port 8082)
// Client 3 - Service C (Port 8083)

// Each client has same configuration pointing to Admin Server
// Admin Server will show all three applications in dashboard
```

**Step 9: Custom Notifications**

java

```java
@Configuration
public class NotificationConfig {
    
    @Bean
    public Notifier customNotifier() {
        return new AbstractStatusChangeNotifier() {
            @Override
            protected Mono<Void> doNotify(
                    InstanceEvent event, 
                    Instance instance) {
                
                return Mono.fromRunnable(() -> {
                    if (event instanceof InstanceStatusChangedEvent) {
                        System.out.println(
                            "Application: " + instance.getRegistration().getName() +
                            " Status changed to: " + 
                            ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus()
                        );
                        // Send email, Slack notification, etc.
                    }
                });
            }
        };
    }
}
```

### üîë Key Points to Remember

-   Admin Server provides centralized monitoring
-   Clients must have Actuator enabled
-   Secure both Admin Server and client endpoints
-   Use notifications for critical status changes
-   One Admin Server can monitor multiple applications
-   Great for microservices architecture

----------

## 5. Asynchronous Programming with @Async

### üéØ Concept & Analogy

**Analogy**: Think of @Async like  **ordering food at a restaurant**.

-   **Synchronous**: You wait at the counter until your order is ready (blocking)
-   **Asynchronous**: You get a buzzer and can sit down, chat, or use your phone while the kitchen prepares your food (non-blocking)

**Memory Visualization**:

```
Synchronous:                 Asynchronous:
Thread 1                     Thread 1 (Main)
   ‚Üì                            ‚Üì
Task A (5s) ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ          Task A ‚Üí Thread 2 ‚îÅ‚îÅ‚îÅ
   ‚Üì                            ‚Üì
Task B (3s) ‚îÅ‚îÅ‚îÅ              Task B ‚Üí Thread 3 ‚îÅ‚îÅ
   ‚Üì                            ‚Üì
Result (8s total)             Result (max 5s)
```

### üìö Theory

Asynchronous programming allows methods to execute in separate threads, improving application responsiveness and throughput.

**Key Concepts**:

-   **@Async**: Marks method for asynchronous execution
-   **@EnableAsync**: Enables async support in application
-   **Thread Pool**: Manages threads for async execution
-   **Future/CompletableFuture**: Represents async operation result

**When to Use Async**:

-   Long-running operations (file processing, external API calls)
-   Independent tasks that can run in parallel
-   Background jobs (email sending, report generation)
-   Operations that don't need immediate result

### üíª Implementation

**Step 1: Enable Async Support**

java

```java
@SpringBootApplication
@EnableAsync
public class AsyncApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncApplication.class, args);
    }
}
```

**Step 2: Configure Thread Pool**

java

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // Core pool size
        executor.setCorePoolSize(5);
        
        // Maximum pool size
        executor.setMaxPoolSize(10);
        
        // Queue capacity
        executor.setQueueCapacity(100);
        
        // Thread name prefix
        executor.setThreadNamePrefix("Async-");
        
        // Rejection policy
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // Wait for tasks to complete on shutdown
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        
        executor.initialize();
        return executor;
    }
}
```

**Step 3: Simple Async Method**

java

```java
@Service
public class NotificationService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(NotificationService.class);
    
    @Async
    public void sendEmail(String to, String subject, String body) {
        logger.info("Sending email on thread: " + 
            Thread.currentThread().getName());
        
        try {
            // Simulate email sending delay
            Thread.sleep(3000);
            logger.info("Email sent successfully to: " + to);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Email sending interrupted", e);
        }
    }
    
    @Async
    public void sendSMS(String phoneNumber, String message) {
        logger.info("Sending SMS on thread: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(2000);
            logger.info("SMS sent successfully to: " + phoneNumber);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("SMS sending interrupted", e);
        }
    }
}
```

**Step 4: Async with Return Value (Future)**

java

```java
@Service
public class DataProcessingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(DataProcessingService.class);
    
    @Async
    public Future<String> processDataSet1() {
        logger.info("Processing Dataset 1 on: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(3000);
            return new AsyncResult<>("Dataset 1 processed: 1000 records");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new AsyncResult<>("Dataset 1 failed");
        }
    }
    
    @Async
    public Future<String> processDataSet2() {
        logger.info("Processing Dataset 2 on: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(2000);
            return new AsyncResult<>("Dataset 2 processed: 500 records");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new AsyncResult<>("Dataset 2 failed");
        }
    }
}
```

**Step 5: Async with CompletableFuture**

java

```java
@Service
public class ReportService {
    
    @Async
    public CompletableFuture<Report> generateSalesReport() {
        try {
            // Simulate report generation
            Thread.sleep(4000);
            Report report = new Report("Sales", 15000.00, "Q4-2024");
            return CompletableFuture.completedFuture(report);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Async
    public CompletableFuture<Report> generateInventoryReport() {
        try {
            Thread.sleep(3000);
            Report report = new Report("Inventory", 0, "Q4-2024");
            return CompletableFuture.completedFuture(report);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CompletableFuture.failedFuture(e);
        }
    }
}

// Report class
class Report {
    private String type;
    private double value;
    private String period;
    
    // Constructor, getters, setters
    public Report(String type, double value, String period) {
        this.type = type;
        this.value = value;
        this.period = period;
    }
    
    // Getters and setters...
}
```

**Step 6: Controller Using Async Methods**

java

```java
@RestController
@RequestMapping("/async")
public class AsyncController {
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private DataProcessingService dataProcessingService;
    
    @Autowired
    private ReportService reportService;
    
    // Fire and forget
    @PostMapping("/notify")
    public ResponseEntity<String> sendNotifications() {
        long start = System.currentTimeMillis();
        
        // These run asynchronously
        notificationService.sendEmail(
            "user@example.com", 
            "Welcome", 
            "Welcome to our service"
        );
        notificationService.sendSMS(
            "+1234567890", 
            "Welcome SMS"
        );
        
        long end = System.currentTimeMillis();
        
        return ResponseEntity.ok(
            "Notifications triggered in " + (end - start) + "ms"
        );
    }
    
    // Wait for results
    @GetMapping("/process")
    public ResponseEntity<Map<String, String>> processData() 
            throws Exception {
        long start = System.currentTimeMillis();
        
        // Start async tasks
        Future<String> result1 = dataProcessingService.processDataSet1();
        Future<String> result2 = dataProcessingService.processDataSet2();
        
        // Wait for both to complete
        while (!result1.isDone() || !result2.isDone()) {
            Thread.sleep(100);
        }
        
        long end = System.currentTimeMillis();
        
        Map<String, String> results = new HashMap<>();
        results.put("dataset1", result1.get());
        results.put("dataset2", result2.get());
        results.put("totalTime", (end - start) + "ms");
        
        return ResponseEntity.ok(results);
    }
    
    // CompletableFuture composition
    @GetMapping("/reports")
    public CompletableFuture<Map<String, Object>> generateReports() {
        
        CompletableFuture<Report> salesFuture = 
            reportService.generateSalesReport();
        CompletableFuture<Report> inventoryFuture = 
            reportService.generateInventoryReport();
        
        // Combine both results
        return salesFuture.thenCombine(inventoryFuture, 
            (salesReport, inventoryReport) -> {
                Map<String, Object> combined = new HashMap<>();
                combined.put("sales", salesReport);
                combined.put("inventory", inventoryReport);
                combined.put("generatedAt", LocalDateTime.now());
                return combined;
            });
    }
}
```

**Step 7: Exception Handling in Async**

java

```java
@Service
public class AsyncExceptionService {
    
    @Async
    public CompletableFuture<String> riskyOperation() {
        try {
            // Simulate processing
            if (Math.random() > 0.5) {
                throw new RuntimeException("Random failure!");
            }
            return CompletableFuture.completedFuture("Success");
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
}

// Async Exception Handler
@ControllerAdvice
public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(AsyncExceptionHandler.class);
    
    @Override
    public void handleUncaughtException(
            Throwable throwable, 
            Method method, 
            Object... params) {
        
        logger.error("Async exception in method: " + method.getName());
        logger.error("Exception: " + throwable.getMessage());
        logger.error("Parameters: " + Arrays.toString(params));
    }
}

// Configure exception handler
@Configuration
@EnableAsync
public class AsyncConfigWithExceptionHandler 
        implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}
```

**Step 8: Testing Async Methods**

java

```java
@SpringBootTest
class AsyncServiceTest {
    
    @Autowired
    private DataProcessingService dataProcessingService;
    
    @Test
    void testAsyncExecution() throws Exception {
        long start = System.currentTimeMillis();
        
        Future<String> result1 = dataProcessingService.processDataSet1();
        Future<String> result2 = dataProcessingService.processDataSet2();
        
        // Wait for completion
        while (!result1.isDone() || !result2.isDone()) {
            Thread.sleep(100);
        }
        
        long end = System.currentTimeMillis();
        
        assertNotNull(result1.get());
        assertNotNull(result2.get());
        
        // Should take around 3 seconds (parallel), not 5 (sequential)
        assertTrue((end - start) < 4000);
    }
}
```

### üîë Key Points to Remember

-   **@Async methods must be in Spring-managed beans**
-   **Calling @Async from same class won't work**  (use proxy)
-   Configure thread pool size based on workload
-   Use CompletableFuture for complex async compositions
-   Handle exceptions properly in async methods
-   Monitor thread pool metrics in production

**Common Pitfalls**:

java

```java
// ‚ùå WRONG - Calling async method from same class
@Service
public class WrongService {
    @Async
    public void asyncMethod() { }
    
    public void normalMethod() {
        this.asyncMethod(); // Won't be async!
    }
}

// ‚úÖ CORRECT - Inject bean and call
@Service
public class CorrectService {
    @Autowired
    private AsyncHelper asyncHelper;
    
    public void normalMethod() {
        asyncHelper.asyncMethod(); // Will be async
    }
}
```

----------

## 6. Logging in Spring Boot

### üéØ Concept & Analogy

**Analogy**: Logging is like a  **flight recorder (black box)**  in an airplane. It continuously records everything happening during the flight. If something goes wrong, investigators can review the logs to understand what happened.

**Memory Visualization**:

```
Application Flow
      ‚Üì
  Logger Levels
      ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ TRACE (Most)    ‚îÇ ‚Üê Everything
‚îÇ DEBUG           ‚îÇ ‚Üê Development details
‚îÇ INFO            ‚îÇ ‚Üê Important events
‚îÇ WARN            ‚îÇ ‚Üê Potential issues
‚îÇ ERROR (Least)   ‚îÇ ‚Üê Actual problems
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Console  ‚îÇ  File   ‚îÇ  Cloud  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üìö Theory

Spring Boot uses  **Commons Logging**  internally but supports various logging frameworks:

-   **Logback**  (default)
-   **Log4j2**
-   **Java Util Logging**

**Log Levels**  (Least to Most verbose):

1.  **OFF**  - No logging
2.  **ERROR**  - Error events
3.  **WARN**  - Potentially harmful situations
4.  **INFO**  - Informational messages
5.  **DEBUG**  - Debug information
6.  **TRACE**  - Most detailed information
7.  **ALL**  - All logging

**Logging Best Practices**:

-   Use appropriate log levels
-   Include contextual information
-   Avoid logging sensitive data (passwords, credit cards)
-   Use parameterized logging for performance
-   Configure different levels for different environments

### üíª Implementation

**Step 1: Default Logging (No Configuration)**

java

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api")
public class ProductController {
    
    // Create logger instance
    private static final Logger logger = 
        LoggerFactory.getLogger(ProductController.class);
    
    @GetMapping("/products/{id}")
    public Product getProduct(@PathVariable Long id) {
        logger.trace("TRACE: Entering getProduct method");
        logger.debug("DEBUG: Fetching product with ID: {}", id);
        logger.info("INFO: Product request received for ID: {}", id);
        
        try {
            Product product = productService.findById(id);
            logger.info("INFO: Product found: {}", product.getName());
            return product;
        } catch (Exception e) {
            logger.error("ERROR: Failed to fetch product with ID: {}", id, e);
            throw e;
        }
    }
}
```

**Step 2: Configuration via application.properties**

properties

```properties
# Root logging level
logging.level.root=INFO

# Package-specific logging levels
logging.level.com.myapp=DEBUG
logging.level.com.myapp.controller=TRACE
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR

# Log file configuration
logging.file.name=logs/application.log
logging.file.path=logs/

# Log file rotation
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=30
logging.logback.rollingpolicy.total-size-cap=1GB

# Log pattern for console
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n

# Log pattern for file
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
```

**Step 3: Logback Configuration (logback-spring.xml)**

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>
    
    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        
        <!-- Rolling Policy -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy 
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- Error File Appender -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/error-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- JSON Appender (for log aggregation) -->
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.json</file>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"app":"my-spring-boot-app"}</customFields>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.json</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- Async Appender for better performance -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- Logger for specific package -->
    <logger name="com.myapp.controller" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </logger>
    
    <logger name="com.myapp.service" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </logger>
    
    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>
    
    <!-- Profile-specific configuration -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <root level="WARN">
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ERROR_FILE" />
            <appender-ref ref="JSON_FILE" />
        </root>
    </springProfile>
    
</configuration>
```

**Step 4: Structured Logging with MDC (Mapped Diagnostic Context)**

java

```java
@Component
public class LoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // Add contextual information to MDC
        MDC.put("requestId", UUID.randomUUID().toString());
        MDC.put("userId", getUserIdFromRequest(httpRequest));
        MDC.put("ipAddress", httpRequest.getRemoteAddr());
        MDC.put("requestUri", httpRequest.getRequestURI());
        
        try {
            chain.doFilter(request, response);
        } finally {
            // Clean up MDC
            MDC.clear();
        }
    }
    
    private String getUserIdFromRequest(HttpServletRequest request) {
        // Extract user ID from session or JWT token
        return "user123";
    }
}

// Using MDC in logs
@Service
public class OrderService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(OrderService.class);
    
    public void createOrder(Order order) {
        MDC.put("orderId", order.getId().toString());
        logger.info("Creating order"); // Will include orderId in log
        
        // Business logic
        
        MDC.remove("orderId");
    }
}
```

**Logback pattern with MDC**:

xml

```xml
<pattern>
    %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} [RequestId:%X{requestId}] [UserId:%X{userId}] - %msg%n
</pattern>
```

**Step 5: Custom Logger with Aspects**

java

```java
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(LoggingAspect.class);
    
    // Log all controller methods
    @Around("execution(* com.myapp.controller..*(..))")
    public Object logControllerMethods(ProceedingJoinPoint joinPoint) 
            throws Throwable {
        
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        
        logger.info("Entering {}.{}", className, methodName);
        
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            
            long endTime = System.currentTimeMillis();
            logger.info("Exiting {}.{} - Execution time: {}ms", 
                className, methodName, (endTime - startTime));
            
            return result;
        } catch (Exception e) {
            logger.error("Exception in {}.{}: {}", 
                className, methodName, e.getMessage(), e);
            throw e;
        }
    }
    
    // Log all service methods with parameters
    @Around("execution(* com.myapp.service..*(..))")
    public Object logServiceMethods(ProceedingJoinPoint joinPoint) 
            throws Throwable {
        
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        logger.debug("Service method: {} called with args: {}", 
            methodName, Arrays.toString(args));
        
        Object result = joinPoint.proceed();
        
        logger.debug("Service method: {} returned: {}", 
            methodName, result);
        
        return result;
    }
}
```

**Step 6: Logging Best Practices Examples**

java

```java
@Service
public class BestPracticesService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(BestPracticesService.class);
    
    // ‚úÖ GOOD: Parameterized logging (better performance)
    public void goodLogging(String username, int age) {
        logger.info("User {} logged in, age: {}", username, age);
    }
    
    // ‚ùå BAD: String concatenation
    public void badLogging(String username, int age) {
        logger.info("User " + username + " logged in, age: " + age);
    }
    
    // ‚úÖ GOOD: Guard conditions for expensive operations
    public void conditionalLogging(Object complexObject) {
        if (logger.isDebugEnabled()) {
            logger.debug("Complex object state: {}", 
                expensiveToString(complexObject));
        }
    }
    
    // ‚úÖ GOOD: Logging exceptions with context
    public void exceptionLogging(String userId) {
        try {
            // Some operation
        } catch (Exception e) {
            logger.error("Failed to process user: {}", userId, e);
            // 'e' will print full stack trace
        }
    }
    
    // ‚úÖ GOOD: Structured logging
    public void structuredLogging(Order order) {
        logger.info("Order processed - " +
            "orderId: {}, userId: {}, amount: {}, status: {}", 
            order.getId(), 
            order.getUserId(), 
            order.getAmount(), 
            order.getStatus()
        );
    }
    
    // ‚ùå BAD: Logging sensitive information
    public void dontLogSensitiveData(User user) {
        // Never log passwords, credit cards, SSN, etc.
        logger.info("User: {}", user); // If User.toString() includes password
    }
    
    // ‚úÖ GOOD: Sanitize sensitive data
    public void sanitizeLogging(User user) {
        logger.info("User logged in: username={}, email={}", 
            user.getUsername(), 
            maskEmail(user.getEmail())
        );
    }
    
    private String maskEmail(String email) {
        return email.replaceAll("(^[^@]{3})[^@]*", "$1***");
    }
    
    private String expensiveToString(Object obj) {
        // Expensive operation
        return obj.toString();
    }
}
```

**Step 7: Log Aggregation with ELK Stack Integration**

xml

```xml
<!-- Add Logstash Logback Encoder -->
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>7.4</version>
</dependency>
```

java

```java
// Custom JSON logging
@Service
public class JsonLoggingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(JsonLoggingService.class);
    
    public void logStructuredEvent(String eventType, Map<String, Object> data) {
        ObjectNode logNode = JsonNodeFactory.instance.objectNode();
        logNode.put("eventType", eventType);
        logNode.put("timestamp", Instant.now().toString());
        logNode.set("data", convertToJsonNode(data));
        
        logger.info(logNode.toString());
    }
    
    private JsonNode convertToJsonNode(Map<String, Object> data) {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.valueToTree(data);
    }
}
```

**Step 8: Performance Monitoring with Logs**

java

```java
@Service
public class PerformanceLoggingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(PerformanceLoggingService.class);
    
    public void monitoredOperation(String operationName) {
        StopWatch stopWatch = new StopWatch(operationName);
        stopWatch.start();
        
        try {
            // Perform operation
            performHeavyOperation();
            
            stopWatch.stop();
            
            if (stopWatch.getTotalTimeMillis() > 1000) {
                logger.warn("Slow operation detected: {} took {}ms", 
                    operationName, 
                    stopWatch.getTotalTimeMillis()
                );
            } else {
                logger.debug("Operation {} completed in {}ms", 
                    operationName, 
                    stopWatch.getTotalTimeMillis()
                );
            }
        } catch (Exception e) {
            stopWatch.stop();
            logger.error("Operation {} failed after {}ms", 
                operationName, 
                stopWatch.getTotalTimeMillis(), 
                e
            );
            throw e;
        }
    }
    
    private void performHeavyOperation() {
        // Heavy operation
    }
}
```

**Step 9: Testing Logging**

java

```java
@SpringBootTest
class LoggingTest {
    
    @Autowired
    private ProductController productController;
    
    @Test
    void testLogging() {
        // Configure test appender
        Logger logger = (Logger) LoggerFactory.getLogger(
            ProductController.class
        );
        
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);
        
        // Execute method
        productController.getProduct(1L);
        
        // Verify logs
        List<ILoggingEvent> logsList = listAppender.list;
        
        assertTrue(logsList.stream()
            .anyMatch(event -> 
                event.getMessage().contains("Product request received")
            )
        );
    }
}
```

**Step 10: Environment-Specific Logging**

yaml

```yaml
# application-dev.yml
logging:
  level:
    root: DEBUG
    com.myapp: TRACE
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/dev-application.log

# application-prod.yml
logging:
  level:
    root: WARN
    com.myapp: INFO
  pattern:
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n"
  file:
    name: /var/log/myapp/application.log
    max-size: 100MB
    max-history: 30
```

### üîë Key Points to Remember

-   **Use SLF4J**  as logging facade (abstraction)
-   **Choose appropriate log levels**: ERROR for failures, WARN for potential issues, INFO for important events, DEBUG for development
-   **Use parameterized logging**  for better performance
-   **Never log sensitive data**  (passwords, tokens, PII)
-   **Configure log rotation**  to prevent disk space issues
-   **Use MDC**  for request tracing and correlation
-   **Different configurations**  for different environments
-   **Async appenders**  for better performance in production
-   **Integrate with log aggregation**  tools (ELK, Splunk, CloudWatch)

----------

## üìä Quick Reference Comparison
<img width="818" height="247" alt="image" src="https://github.com/user-attachments/assets/7cc2f4b3-9278-4ffb-bbcf-e1d3b71d0036" />

## üí° Real-World Scenario: Complete Application

java

```java
@SpringBootApplication
@EnableAsync
@EnableAdminServer  // If admin server
public class CompleteApplication {
    public static void main(String[] args) {
        SpringApplication.run(CompleteApplication.class, args);
    }
}

@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(OrderController.class);
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private NotificationService notificationService;
    
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody Order order) {
        // Add request ID to MDC for tracing
        MDC.put("orderId", order.getId());
        
        logger.info("Received order creation request");
        
        try {
            // Process order (sync)
            Order savedOrder = orderService.saveOrder(order);
            logger.info("Order saved successfully");
            
            // Send notifications (async - fire and forget)
            notificationService.sendOrderConfirmation(savedOrder);
            logger.debug("Order confirmation triggered");
            
            return ResponseEntity.ok(savedOrder);
        } catch (Exception e) {
            logger.error("Failed to create order", e);
            return ResponseEntity.internalServerError().build();
        } finally {
            MDC.clear();
        }
    }
}
```

----------

## üéØ Practice Exercises

1.  **DevTools**: Create a REST API and modify it to see auto-restart
2.  **Profiles**: Configure H2 for dev, PostgreSQL for prod
3.  **Actuator**: Create custom health indicator for database
4.  **Admin**: Set up admin server with 3 client applications
5.  **Async**: Build file upload service with async processing
6.  **Logging**: Implement request/response logging with MDC

----------
