# Spring Boot Advanced Features: Complete Tutorial Guide

## Table of Contents

1.  Spring Boot DevTools
2.  Profiles in Spring Boot
3.  Actuator in Spring Boot
4.  Spring Boot Admin Server & Clients
5.  Asynchronous Programming with @Async
6.  Logging in Spring Boot

----------

## 1. Spring Boot DevTools

### 🎯 Concept & Analogy

**Analogy**: Think of DevTools as a  **"live reload button"**  for your development environment. Just like how modern IDEs auto-save your work, DevTools automatically restarts your application when you make changes.

**Memory Visualization**:

```
Without DevTools:          With DevTools:
Code Change                Code Change
    ↓                          ↓
Stop Server               Auto Detect
    ↓                          ↓
Rebuild                    Quick Restart
    ↓                          ↓
Start Server              Ready! (2-3 sec)
    ↓
Wait (30+ sec)
```

### 📚 Theory

Spring Boot DevTools provides developer-friendly features:

-   **Automatic Restart**: Restarts application when classpath changes
-   **Live Reload**: Browser auto-refresh (with browser extension)
-   **Property Defaults**: Disables template caching in development
-   **Remote Development**: Debug applications running remotely

**How it works**: DevTools uses two classloaders:

-   **Base classloader**: Loads third-party JARs (doesn't change)
-   **Restart classloader**: Loads your application code (restarts on change)

### 💻 Implementation

**Step 1: Add Dependency**

xml

```xml
<!-- Maven -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

gradle

```gradle
// Gradle
developmentOnly 'org.springframework.boot:spring-boot-devtools'
```

**Step 2: Configuration (application.properties)**

properties

```properties
# Enable/Disable DevTools
spring.devtools.restart.enabled=true

# Additional paths to watch
spring.devtools.restart.additional-paths=src/main/resources

# Exclude paths from restart
spring.devtools.restart.exclude=static/**,public/**

# Enable live reload
spring.devtools.livereload.enabled=true
```

**Step 3: Example Controller**

java

```java
@RestController
@RequestMapping("/api")
public class DevToolsDemo {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello from DevTools! Change me and see auto-restart!";
    }
}
```

### 🔑 Key Points to Remember

-   DevTools is  **automatically disabled**  in production
-   Works only when running from IDE or  `java -jar`
-   Restart is faster than full application startup
-   Not included in packaged artifacts by default

----------

## 2. Profiles in Spring Boot

### 🎯 Concept & Analogy

**Analogy**: Profiles are like  **wardrobe changes for different occasions**. You wear different clothes for work, gym, and parties. Similarly, your application needs different configurations for development, testing, and production.

**Memory Visualization**:

```
Application
    ↓
Environment Detection
    ↓
┌───────────┬───────────┬────────────┐
│   DEV     │   TEST    │    PROD    │
├───────────┼───────────┼────────────┤
│ H2 DB     │ MySQL     │ PostgreSQL │
│ Debug ON  │ Debug ON  │ Debug OFF  │
│ Port 8080 │ Port 8081 │ Port 80    │
└───────────┴───────────┴────────────┘
```

### 📚 Theory

Profiles provide a way to segregate application configuration and make it available only in certain environments.

**Profile Activation Priority**:

1.  Command line arguments
2.  Environment variables
3.  application.properties
4.  Default profile

### 💻 Implementation

**Step 1: Create Profile-Specific Properties Files**

```
src/main/resources/
├── application.properties          # Common properties
├── application-dev.properties      # Development
├── application-test.properties     # Testing
└── application-prod.properties     # Production
```

**application.properties**  (Common)

properties

```properties
# Common configuration
app.name=MySpringBootApp
app.version=1.0.0

# Active profile
spring.profiles.active=dev
```

**application-dev.properties**

properties

```properties
# Development Database
spring.datasource.url=jdbc:h2:mem:devdb
spring.datasource.username=sa
spring.datasource.password=

# Logging
logging.level.root=DEBUG
logging.level.com.myapp=TRACE

# Server
server.port=8080
```

**application-prod.properties**

properties

```properties
# Production Database
spring.datasource.url=jdbc:postgresql://prod-server:5432/proddb
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}

# Logging
logging.level.root=WARN
logging.level.com.myapp=INFO

# Server
server.port=80
```

**Step 2: Profile-Specific Beans**

java

```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setMaximumPoolSize(10);
        // Configure production datasource
        return dataSource;
    }
}
```

**Step 3: Using Profiles in Code**

java

```java
@Service
public class EmailService {
    
    @Value("${spring.profiles.active}")
    private String activeProfile;
    
    public void sendEmail(String to, String message) {
        if ("dev".equals(activeProfile)) {
            System.out.println("DEV MODE: Email to " + to + ": " + message);
        } else {
            // Actually send email in production
            actualEmailSender.send(to, message);
        }
    }
}
```

**Step 4: Profile Activation Methods**

**Method 1: In application.properties**

properties

```properties
spring.profiles.active=dev
```

**Method 2: Command Line**

bash

```bash
java -jar myapp.jar --spring.profiles.active=prod
```

**Method 3: Environment Variable**

bash

```bash
export SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar
```

**Method 4: IDE Configuration (IntelliJ)**

```
Run → Edit Configurations → VM Options:
-Dspring.profiles.active=dev
```

**Step 5: Multiple Profiles**

properties

```properties
# Activate multiple profiles
spring.profiles.active=dev,debug,mock-services
```

### 🔑 Key Points to Remember

-   Properties in specific profiles override common properties
-   Multiple profiles can be active simultaneously
-   Use  `@Profile`  annotation for conditional bean creation
-   Environment variables take precedence over property files

----------

## 3. Actuator in Spring Boot

### 🎯 Concept & Analogy

**Analogy**: Actuator is like the  **dashboard in your car**. It shows vital statistics: speed (performance), fuel (memory), engine temperature (health), and allows you to diagnose problems without opening the hood.

**Memory Visualization**:

```
Your Application
        ↓
    Actuator
        ↓
┌────────────────────────────────┐
│  📊 Metrics   │  ❤️ Health     │
│  📝 Logs      │  🔧 Info       │
│  🌐 Mappings  │  💾 Memory     │
│  🔍 Trace     │  📈 Prometheus │
└────────────────────────────────┘
```

### 📚 Theory

Spring Boot Actuator provides production-ready features to help monitor and manage your application:

**Key Endpoints**:

-   `/health`  - Application health status
-   `/info`  - Application information
-   `/metrics`  - Application metrics
-   `/env`  - Environment properties
-   `/loggers`  - Logger configuration
-   `/httptrace`  - HTTP trace information
-   `/threaddump`  - Thread dump
-   `/heapdump`  - Heap dump

**Security Consideration**: Actuator endpoints expose sensitive information. Always secure them in production!

### 💻 Implementation

**Step 1: Add Dependency**

xml

```xml
<!-- Maven -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Step 2: Configuration**

properties

```properties
# Actuator Configuration (application.properties)

# Expose all endpoints (ONLY FOR DEV!)
management.endpoints.web.exposure.include=*

# Expose specific endpoints (PRODUCTION)
management.endpoints.web.exposure.include=health,info,metrics

# Base path for actuator
management.endpoints.web.base-path=/actuator

# Health endpoint details
management.endpoint.health.show-details=always

# Info endpoint
info.app.name=My Spring Boot Application
info.app.description=Advanced Spring Boot Tutorial
info.app.version=1.0.0
info.team.name=Development Team

# Enable specific endpoints
management.endpoint.shutdown.enabled=true
```

**Step 3: Custom Health Indicator**

java

```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        // Check custom health condition
        boolean isHealthy = checkExternalService();
        
        if (isHealthy) {
            return Health.up()
                .withDetail("service", "External API")
                .withDetail("status", "Available")
                .withDetail("responseTime", "120ms")
                .build();
        } else {
            return Health.down()
                .withDetail("service", "External API")
                .withDetail("status", "Unavailable")
                .withDetail("error", "Connection timeout")
                .build();
        }
    }
    
    private boolean checkExternalService() {
        // Your health check logic
        return true;
    }
}
```

**Step 4: Custom Info Contributor**

java

```java
@Component
public class CustomInfoContributor implements InfoContributor {
    
    @Override
    public void contribute(Info.Builder builder) {
        Map<String, Object> details = new HashMap<>();
        details.put("activeUsers", 1250);
        details.put("lastDeployment", LocalDateTime.now().minusDays(2));
        details.put("environment", "production");
        
        builder.withDetail("custom", details);
    }
}
```

**Step 5: Custom Metrics**

java

```java
@Service
public class OrderService {
    
    private final MeterRegistry meterRegistry;
    private final Counter orderCounter;
    
    public OrderService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.orderCounter = Counter.builder("orders.created")
            .description("Total orders created")
            .tag("type", "online")
            .register(meterRegistry);
    }
    
    public void createOrder(Order order) {
        // Business logic
        orderCounter.increment();
        
        // Record timing
        Timer.Sample sample = Timer.start(meterRegistry);
        processOrder(order);
        sample.stop(Timer.builder("order.processing.time")
            .register(meterRegistry));
    }
    
    private void processOrder(Order order) {
        // Process order
    }
}
```

**Step 6: Securing Actuator Endpoints**

java

```java
@Configuration
public class ActuatorSecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) 
            throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/actuator/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic();
        return http.build();
    }
}
```

**Step 7: Testing Endpoints**

bash

```bash
# Health check
curl http://localhost:8080/actuator/health

# Application info
curl http://localhost:8080/actuator/info

# All metrics
curl http://localhost:8080/actuator/metrics

# Specific metric
curl http://localhost:8080/actuator/metrics/jvm.memory.used

# Thread dump
curl http://localhost:8080/actuator/threaddump
```

### 🔑 Key Points to Remember

-   Never expose all endpoints in production
-   Always secure actuator endpoints
-   Use custom health indicators for critical dependencies
-   Integrate with monitoring tools (Prometheus, Grafana)
-   Health checks are crucial for container orchestration (Kubernetes)

----------

## 4. Spring Boot Admin Server & Clients

### 🎯 Concept & Analogy

**Analogy**: Spring Boot Admin is like a  **smart home control panel**  that monitors all your IoT devices. Instead of checking each device individually, you have one central dashboard showing the status of everything.

**Memory Visualization**:

```
     Admin Server (Control Panel)
            ↓
    ┌───────┴───────┐
    ↓       ↓       ↓
Client 1  Client 2  Client 3
(App A)   (App B)   (App C)
    ↓       ↓       ↓
Actuator Actuator Actuator
[Metrics][Metrics][Metrics]
```

### 📚 Theory

Spring Boot Admin provides a web-based UI for managing and monitoring Spring Boot applications. It's built on top of Spring Boot Actuator.

**Features**:

-   Visual dashboard for multiple applications
-   Real-time monitoring
-   Health status with notifications
-   JVM and memory metrics
-   Log file viewing
-   Environment and configuration viewing
-   HTTP trace requests

### 💻 Implementation

### Admin Server Setup

**Step 1: Create Admin Server Project**

xml

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Admin Server -->
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-server</artifactId>
        <version>3.1.8</version>
    </dependency>
    
    <!-- Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Security (Optional but recommended) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

**Step 2: Enable Admin Server**

java

```java
@SpringBootApplication
@EnableAdminServer
public class AdminServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AdminServerApplication.class, args);
    }
}
```

**Step 3: Admin Server Configuration**

properties

```properties
# application.properties
server.port=9090
spring.application.name=Admin-Server

# Security (if using Spring Security)
spring.security.user.name=admin
spring.security.user.password=admin123

# Notification settings
spring.boot.admin.notify.mail.enabled=false
```

**Step 4: Admin Server Security Configuration**

java

```java
@Configuration
public class SecurityConfig {
    
    private final AdminServerProperties adminServer;
    
    public SecurityConfig(AdminServerProperties adminServer) {
        this.adminServer = adminServer;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) 
            throws Exception {
        SavedRequestAwareAuthenticationSuccessHandler successHandler = 
            new SavedRequestAwareAuthenticationSuccessHandler();
        successHandler.setTargetUrlParameter("redirectTo");
        successHandler.setDefaultTargetUrl(
            adminServer.path("/"));
        
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(
                    adminServer.path("/assets/**"),
                    adminServer.path("/login")
                ).permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage(adminServer.path("/login"))
                .successHandler(successHandler)
            )
            .logout(logout -> logout
                .logoutUrl(adminServer.path("/logout"))
            )
            .csrf(csrf -> csrf
                .disable()
            );
        
        return http.build();
    }
}
```

### Client Application Setup

**Step 5: Add Client Dependencies**

xml

```xml
<!-- pom.xml for Client Application -->
<dependencies>
    <!-- Admin Client -->
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-client</artifactId>
        <version>3.1.8</version>
    </dependency>
    
    <!-- Actuator (Required) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**Step 6: Client Configuration**

properties

```properties
# application.properties (Client App)
server.port=8080
spring.application.name=My-Microservice

# Admin Server URL
spring.boot.admin.client.url=http://localhost:9090
spring.boot.admin.client.username=admin
spring.boot.admin.client.password=admin123

# Application metadata
spring.boot.admin.client.instance.metadata.user.name=client-app
spring.boot.admin.client.instance.metadata.user.password=secret

# Actuator endpoints
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

# Application info
info.app.name=My Microservice
info.app.version=1.0.0
```

**Step 7: Client Application**

java

```java
@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}

@RestController
@RequestMapping("/api")
class DemoController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello from Client Application!";
    }
    
    @GetMapping("/status")
    public Map<String, Object> status() {
        Map<String, Object> status = new HashMap<>();
        status.put("status", "running");
        status.put("timestamp", LocalDateTime.now());
        status.put("uptime", "2 hours");
        return status;
    }
}
```

**Step 8: Multiple Clients Registration**

java

```java
// Client 1 - Service A (Port 8081)
// Client 2 - Service B (Port 8082)
// Client 3 - Service C (Port 8083)

// Each client has same configuration pointing to Admin Server
// Admin Server will show all three applications in dashboard
```

**Step 9: Custom Notifications**

java

```java
@Configuration
public class NotificationConfig {
    
    @Bean
    public Notifier customNotifier() {
        return new AbstractStatusChangeNotifier() {
            @Override
            protected Mono<Void> doNotify(
                    InstanceEvent event, 
                    Instance instance) {
                
                return Mono.fromRunnable(() -> {
                    if (event instanceof InstanceStatusChangedEvent) {
                        System.out.println(
                            "Application: " + instance.getRegistration().getName() +
                            " Status changed to: " + 
                            ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus()
                        );
                        // Send email, Slack notification, etc.
                    }
                });
            }
        };
    }
}
```

### 🔑 Key Points to Remember

-   Admin Server provides centralized monitoring
-   Clients must have Actuator enabled
-   Secure both Admin Server and client endpoints
-   Use notifications for critical status changes
-   One Admin Server can monitor multiple applications
-   Great for microservices architecture

----------

## 5. Asynchronous Programming with @Async

### 🎯 Concept & Analogy

**Analogy**: Think of @Async like  **ordering food at a restaurant**.

-   **Synchronous**: You wait at the counter until your order is ready (blocking)
-   **Asynchronous**: You get a buzzer and can sit down, chat, or use your phone while the kitchen prepares your food (non-blocking)

**Memory Visualization**:

```
Synchronous:                 Asynchronous:
Thread 1                     Thread 1 (Main)
   ↓                            ↓
Task A (5s) ━━━━━━━          Task A → Thread 2 ━━━
   ↓                            ↓
Task B (3s) ━━━              Task B → Thread 3 ━━
   ↓                            ↓
Result (8s total)             Result (max 5s)
```

### 📚 Theory

Asynchronous programming allows methods to execute in separate threads, improving application responsiveness and throughput.

**Key Concepts**:

-   **@Async**: Marks method for asynchronous execution
-   **@EnableAsync**: Enables async support in application
-   **Thread Pool**: Manages threads for async execution
-   **Future/CompletableFuture**: Represents async operation result

**When to Use Async**:

-   Long-running operations (file processing, external API calls)
-   Independent tasks that can run in parallel
-   Background jobs (email sending, report generation)
-   Operations that don't need immediate result

### 💻 Implementation

**Step 1: Enable Async Support**

java

```java
@SpringBootApplication
@EnableAsync
public class AsyncApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncApplication.class, args);
    }
}
```

**Step 2: Configure Thread Pool**

java

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // Core pool size
        executor.setCorePoolSize(5);
        
        // Maximum pool size
        executor.setMaxPoolSize(10);
        
        // Queue capacity
        executor.setQueueCapacity(100);
        
        // Thread name prefix
        executor.setThreadNamePrefix("Async-");
        
        // Rejection policy
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // Wait for tasks to complete on shutdown
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        
        executor.initialize();
        return executor;
    }
}
```

**Step 3: Simple Async Method**

java

```java
@Service
public class NotificationService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(NotificationService.class);
    
    @Async
    public void sendEmail(String to, String subject, String body) {
        logger.info("Sending email on thread: " + 
            Thread.currentThread().getName());
        
        try {
            // Simulate email sending delay
            Thread.sleep(3000);
            logger.info("Email sent successfully to: " + to);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Email sending interrupted", e);
        }
    }
    
    @Async
    public void sendSMS(String phoneNumber, String message) {
        logger.info("Sending SMS on thread: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(2000);
            logger.info("SMS sent successfully to: " + phoneNumber);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("SMS sending interrupted", e);
        }
    }
}
```

**Step 4: Async with Return Value (Future)**

java

```java
@Service
public class DataProcessingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(DataProcessingService.class);
    
    @Async
    public Future<String> processDataSet1() {
        logger.info("Processing Dataset 1 on: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(3000);
            return new AsyncResult<>("Dataset 1 processed: 1000 records");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new AsyncResult<>("Dataset 1 failed");
        }
    }
    
    @Async
    public Future<String> processDataSet2() {
        logger.info("Processing Dataset 2 on: " + 
            Thread.currentThread().getName());
        
        try {
            Thread.sleep(2000);
            return new AsyncResult<>("Dataset 2 processed: 500 records");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return new AsyncResult<>("Dataset 2 failed");
        }
    }
}
```

**Step 5: Async with CompletableFuture**

java

```java
@Service
public class ReportService {
    
    @Async
    public CompletableFuture<Report> generateSalesReport() {
        try {
            // Simulate report generation
            Thread.sleep(4000);
            Report report = new Report("Sales", 15000.00, "Q4-2024");
            return CompletableFuture.completedFuture(report);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Async
    public CompletableFuture<Report> generateInventoryReport() {
        try {
            Thread.sleep(3000);
            Report report = new Report("Inventory", 0, "Q4-2024");
            return CompletableFuture.completedFuture(report);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CompletableFuture.failedFuture(e);
        }
    }
}

// Report class
class Report {
    private String type;
    private double value;
    private String period;
    
    // Constructor, getters, setters
    public Report(String type, double value, String period) {
        this.type = type;
        this.value = value;
        this.period = period;
    }
    
    // Getters and setters...
}
```

**Step 6: Controller Using Async Methods**

java

```java
@RestController
@RequestMapping("/async")
public class AsyncController {
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private DataProcessingService dataProcessingService;
    
    @Autowired
    private ReportService reportService;
    
    // Fire and forget
    @PostMapping("/notify")
    public ResponseEntity<String> sendNotifications() {
        long start = System.currentTimeMillis();
        
        // These run asynchronously
        notificationService.sendEmail(
            "user@example.com", 
            "Welcome", 
            "Welcome to our service"
        );
        notificationService.sendSMS(
            "+1234567890", 
            "Welcome SMS"
        );
        
        long end = System.currentTimeMillis();
        
        return ResponseEntity.ok(
            "Notifications triggered in " + (end - start) + "ms"
        );
    }
    
    // Wait for results
    @GetMapping("/process")
    public ResponseEntity<Map<String, String>> processData() 
            throws Exception {
        long start = System.currentTimeMillis();
        
        // Start async tasks
        Future<String> result1 = dataProcessingService.processDataSet1();
        Future<String> result2 = dataProcessingService.processDataSet2();
        
        // Wait for both to complete
        while (!result1.isDone() || !result2.isDone()) {
            Thread.sleep(100);
        }
        
        long end = System.currentTimeMillis();
        
        Map<String, String> results = new HashMap<>();
        results.put("dataset1", result1.get());
        results.put("dataset2", result2.get());
        results.put("totalTime", (end - start) + "ms");
        
        return ResponseEntity.ok(results);
    }
    
    // CompletableFuture composition
    @GetMapping("/reports")
    public CompletableFuture<Map<String, Object>> generateReports() {
        
        CompletableFuture<Report> salesFuture = 
            reportService.generateSalesReport();
        CompletableFuture<Report> inventoryFuture = 
            reportService.generateInventoryReport();
        
        // Combine both results
        return salesFuture.thenCombine(inventoryFuture, 
            (salesReport, inventoryReport) -> {
                Map<String, Object> combined = new HashMap<>();
                combined.put("sales", salesReport);
                combined.put("inventory", inventoryReport);
                combined.put("generatedAt", LocalDateTime.now());
                return combined;
            });
    }
}
```

**Step 7: Exception Handling in Async**

java

```java
@Service
public class AsyncExceptionService {
    
    @Async
    public CompletableFuture<String> riskyOperation() {
        try {
            // Simulate processing
            if (Math.random() > 0.5) {
                throw new RuntimeException("Random failure!");
            }
            return CompletableFuture.completedFuture("Success");
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
}

// Async Exception Handler
@ControllerAdvice
public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(AsyncExceptionHandler.class);
    
    @Override
    public void handleUncaughtException(
            Throwable throwable, 
            Method method, 
            Object... params) {
        
        logger.error("Async exception in method: " + method.getName());
        logger.error("Exception: " + throwable.getMessage());
        logger.error("Parameters: " + Arrays.toString(params));
    }
}

// Configure exception handler
@Configuration
@EnableAsync
public class AsyncConfigWithExceptionHandler 
        implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}
```

**Step 8: Testing Async Methods**

java

```java
@SpringBootTest
class AsyncServiceTest {
    
    @Autowired
    private DataProcessingService dataProcessingService;
    
    @Test
    void testAsyncExecution() throws Exception {
        long start = System.currentTimeMillis();
        
        Future<String> result1 = dataProcessingService.processDataSet1();
        Future<String> result2 = dataProcessingService.processDataSet2();
        
        // Wait for completion
        while (!result1.isDone() || !result2.isDone()) {
            Thread.sleep(100);
        }
        
        long end = System.currentTimeMillis();
        
        assertNotNull(result1.get());
        assertNotNull(result2.get());
        
        // Should take around 3 seconds (parallel), not 5 (sequential)
        assertTrue((end - start) < 4000);
    }
}
```

### 🔑 Key Points to Remember

-   **@Async methods must be in Spring-managed beans**
-   **Calling @Async from same class won't work**  (use proxy)
-   Configure thread pool size based on workload
-   Use CompletableFuture for complex async compositions
-   Handle exceptions properly in async methods
-   Monitor thread pool metrics in production

**Common Pitfalls**:

java

```java
// ❌ WRONG - Calling async method from same class
@Service
public class WrongService {
    @Async
    public void asyncMethod() { }
    
    public void normalMethod() {
        this.asyncMethod(); // Won't be async!
    }
}

// ✅ CORRECT - Inject bean and call
@Service
public class CorrectService {
    @Autowired
    private AsyncHelper asyncHelper;
    
    public void normalMethod() {
        asyncHelper.asyncMethod(); // Will be async
    }
}
```

----------

## 6. Logging in Spring Boot

### 🎯 Concept & Analogy

**Analogy**: Logging is like a  **flight recorder (black box)**  in an airplane. It continuously records everything happening during the flight. If something goes wrong, investigators can review the logs to understand what happened.

**Memory Visualization**:

```
Application Flow
      ↓
  Logger Levels
      ↓
┌─────────────────┐
│ TRACE (Most)    │ ← Everything
│ DEBUG           │ ← Development details
│ INFO            │ ← Important events
│ WARN            │ ← Potential issues
│ ERROR (Least)   │ ← Actual problems
└─────────────────┘
      ↓
┌──────────┬─────────┬─────────┐
│ Console  │  File   │  Cloud  │
└──────────┴─────────┴─────────┘
```

### 📚 Theory

Spring Boot uses  **Commons Logging**  internally but supports various logging frameworks:

-   **Logback**  (default)
-   **Log4j2**
-   **Java Util Logging**

**Log Levels**  (Least to Most verbose):

1.  **OFF**  - No logging
2.  **ERROR**  - Error events
3.  **WARN**  - Potentially harmful situations
4.  **INFO**  - Informational messages
5.  **DEBUG**  - Debug information
6.  **TRACE**  - Most detailed information
7.  **ALL**  - All logging

**Logging Best Practices**:

-   Use appropriate log levels
-   Include contextual information
-   Avoid logging sensitive data (passwords, credit cards)
-   Use parameterized logging for performance
-   Configure different levels for different environments

### 💻 Implementation

**Step 1: Default Logging (No Configuration)**

java

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api")
public class ProductController {
    
    // Create logger instance
    private static final Logger logger = 
        LoggerFactory.getLogger(ProductController.class);
    
    @GetMapping("/products/{id}")
    public Product getProduct(@PathVariable Long id) {
        logger.trace("TRACE: Entering getProduct method");
        logger.debug("DEBUG: Fetching product with ID: {}", id);
        logger.info("INFO: Product request received for ID: {}", id);
        
        try {
            Product product = productService.findById(id);
            logger.info("INFO: Product found: {}", product.getName());
            return product;
        } catch (Exception e) {
            logger.error("ERROR: Failed to fetch product with ID: {}", id, e);
            throw e;
        }
    }
}
```

**Step 2: Configuration via application.properties**

properties

```properties
# Root logging level
logging.level.root=INFO

# Package-specific logging levels
logging.level.com.myapp=DEBUG
logging.level.com.myapp.controller=TRACE
logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR

# Log file configuration
logging.file.name=logs/application.log
logging.file.path=logs/

# Log file rotation
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=30
logging.logback.rollingpolicy.total-size-cap=1GB

# Log pattern for console
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n

# Log pattern for file
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
```

**Step 3: Logback Configuration (logback-spring.xml)**

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>
    
    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        
        <!-- Rolling Policy -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy 
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- Error File Appender -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/error-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- JSON Appender (for log aggregation) -->
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.json</file>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"app":"my-spring-boot-app"}</customFields>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.json</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- Async Appender for better performance -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- Logger for specific package -->
    <logger name="com.myapp.controller" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </logger>
    
    <logger name="com.myapp.service" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </logger>
    
    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>
    
    <!-- Profile-specific configuration -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <root level="WARN">
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ERROR_FILE" />
            <appender-ref ref="JSON_FILE" />
        </root>
    </springProfile>
    
</configuration>
```

**Step 4: Structured Logging with MDC (Mapped Diagnostic Context)**

java

```java
@Component
public class LoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // Add contextual information to MDC
        MDC.put("requestId", UUID.randomUUID().toString());
        MDC.put("userId", getUserIdFromRequest(httpRequest));
        MDC.put("ipAddress", httpRequest.getRemoteAddr());
        MDC.put("requestUri", httpRequest.getRequestURI());
        
        try {
            chain.doFilter(request, response);
        } finally {
            // Clean up MDC
            MDC.clear();
        }
    }
    
    private String getUserIdFromRequest(HttpServletRequest request) {
        // Extract user ID from session or JWT token
        return "user123";
    }
}

// Using MDC in logs
@Service
public class OrderService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(OrderService.class);
    
    public void createOrder(Order order) {
        MDC.put("orderId", order.getId().toString());
        logger.info("Creating order"); // Will include orderId in log
        
        // Business logic
        
        MDC.remove("orderId");
    }
}
```

**Logback pattern with MDC**:

xml

```xml
<pattern>
    %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} [RequestId:%X{requestId}] [UserId:%X{userId}] - %msg%n
</pattern>
```

**Step 5: Custom Logger with Aspects**

java

```java
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(LoggingAspect.class);
    
    // Log all controller methods
    @Around("execution(* com.myapp.controller..*(..))")
    public Object logControllerMethods(ProceedingJoinPoint joinPoint) 
            throws Throwable {
        
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        
        logger.info("Entering {}.{}", className, methodName);
        
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            
            long endTime = System.currentTimeMillis();
            logger.info("Exiting {}.{} - Execution time: {}ms", 
                className, methodName, (endTime - startTime));
            
            return result;
        } catch (Exception e) {
            logger.error("Exception in {}.{}: {}", 
                className, methodName, e.getMessage(), e);
            throw e;
        }
    }
    
    // Log all service methods with parameters
    @Around("execution(* com.myapp.service..*(..))")
    public Object logServiceMethods(ProceedingJoinPoint joinPoint) 
            throws Throwable {
        
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        logger.debug("Service method: {} called with args: {}", 
            methodName, Arrays.toString(args));
        
        Object result = joinPoint.proceed();
        
        logger.debug("Service method: {} returned: {}", 
            methodName, result);
        
        return result;
    }
}
```

**Step 6: Logging Best Practices Examples**

java

```java
@Service
public class BestPracticesService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(BestPracticesService.class);
    
    // ✅ GOOD: Parameterized logging (better performance)
    public void goodLogging(String username, int age) {
        logger.info("User {} logged in, age: {}", username, age);
    }
    
    // ❌ BAD: String concatenation
    public void badLogging(String username, int age) {
        logger.info("User " + username + " logged in, age: " + age);
    }
    
    // ✅ GOOD: Guard conditions for expensive operations
    public void conditionalLogging(Object complexObject) {
        if (logger.isDebugEnabled()) {
            logger.debug("Complex object state: {}", 
                expensiveToString(complexObject));
        }
    }
    
    // ✅ GOOD: Logging exceptions with context
    public void exceptionLogging(String userId) {
        try {
            // Some operation
        } catch (Exception e) {
            logger.error("Failed to process user: {}", userId, e);
            // 'e' will print full stack trace
        }
    }
    
    // ✅ GOOD: Structured logging
    public void structuredLogging(Order order) {
        logger.info("Order processed - " +
            "orderId: {}, userId: {}, amount: {}, status: {}", 
            order.getId(), 
            order.getUserId(), 
            order.getAmount(), 
            order.getStatus()
        );
    }
    
    // ❌ BAD: Logging sensitive information
    public void dontLogSensitiveData(User user) {
        // Never log passwords, credit cards, SSN, etc.
        logger.info("User: {}", user); // If User.toString() includes password
    }
    
    // ✅ GOOD: Sanitize sensitive data
    public void sanitizeLogging(User user) {
        logger.info("User logged in: username={}, email={}", 
            user.getUsername(), 
            maskEmail(user.getEmail())
        );
    }
    
    private String maskEmail(String email) {
        return email.replaceAll("(^[^@]{3})[^@]*", "$1***");
    }
    
    private String expensiveToString(Object obj) {
        // Expensive operation
        return obj.toString();
    }
}
```

**Step 7: Log Aggregation with ELK Stack Integration**

xml

```xml
<!-- Add Logstash Logback Encoder -->
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>7.4</version>
</dependency>
```

java

```java
// Custom JSON logging
@Service
public class JsonLoggingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(JsonLoggingService.class);
    
    public void logStructuredEvent(String eventType, Map<String, Object> data) {
        ObjectNode logNode = JsonNodeFactory.instance.objectNode();
        logNode.put("eventType", eventType);
        logNode.put("timestamp", Instant.now().toString());
        logNode.set("data", convertToJsonNode(data));
        
        logger.info(logNode.toString());
    }
    
    private JsonNode convertToJsonNode(Map<String, Object> data) {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.valueToTree(data);
    }
}
```

**Step 8: Performance Monitoring with Logs**

java

```java
@Service
public class PerformanceLoggingService {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(PerformanceLoggingService.class);
    
    public void monitoredOperation(String operationName) {
        StopWatch stopWatch = new StopWatch(operationName);
        stopWatch.start();
        
        try {
            // Perform operation
            performHeavyOperation();
            
            stopWatch.stop();
            
            if (stopWatch.getTotalTimeMillis() > 1000) {
                logger.warn("Slow operation detected: {} took {}ms", 
                    operationName, 
                    stopWatch.getTotalTimeMillis()
                );
            } else {
                logger.debug("Operation {} completed in {}ms", 
                    operationName, 
                    stopWatch.getTotalTimeMillis()
                );
            }
        } catch (Exception e) {
            stopWatch.stop();
            logger.error("Operation {} failed after {}ms", 
                operationName, 
                stopWatch.getTotalTimeMillis(), 
                e
            );
            throw e;
        }
    }
    
    private void performHeavyOperation() {
        // Heavy operation
    }
}
```

**Step 9: Testing Logging**

java

```java
@SpringBootTest
class LoggingTest {
    
    @Autowired
    private ProductController productController;
    
    @Test
    void testLogging() {
        // Configure test appender
        Logger logger = (Logger) LoggerFactory.getLogger(
            ProductController.class
        );
        
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);
        
        // Execute method
        productController.getProduct(1L);
        
        // Verify logs
        List<ILoggingEvent> logsList = listAppender.list;
        
        assertTrue(logsList.stream()
            .anyMatch(event -> 
                event.getMessage().contains("Product request received")
            )
        );
    }
}
```

**Step 10: Environment-Specific Logging**

yaml

```yaml
# application-dev.yml
logging:
  level:
    root: DEBUG
    com.myapp: TRACE
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/dev-application.log

# application-prod.yml
logging:
  level:
    root: WARN
    com.myapp: INFO
  pattern:
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n"
  file:
    name: /var/log/myapp/application.log
    max-size: 100MB
    max-history: 30
```

### 🔑 Key Points to Remember

-   **Use SLF4J**  as logging facade (abstraction)
-   **Choose appropriate log levels**: ERROR for failures, WARN for potential issues, INFO for important events, DEBUG for development
-   **Use parameterized logging**  for better performance
-   **Never log sensitive data**  (passwords, tokens, PII)
-   **Configure log rotation**  to prevent disk space issues
-   **Use MDC**  for request tracing and correlation
-   **Different configurations**  for different environments
-   **Async appenders**  for better performance in production
-   **Integrate with log aggregation**  tools (ELK, Splunk, CloudWatch)

----------

## 📊 Quick Reference Comparison
<img width="818" height="247" alt="image" src="https://github.com/user-attachments/assets/7cc2f4b3-9278-4ffb-bbcf-e1d3b71d0036" />

## 💡 Real-World Scenario: Complete Application

java

```java
@SpringBootApplication
@EnableAsync
@EnableAdminServer  // If admin server
public class CompleteApplication {
    public static void main(String[] args) {
        SpringApplication.run(CompleteApplication.class, args);
    }
}

@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(OrderController.class);
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private NotificationService notificationService;
    
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody Order order) {
        // Add request ID to MDC for tracing
        MDC.put("orderId", order.getId());
        
        logger.info("Received order creation request");
        
        try {
            // Process order (sync)
            Order savedOrder = orderService.saveOrder(order);
            logger.info("Order saved successfully");
            
            // Send notifications (async - fire and forget)
            notificationService.sendOrderConfirmation(savedOrder);
            logger.debug("Order confirmation triggered");
            
            return ResponseEntity.ok(savedOrder);
        } catch (Exception e) {
            logger.error("Failed to create order", e);
            return ResponseEntity.internalServerError().build();
        } finally {
            MDC.clear();
        }
    }
}
```

----------

## 🎯 Practice Exercises

1.  **DevTools**: Create a REST API and modify it to see auto-restart
2.  **Profiles**: Configure H2 for dev, PostgreSQL for prod
3.  **Actuator**: Create custom health indicator for database
4.  **Admin**: Set up admin server with 3 client applications
5.  **Async**: Build file upload service with async processing
6.  **Logging**: Implement request/response logging with MDC

----------
