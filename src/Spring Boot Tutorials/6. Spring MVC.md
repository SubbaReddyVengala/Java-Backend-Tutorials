
# Spring Web MVC Complete Tutorial

## A Comprehensive Guide with Visualizations and Analogies

----------

## Table of Contents

1.  Introduction to Spring Web MVC
2.  Advantages of Spring Web MVC
3.  MVC Architecture
4.  Spring MVC Flow & Components
5.  Creating Spring MVC Applications
6.  Layer Architecture & Annotations
7.  Spring vs Spring Boot

----------

## 1. Introduction to Spring Web MVC

### What is Spring Web MVC?

Spring Web MVC is a **web framework** built on the Servlet API for building web applications using the Model-View-Controller design pattern. It's part of the Spring Framework ecosystem.

### Memory Visualization 🧠

Think of Spring MVC as a **restaurant system**:

-   **Customer (Browser)** → Places order (HTTP Request)
-   **Waiter (Dispatcher Servlet)** → Takes order and coordinates
-   **Chef (Controller)** → Prepares the dish (processes business logic)
-   **Recipe Book (Service Layer)** → Contains cooking instructions
-   **Pantry (Repository Layer)** → Stores ingredients (data)
-   **Plate (View)** → Presents the final dish (HTML/JSON response)

----------

## 2. Advantages of Spring Web MVC 

### Key Benefits:

1.  **Clear Separation of Concerns**
    -   Model, View, and Controller are separated
    -   Easy to maintain and test individual components
2.  **Flexible Configuration**
    -   XML, Java annotations, or Java-based configuration
    -   Choose what suits your project
3.  **Powerful Request Mapping**
    -   Map URLs to specific methods easily
    -   Support for RESTful web services
4.  **Integration with Spring Ecosystem**
    -   Dependency Injection
    -   Transaction Management
    -   Security (Spring Security)
5.  **Multiple View Technologies**
    -   JSP, Thymeleaf, FreeMarker, JSON, XML
    -   Choose based on requirements
6.  **Testing Support**
    -   Easy to write unit and integration tests
    -   Mock objects for testing

### Analogy 💡

Spring MVC is like a **Swiss Army Knife** for web development:

-   Multiple tools (features) in one package
-   Each tool specialized for specific tasks
-   Well-designed and reliable

----------

## 3. MVC Architecture

### The MVC Pattern Explained

MVC stands for **Model-View-Controller** - a design pattern that separates application into three interconnected components.

```
┌─────────────────────────────────────────┐
│           USER (Browser)                │
└────────────┬───────────▲────────────────┘
             │           │
        [1] Request  [5] Response
             │           │
             ▼           │
┌────────────────────────┼────────────────┐
│         CONTROLLER     │                │
│  (Handles user input)  │                │
│                        │                │
│  [2] ▼          [4] ▲  │                │
│    MODEL ──────────┘   │                │
│  (Business Logic       │                │
│   & Data)              │                │
│                        │                │
│  [3] ────► VIEW        │                │
│         (Presentation) │                │
└────────────────────────────────────────┘
```

### Components Breakdown:

#### 1. **Model** 🗂️

-   Represents application data and business logic
-   POJOs (Plain Old Java Objects) with data
-   Independent of user interface

**Example:**

java

```java
public class Student {
    private Long id;
    private String name;
    private String email;
    private int age;
    
    // Getters and Setters
}
```

**Analogy**: The model is like a **filing cabinet** containing all your documents (data).

#### 2. **View** 👁️

-   Presentation layer
-   Displays data from model
-   HTML, JSP, Thymeleaf templates, JSON

**Example (JSP):**

jsp

```jsp
<html>
<body>
    <h1>Student Details</h1>
    <p>Name: ${student.name}</p>
    <p>Email: ${student.email}</p>
</body>
</html>
```

**Analogy**: The view is like a **picture frame** - it displays the content beautifully.

#### 3. **Controller** 🎮

-   Handles user requests
-   Updates model
-   Selects appropriate view
-   Acts as intermediary

**Example:**

java

```java
@Controller
public class StudentController {
    
    @GetMapping("/student/{id}")
    public String getStudent(@PathVariable Long id, Model model) {
        Student student = studentService.findById(id);
        model.addAttribute("student", student);
        return "studentView"; // View name
    }
}
```

**Analogy**: The controller is like a **traffic cop** - directing requests to the right destination.

----------

## 4. Spring MVC Flow & Components 

### Complete Request-Response Flow

```
[Browser] 
    │
    │ 1. HTTP Request (GET /students/123)
    ▼
[Dispatcher Servlet] ◄─── Front Controller
    │
    │ 2. Consults Handler Mapping
    ▼
[Handler Mapping]
    │
    │ 3. Returns Controller info
    ▼
[Dispatcher Servlet]
    │
    │ 4. Calls appropriate method
    ▼
[Controller] ◄─────────── @Controller
    │
    │ 5. Calls business logic
    ▼
[Service Layer] ◄──────── @Service
    │
    │ 6. Calls data layer
    ▼
[Repository Layer] ◄────── @Repository
    │
    │ 7. Database query
    ▼
[Database]
    │
    │ 8. Returns data
    ▼
[Repository] ──► [Service] ──► [Controller]
    │
    │ 9. Returns ModelAndView
    ▼
[Dispatcher Servlet]
    │
    │ 10. Consults View Resolver
    ▼
[View Resolver]
    │
    │ 11. Returns View object
    ▼
[View (JSP/Thymeleaf)]
    │
    │ 12. Renders HTML
    ▼
[Dispatcher Servlet]
    │
    │ 13. HTTP Response
    ▼
[Browser]
```

### Key Components Explained:

#### A. Front Controller Pattern

**What is Front Controller?**

The Front Controller Design Pattern provides a **centralized entry point** for handling all requests in a web application.

**Real-World Analogy**: Think of a **hotel reception desk**:

-   All guests (requests) come to reception first
-   Reception (front controller) directs them to appropriate rooms (controllers)
-   Reception handles common tasks: security check, logging, etc.

**Benefits:**

-   Centralized control
-   Common functionality in one place
-   Easy to maintain
-   Reduces code duplication

#### B. Dispatcher Servlet

**What is Dispatcher Servlet?**

DispatcherServlet is Spring MVC's **implementation of the Front Controller pattern**. It's the heart of Spring MVC.

**Configuration (web.xml - Traditional Spring):**

xml

```xml
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

**Responsibilities:**

1.  Receives all HTTP requests
2.  Delegates to appropriate handlers
3.  Manages view resolution
4.  Handles exceptions
5.  Returns response

**Memory Visualization:**

```
DispatcherServlet = Orchestra Conductor 🎼
- Coordinates all musicians (components)
- Ensures harmony in execution
- Controls timing and flow
```

#### C. Handler Mappings

**What are Handler Mappings?**

Handler Mappings determine which controller should handle a specific request based on URL patterns.

**Types:**

1.  **RequestMappingHandlerMapping** (Default - Annotation-based)
2.  **SimpleUrlHandlerMapping** (URL-based)
3.  **BeanNameUrlHandlerMapping** (Bean name-based)

**Example:**

java

```java
@Controller
@RequestMapping("/api/students")
public class StudentController {
    
    // Handles: GET /api/students
    @GetMapping
    public String listStudents(Model model) {
        // logic
    }
    
    // Handles: GET /api/students/123
    @GetMapping("/{id}")
    public String getStudent(@PathVariable Long id) {
        // logic
    }
    
    // Handles: POST /api/students
    @PostMapping
    public String createStudent(@RequestBody Student student) {
        // logic
    }
}
```

**Analogy**: Handler Mapping is like a **phone directory** - it knows which controller to call for each URL.

----------

## 5. Creating Spring MVC Applications 

### A. Traditional Spring MVC Application

#### Step 1: Project Structure

```
spring-mvc-app/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/
│   │   │       ├── controller/
│   │   │       │   └── StudentController.java
│   │   │       ├── service/
│   │   │       │   ├── StudentService.java
│   │   │       │   └── StudentServiceImpl.java
│   │   │       ├── repository/
│   │   │       │   └── StudentRepository.java
│   │   │       └── model/
│   │   │           └── Student.java
│   │   ├── resources/
│   │   │   └── application.properties
│   │   └── webapp/
│   │       ├── WEB-INF/
│   │       │   ├── web.xml
│   │       │   ├── dispatcher-servlet.xml
│   │       │   └── views/
│   │       │       └── students.jsp
│   │       └── resources/
│   │           └── css/
│   └── test/
└── pom.xml
```

#### Step 2: Dependencies (pom.xml)

xml

```xml
<dependencies>
    <!-- Spring MVC -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.23</version>
    </dependency>
    
    <!-- Servlet API -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
    </dependency>
    
    <!-- JSP and JSTL -->
    <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>jsp-api</artifactId>
        <version>2.2</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
```

#### Step 3: web.xml Configuration

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         version="4.0">
    
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/dispatcher-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### Step 4: dispatcher-servlet.xml

xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc">
    
    <!-- Enable component scanning -->
    <context:component-scan base-package="com.example" />
    
    <!-- Enable Spring MVC annotations -->
    <mvc:annotation-driven />
    
    <!-- View Resolver -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".jsp" />
    </bean>
</beans>
```

### B. Spring Boot MVC Application

#### Step 1: Project Structure

```
springboot-mvc-app/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/
│   │   │       ├── SpringBootMvcApplication.java
│   │   │       ├── controller/
│   │   │       ├── service/
│   │   │       ├── repository/
│   │   │       └── model/
│   │   └── resources/
│   │       ├── application.properties
│   │       ├── templates/  (for Thymeleaf)
│   │       └── static/     (CSS, JS, images)
│   └── test/
└── pom.xml
```

#### Step 2: Dependencies (pom.xml)

xml

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
</parent>

<dependencies>
    <!-- Spring Boot Web Starter (includes MVC) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Thymeleaf for views -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
</dependencies>
```

#### Step 3: Main Application Class

java

```java
package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // Combines @Configuration, @EnableAutoConfiguration, @ComponentScan
public class SpringBootMvcApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(SpringBootMvcApplication.class, args);
    }
}
```

#### Step 4: application.properties

properties

```properties
# Server configuration
server.port=8080

# Thymeleaf configuration
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.cache=false
```

----------

## 6. Layer Architecture & Annotations 
### Three-Layer Architecture

```
┌─────────────────────────────────────┐
│     PRESENTATION LAYER              │
│       @Controller                   │
│  - Handles HTTP requests            │
│  - Returns views/JSON               │
│  - Input validation                 │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│     BUSINESS LAYER                  │
│       @Service                      │
│  - Business logic                   │
│  - Transaction management           │
│  - Coordinates between layers       │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│     DATA ACCESS LAYER               │
│       @Repository                   │
│  - Database operations              │
│  - CRUD operations                  │
│  - Query execution                  │
└──────────────┬──────────────────────┘
               │
               ▼
         [DATABASE]
```

### Stereotype Annotations

#### What are Stereotype Annotations?

Stereotype annotations are **markers** that indicate a class serves a particular role in the application architecture. Spring automatically detects and registers these classes as beans.

**Base Annotation**: `@Component` (Generic stereotype)

**Specialized Annotations**:

-   `@Controller` - Presentation layer
-   `@Service` - Business layer
-   `@Repository` - Data access layer

----------

### A. @Controller Annotation

**Purpose**: Marks a class as a Spring MVC controller that handles web requests.

**Key Features**:

-   Handles HTTP requests
-   Returns views or data
-   Supports request mapping
-   Automatic exception handling

**Complete Example:**

java

```java
package com.example.controller;

import com.example.model.Student;
import com.example.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
@RequestMapping("/students")
public class StudentController {
    
    @Autowired
    private StudentService studentService;
    
    // Display all students
    // URL: GET /students
    @GetMapping
    public String listStudents(Model model) {
        List<Student> students = studentService.getAllStudents();
        model.addAttribute("students", students);
        return "student-list"; // Returns view name
    }
    
    // Show form for new student
    // URL: GET /students/new
    @GetMapping("/new")
    public String showCreateForm(Model model) {
        model.addAttribute("student", new Student());
        return "student-form";
    }
    
    // Save new student
    // URL: POST /students
    @PostMapping
    public String saveStudent(@ModelAttribute Student student) {
        studentService.saveStudent(student);
        return "redirect:/students"; // Redirect after POST
    }
    
    // Display student by ID
    // URL: GET /students/5
    @GetMapping("/{id}")
    public String getStudent(@PathVariable Long id, Model model) {
        Student student = studentService.getStudentById(id);
        model.addAttribute("student", student);
        return "student-detail";
    }
    
    // Delete student
    // URL: DELETE /students/5
    @DeleteMapping("/{id}")
    public String deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return "redirect:/students";
    }
}
```

**@RestController** (Special variant):

java

```java
@RestController // = @Controller + @ResponseBody
@RequestMapping("/api/students")
public class StudentRestController {
    
    @Autowired
    private StudentService studentService;
    
    // Returns JSON directly (not a view name)
    @GetMapping
    public List<Student> getAllStudents() {
        return studentService.getAllStudents();
    }
    
    @GetMapping("/{id}")
    public Student getStudent(@PathVariable Long id) {
        return studentService.getStudentById(id);
    }
}
```

**Memory Analogy**: Controller is like a **restaurant waiter**:

-   Takes orders (requests) from customers (browser)
-   Communicates with kitchen (service layer)
-   Serves food (response) to customers

----------

### B. @Service Annotation

**Purpose**: Marks a class as a service layer component containing business logic.

**Key Features**:

-   Business logic encapsulation
-   Transaction management
-   Coordinates between controller and repository
-   Reusable business operations

**Complete Example:**

java

```java
package com.example.service;

import com.example.model.Student;
import com.example.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional // Manages transactions for all methods
public class StudentService {
    
    @Autowired
    private StudentRepository studentRepository;
    
    // Business logic: Get all students
    public List<Student> getAllStudents() {
        return studentRepository.findAll();
    }
    
    // Business logic: Get student by ID with validation
    public Student getStudentById(Long id) {
        return studentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Student not found with id: " + id));
    }
    
    // Business logic: Save student with validation
    public Student saveStudent(Student student) {
        // Validation logic
        if (student.getAge() < 18) {
            throw new IllegalArgumentException("Student must be 18 or older");
        }
        
        // Check duplicate email
        if (studentRepository.existsByEmail(student.getEmail())) {
            throw new IllegalArgumentException("Email already exists");
        }
        
        return studentRepository.save(student);
    }
    
    // Business logic: Update student
    public Student updateStudent(Long id, Student updatedStudent) {
        Student existingStudent = getStudentById(id);
        existingStudent.setName(updatedStudent.getName());
        existingStudent.setEmail(updatedStudent.getEmail());
        existingStudent.setAge(updatedStudent.getAge());
        return studentRepository.save(existingStudent);
    }
    
    // Business logic: Delete student
    public void deleteStudent(Long id) {
        if (!studentRepository.existsById(id)) {
            throw new RuntimeException("Cannot delete. Student not found with id: " + id);
        }
        studentRepository.deleteById(id);
    }
    
    // Custom business logic: Find students by age range
    public List<Student> findStudentsByAgeRange(int minAge, int maxAge) {
        return studentRepository.findByAgeBetween(minAge, maxAge);
    }
    
    // Business logic with multiple repository calls
    public long getStudentCountByDepartment(String department) {
        return studentRepository.countByDepartment(department);
    }
}
```

**Why separate Service layer?**

Without Service Layer (BAD):

java

```java
@Controller
public class StudentController {
    @Autowired
    private StudentRepository repository;
    
    @PostMapping("/students")
    public String saveStudent(@ModelAttribute Student student) {
        // Business logic mixed with controller - BAD!
        if (student.getAge() < 18) {
            throw new IllegalArgumentException("Too young");
        }
        repository.save(student);
        return "redirect:/students";
    }
}
```

With Service Layer (GOOD):

java

```java
@Controller
public class StudentController {
    @Autowired
    private StudentService service; // Clean separation
    
    @PostMapping("/students")
    public String saveStudent(@ModelAttribute Student student) {
        service.saveStudent(student); // Business logic in service
        return "redirect:/students";
    }
}
```

**Memory Analogy**: Service is like a **restaurant chef**:

-   Knows recipes (business logic)
-   Validates ingredients (data validation)
-   Coordinates cooking steps (multiple operations)
-   Can use ingredients from pantry (repository)

----------

### C. @Repository Annotation

**Purpose**: Marks a class as a Data Access Object (DAO) that interacts with the database.

**Key Features**:

-   Database operations
-   CRUD operations
-   Exception translation (SQLException → DataAccessException)
-   Query methods

**Complete Example:**

java

```java
package com.example.repository;

import com.example.model.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Spring Data JPA automatically implements basic CRUD:
    // - save(Student s)
    // - findById(Long id)
    // - findAll()
    // - deleteById(Long id)
    // - count()
    
    // Custom query methods (Spring generates queries automatically)
    
    // Find by email
    Optional<Student> findByEmail(String email);
    
    // Check if email exists
    boolean existsByEmail(String email);
    
    // Find by name (case-insensitive)
    List<Student> findByNameIgnoreCase(String name);
    
    // Find by age range
    List<Student> findByAgeBetween(int minAge, int maxAge);
    
    // Find by name containing (like search)
    List<Student> findByNameContaining(String keyword);
    
    // Find by department
    List<Student> findByDepartment(String department);
    
    // Count students by department
    long countByDepartment(String department);
    
    // Custom JPQL query
    @Query("SELECT s FROM Student s WHERE s.age > :age ORDER BY s.name")
    List<Student> findStudentsOlderThan(@Param("age") int age);
    
    // Native SQL query
    @Query(value = "SELECT * FROM students WHERE email LIKE %:domain%", 
           nativeQuery = true)
    List<Student> findByEmailDomain(@Param("domain") String domain);
    
    // Delete by email
    void deleteByEmail(String email);
}
```

**Traditional @Repository Implementation (without Spring Data JPA):**

java

```java
package com.example.repository;

import com.example.model.Student;
import org.springframework.stereotype.Repository;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.List;
import java.util.Optional;

@Repository
public class StudentRepositoryImpl {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public Student save(Student student) {
        if (student.getId() == null) {
            entityManager.persist(student);
            return student;
        } else {
            return entityManager.merge(student);
        }
    }
    
    public Optional<Student> findById(Long id) {
        Student student = entityManager.find(Student.class, id);
        return Optional.ofNullable(student);
    }
    
    public List<Student> findAll() {
        return entityManager
            .createQuery("SELECT s FROM Student s", Student.class)
            .getResultList();
    }
    
    public void deleteById(Long id) {
        Student student = entityManager.find(Student.class, id);
        if (student != null) {
            entityManager.remove(student);
        }
    }
}
```

**Model Class:**

java

```java
package com.example.model;

import javax.persistence.*;

@Entity
@Table(name = "students")
public class Student {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private int age;
    
    private String department;
    
    // Constructors
    public Student() {}
    
    public Student(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public String getDepartment() {
        return department;
    }
    
    public void setDepartment(String department) {
        this.department = department;
    }
}
```

**Memory Analogy**: Repository is like a **warehouse manager**:

-   Knows where everything is stored (database)
-   Retrieves items when needed (queries)
-   Stores new items (insert)
-   Updates inventory (update)
-   Removes items (delete)

----------

### Complete Flow Example

Let's trace a complete request through all layers:

**Request**: `GET /students/5`

java

```java
// 1. CONTROLLER - Receives request
@Controller
@RequestMapping("/students")
public class StudentController {
    @Autowired
    private StudentService studentService;
    
    @GetMapping("/{id}")
    public String getStudent(@PathVariable Long id, Model model) {
        Student student = studentService.getStudentById(id); // Calls service
        model.addAttribute("student", student);
        return "student-detail";
    }
}

// 2. SERVICE - Business logic
@Service
public class StudentService {
    @Autowired
    private StudentRepository studentRepository;
    
    public Student getStudentById(Long id) {
        // Add business logic here
        return studentRepository.findById(id) // Calls repository
                .orElseThrow(() -> new RuntimeException("Student not found"));
    }
}

// 3. REPOSITORY - Database access
@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    // findById() is provided by JpaRepository
}

// 4. MODEL - Data structure
@Entity
public class Student {
    @Id
    private Long id;
    private String name;
    private String email;
    // ... getters and setters
}
```

**Flow Visualization:**

```
Browser
  │ GET /students/5
  ▼
DispatcherServlet
  │
  ▼
StudentController.getStudent(5)
  │ "Get me student with id=5"
  ▼
StudentService.getStudentById(5)
  │ "Find student 5 in database"
  ▼
StudentRepository.findById(5)
  │ SQL: SELECT * FROM students WHERE id=5
  ▼
Database
  │ Returns: {id:5, name:"John", email:"john@example.com"}
  ▼
StudentRepository
  │ Returns Student object
  ▼
StudentService
  │ Returns Student object
  ▼
StudentController
  │ Adds student to Model
  │ Returns view name: "student-detail"
  ▼
ViewResolver
  │ Resolves to: /WEB-INF/views/student-detail.jsp
  ▼
View (JSP)
  │ Renders HTML with student data
  ▼
DispatcherServlet
  │
  ▼
Browser (HTML page displayed)
```

----------

## 7. Spring vs Spring Boot MVC 

### Comparison Table

<img width="822" height="396" alt="image" src="https://github.com/user-attachments/assets/ecdf7e7f-2dee-420e-b287-cb2ecf2969cc" />




### Detailed Differences

#### 1. Configuration Complexity

**Traditional Spring MVC:**

xml

```xml
<!-- web.xml -->
<web-app>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-config.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>

<!-- spring-config.xml -->
<beans>
    <context:component-scan base-package="com.example" />
    <mvc:annotation-driven />
    
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/" />
        <property name="suffix" value=".jsp" />
    </bean>
    
    <bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver" />
        <property name="url" value="jdbc:mysql://localhost:3306/mydb" />
        <property name="username" value="root" />
        <property name="password" value="password" />
    </bean>
</beans>
```

**Spring Boot MVC:**

java

```java
// SpringBootApplication.java - That's it!
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// application.properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
```

**Memory Analogy**:

-   **Spring MVC** = Building a house from scratch (need blueprints, materials, tools)
-   **Spring Boot** = Moving into a furnished apartment (everything ready to use)

----------

#### 2. Dependencies Management

**Traditional Spring MVC (pom.xml):**

xml

```xml
<dependencies>
    <!-- Need to manage versions manually -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.23</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.23</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-orm</artifactId>
        <version>5.3.23</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
    </dependency>
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>5.6.10.Final</version>
    </dependency>
    <!-- Many more individual dependencies... -->
</dependencies>
```

**Spring Boot MVC (pom.xml):**

xml

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
</parent>

<dependencies>
    <!-- Starter includes everything needed -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
</dependencies>
```

**Analogy**:

-   **Spring MVC** = Grocery shopping - buy each ingredient separately
-   **Spring Boot Starters** = Meal kit - everything bundled together

----------

#### 3. Server Configuration

**Traditional Spring MVC:**

-   Need external server (Tomcat, Jetty, WildFly)
-   Deploy WAR file to server
-   Configure server separately
-   Server starts independently

**Spring Boot:**

java

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        // Embedded Tomcat starts automatically!
    }
}

// Run as: java -jar myapp.jar
```

**Embedded Server Benefits:**

-   No separate installation needed
-   Consistent across environments
-   Easy deployment
-   Single executable JAR

----------

#### 4. Auto-Configuration Magic

**Spring Boot Auto-Configuration** automatically configures beans based on:

1.  Dependencies in classpath
2.  Properties in application.properties
3.  Existing bean definitions

**Example: DataSource Auto-Configuration**

Traditional Spring:

xml

```xml
<bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver" />
    <property name="url" value="jdbc:mysql://localhost:3306/mydb" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maxTotal" value="10" />
    <property name="maxIdle" value="5" />
</bean>

<bean id="entityManagerFactory" 
      class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="dataSource" ref="dataSource" />
    <property name="packagesToScan" value="com.example.model" />
    <!-- More configuration... -->
</bean>
```

Spring Boot:

properties

```properties
# application.properties - That's all!
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
```

Spring Boot automatically:

-   Creates DataSource bean
-   Configures connection pool
-   Sets up EntityManagerFactory
-   Configures transaction manager

----------

#### 5. View Resolver Configuration

**Traditional Spring MVC:**

xml

```xml
<!-- dispatcher-servlet.xml -->
<bean id="viewResolver" 
      class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/views/" />
    <property name="suffix" value=".jsp" />
    <property name="viewClass" 
              value="org.springframework.web.servlet.view.JstlView" />
</bean>
```

**Spring Boot:**

properties

```properties
# application.properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

# For Thymeleaf (auto-configured)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
```

----------

### Complete Comparison Example

Let's create the same Student CRUD application in both approaches:

#### Traditional Spring MVC Application

**Project Structure:**

```
spring-mvc-app/
├── src/main/java/
│   └── com/example/
│       ├── config/
│       │   └── WebConfig.java
│       ├── controller/
│       │   └── StudentController.java
│       ├── service/
│       │   └── StudentService.java
│       ├── repository/
│       │   └── StudentRepository.java
│       └── model/
│           └── Student.java
├── src/main/webapp/
│   ├── WEB-INF/
│   │   ├── web.xml
│   │   └── views/
│   │       └── students.jsp
└── pom.xml
```

**WebConfig.java:**

java

```java
@Configuration
@EnableWebMvc
@ComponentScan("com.example")
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
    
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/school");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
}
```

**web.xml:**

xml

```xml
<web-app>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.example.config.WebConfig</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

----------

#### Spring Boot MVC Application

**Project Structure:**

```
springboot-mvc-app/
├── src/main/java/
│   └── com/example/
│       ├── Application.java
│       ├── controller/
│       │   └── StudentController.java
│       ├── service/
│       │   └── StudentService.java
│       ├── repository/
│       │   └── StudentRepository.java
│       └── model/
│           └── Student.java
├── src/main/resources/
│   ├── application.properties
│   └── templates/
│       └── students.html
└── pom.xml
```

**Application.java:**

java

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**application.properties:**

properties

```properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/school
spring.datasource.username=root
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

**That's it!** No web.xml, no manual configuration classes needed.

----------

### When to Use Which?

#### Use Traditional Spring MVC When:

1.  **Legacy Applications** - Maintaining existing Spring MVC apps
2.  **Fine-Grained Control** - Need complete control over every configuration
3.  **Learning** - Understanding Spring internals deeply
4.  **Custom Requirements** - Very specific configurations not covered by Boot

#### Use Spring Boot When:

1.  **New Projects** - Starting fresh applications
2.  **Microservices** - Building cloud-native applications
3.  **Rapid Development** - Quick prototypes and MVPs
4.  **Modern Applications** - Following current best practices
5.  **Production Ready** - Need monitoring, health checks out of the box

**Recommendation**: For 99% of modern applications, **use Spring Boot**. It's the industry standard now.

----------

## 8. Complete Working Examples

### Example 1: Simple Student Management (Spring Boot)

**Student.java**

java

```java
@Entity
@Table(name = "students")
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    private int age;
    private String department;
    
    // Constructors, Getters, Setters
}
```

**StudentRepository.java**

java

```java
@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    List<Student> findByDepartment(String department);
    Optional<Student> findByEmail(String email);
}
```

**StudentService.java**

java

```java
@Service
public class StudentService {
    @Autowired
    private StudentRepository repository;
    
    public List<Student> getAllStudents() {
        return repository.findAll();
    }
    
    public Student saveStudent(Student student) {
        return repository.save(student);
    }
    
    public Student getStudentById(Long id) {
        return repository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Student not found"));
    }
    
    public void deleteStudent(Long id) {
        repository.deleteById(id);
    }
}
```

**StudentController.java**

java

```java
@Controller
@RequestMapping("/students")
public class StudentController {
    
    @Autowired
    private StudentService studentService;
    
    // Display all students
    @GetMapping
    public String listStudents(Model model) {
        model.addAttribute("students", studentService.getAllStudents());
        return "students/list";
    }
    
    // Show create form
    @GetMapping("/new")
    public String showCreateForm(Model model) {
        model.addAttribute("student", new Student());
        return "students/form";
    }
    
    // Save student
    @PostMapping
    public String saveStudent(@ModelAttribute Student student) {
        studentService.saveStudent(student);
        return "redirect:/students";
    }
    
    // Show edit form
    @GetMapping("/edit/{id}")
    public String showEditForm(@PathVariable Long id, Model model) {
        model.addAttribute("student", studentService.getStudentById(id));
        return "students/form";
    }
    
    // Delete student
    @GetMapping("/delete/{id}")
    public String deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return "redirect:/students";
    }
}
```

**Thymeleaf Template (list.html)**

html

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Student List</title>
</head>
<body>
    <h1>Student List</h1>
    <a th:href="@{/students/new}">Add New Student</a>
    
    <table>
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Email</th>
                <th>Age</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr th:each="student : ${students}">
                <td th:text="${student.id}"></td>
                <td th:text="${student.name}"></td>
                <td th:text="${student.email}"></td>
                <td th:text="${student.age}"></td>
                <td>
                    <a th:href="@{/students/edit/{id}(id=${student.id})}">Edit</a>
                    <a th:href="@{/students/delete/{id}(id=${student.id})}">Delete</a>
                </td>
            </tr>
        </tbody>
    </table>
</body>
</html>
```

----------

### Example 2: REST API (Spring Boot)

**StudentRestController.java**

java

```java
@RestController
@RequestMapping("/api/students")
public class StudentRestController {
    
    @Autowired
    private StudentService studentService;
    
    // GET /api/students
    @GetMapping
    public ResponseEntity<List<Student>> getAllStudents() {
        return ResponseEntity.ok(studentService.getAllStudents());
    }
    
    // GET /api/students/5
    @GetMapping("/{id}")
    public ResponseEntity<Student> getStudent(@PathVariable Long id) {
        return ResponseEntity.ok(studentService.getStudentById(id));
    }
    
    // POST /api/students
    @PostMapping
    public ResponseEntity<Student> createStudent(@RequestBody Student student) {
        Student saved = studentService.saveStudent(student);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }
    
    // PUT /api/students/5
    @PutMapping("/{id}")
    public ResponseEntity<Student> updateStudent(
            @PathVariable Long id,
            @RequestBody Student student) {
        student.setId(id);
        Student updated = studentService.saveStudent(student);
        return ResponseEntity.ok(updated);
    }
    
    // DELETE /api/students/5
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return ResponseEntity.noContent().build();
    }
}
```

**Testing with cURL:**

bash

```bash
# Create student
curl -X POST http://localhost:8080/api/students \
  -H "Content-Type: application/json" \
  -d '{"name":"John Doe","email":"john@example.com","age":20}'

# Get all students
curl http://localhost:8080/api/students

# Get student by ID
curl http://localhost:8080/api/students/1

# Update student
curl -X PUT http://localhost:8080/api/students/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"John Updated","email":"john@example.com","age":21}'

# Delete student
curl -X DELETE http://localhost:8080/api/students/1
```

----------

## 9. Key Concepts - Memory Mnemonics

### Remember Spring MVC Flow: "DHCSVVR"

-   **D**ispatcher Servlet receives request
-   **H**andler Mapping finds controller
-   **C**ontroller processes request
-   **S**ervice handles business logic
-   **V**iew name returned
-   **V**iew Resolver finds actual view
-   **R**esponse sent to client

### Remember Layer Architecture: "CPR"

-   **C**ontroller - Presentation (handles requests)
-   **P**rocessor/Service - Business logic
-   **R**epository - Data access

### Remember Stereotype Annotations: "CSR"

-   **C**ontroller - Web layer
-   **S**ervice - Business layer
-   **R**epository - Data layer

----------

## 10. Common Pitfalls & Best Practices

### ❌ Common Mistakes

1.  **Mixing Concerns**

java

```java
// BAD: Business logic in controller
@Controller
public class StudentController {
    @Autowired
    private StudentRepository repository;
    
    @PostMapping("/students")
    public String save(@ModelAttribute Student student) {
        if (student.getAge() < 18) { // Business logic here!
            throw new IllegalArgumentException("Too young");
        }
        repository.save(student); // Direct repository access!
        return "redirect:/students";
    }
}
```

2.  **Not Using Service Layer**

java

```java
// BAD: Controller directly using repository
@Controller
public class StudentController {
    @Autowired
    private StudentRepository repository; // Skip service layer
}
```

3.  **Missing Exception Handling**

java

```java
// BAD: No exception handling
@GetMapping("/{id}")
public String getStudent(@PathVariable Long id, Model model) {
    Student student = repository.findById(id).get(); // May throw NoSuchElementException
    model.addAttribute("student", student);
    return "student-detail";
}
```

### ✅ Best Practices

1.  **Proper Layer Separation**

java

```java
// GOOD: Clean separation
@Controller
public class StudentController {
    @Autowired
    private StudentService service; // Use service layer
    
    @PostMapping("/students")
    public String save(@ModelAttribute Student student) {
        service.saveStudent(student); // Service handles validation
        return "redirect:/students";
    }
}
```

2.  **Exception Handling**

java

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
```

3.  **Input Validation**

java

```java
@PostMapping
public String saveStudent(@Valid @ModelAttribute Student student,
                          BindingResult result) {
    if (result.hasErrors()) {
        return "students/form";
    }
    studentService.saveStudent(student);
    return "redirect:/students";
}
```

----------

## 11. Summary & Quick Reference

### Spring MVC Request Flow (Simplified)

```
Request → DispatcherServlet → HandlerMapping → Controller 
→ Service → Repository → Database
→ Repository → Service → Controller → ViewResolver → View 
→ DispatcherServlet → Response
```

### Key Annotations Quick Reference
<img width="820" height="547" alt="image" src="https://github.com/user-attachments/assets/0a28e2d0-7452-42cd-bb13-a4e1754035d5" />

----------

## Conclusion

Spring Web MVC provides a robust, flexible framework for building web applications. Spring Boot further simplifies development with auto-configuration and embedded servers.

### Key Takeaways:

1.  **MVC Pattern** separates concerns: Model, View, Controller
2.  **DispatcherServlet** is the Front Controller managing all requests
3.  **Three-layer architecture**: Controller → Service → Repository
4.  **Spring Boot** dramatically simplifies Spring MVC development
5.  **Stereotype annotations** (@Controller, @Service, @Repository) define component roles
